using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using ClientPackets;
using Server.MirDatabase;
using Server.MirEnvir;
using Server.MirNetwork;
using S = ServerPackets;
using System.Text.RegularExpressions;
using Server.MirObjects.Monsters;

namespace Server.MirObjects
{
    public sealed class PlayerObject : MapObject
    {
        private long NextTradeTime;
        private long NextGroupInviteTime;

        public string GMPassword = Settings.GMPassword;
        public bool IsGM, GMLogin, GMNeverDie, GMGameMaster, EnableGroupRecall, EnableGuildInvite, AllowMarriage, AllowLoverRecall, AllowMentor, HasMapShout, HasServerShout; //TODO - Remove

        public bool HasUpdatedBaseStats = true;

        public long LastRecallTime, LastRevivalTime, LastTeleportTime, LastProbeTime;
        public long MenteeEXP;

        public short TransformType;
        public short Looks_Armour = 0, Looks_Weapon = -1, Looks_WeaponEffect = 0;
		public byte Looks_Wings = 0;

        public bool WarZone = false;

        public int CurrentRT = 0;
        public override ObjectType Race
        {
            get { return ObjectType.Player; }
        }

        public CharacterInfo Info;
        public AccountInfo Account;
        public MirConnection Connection;
        public Reporting Report;

        public override string Name
        {
            get { return Info.Name; }
            set { /*Check if Name exists.*/ }
        }

        public override int CurrentMapIndex
        {
            get { return Info.CurrentMapIndex; }
            set { Info.CurrentMapIndex = value; }
        }
        public override Point CurrentLocation
        {
            get { return Info.CurrentLocation; }
            set { Info.CurrentLocation = value; }
        }
        public override MirDirection Direction
        {
            get { return Info.Direction; }
            set { Info.Direction = value; }
        }
        public override ushort Level
        {
            get { return Info.Level; }
            set { Info.Level = value; }
        }
        public override ushort Reborn
        {
            get { return Info.Reborn; }
            set { Info.Reborn = value; }
        }
        public override ushort InstanceStage
        {
            get { return Info.InstanceStage; }
            set { Info.InstanceStage = value; }
        }
        public override ushort ChallengeStage
        {
            get { return Info.ChallengeStage; }
            set { Info.ChallengeStage = value; }
        }

        public override int Health
        {
            get { return HP; }
        }

        public override int MaxHealth
        {
            get { return Stats[Stat.HP]; }
        }

        public int HP
        {
            get { return Info.HP; }
            set { Info.HP = value; }
        }

        public int MP
        {
            get { return Info.MP; }
            set { Info.MP = value; }
        }

        public override AttackMode AMode
        {
            get { return Info.AMode; }
            set { Info.AMode = value; }
        }
        public override PetMode PMode
        {
            get { return Info.PMode; }
            set { Info.PMode = value; }
        }

        public long Experience
        {
            set { Info.Experience = value; }
            get { return Info.Experience; }
        }

        public long MaxExperience;

        public bool NewMail = false;

        public override int PKPoints
        {
            get { return Info.PKPoints; }
            set { Info.PKPoints = value; }
        }

        public byte Hair
        {
            get { return Info.Hair; }
            set { Info.Hair = value; }
        }
        public MirClass Class
        {
            get { return Info.Class; }
        }
        public MirGender Gender
        { get { return Info.Gender; } }

        public int BindMapIndex
        {
            get { return Info.BindMapIndex; }
            set { Info.BindMapIndex = value; }
        }
        public Point BindLocation
        {
            get { return Info.BindLocation; }
            set { Info.BindLocation = value; }
        }

        public bool RidingMount;
        public MountInfo Mount
        {
            get { return Info.Mount; }
        }
        public short MountType
        {
            get { return Mount.MountType; }
            set { Mount.MountType = value; }
        }

        public int FishingChance, FishingChanceCounter, FishingProgressMax, FishingProgress, FishingAutoReelChance = 0, FishingNibbleChance = 0;
        public bool Fishing, FishingAutocast, FishFound, FishFirstFound;

        public bool CanMove
        {
            get { return !Dead && Envir.Time >= ActionTime && !Fishing && !CurrentPoison.HasFlag(PoisonType.Paralysis) && !CurrentPoison.HasFlag(PoisonType.LRParalysis) && !CurrentPoison.HasFlag(PoisonType.Frozen); }
        }
        public bool CanWalk
        {
            get { return !Dead && Envir.Time >= ActionTime && !InTrapRock && !Fishing && !CurrentPoison.HasFlag(PoisonType.Paralysis) && !CurrentPoison.HasFlag(PoisonType.LRParalysis) && !CurrentPoison.HasFlag(PoisonType.Frozen); }
        }
        public bool CanRun
        {
            get { return !Dead && Envir.Time >= ActionTime && (_stepCounter > 0 || FastRun) && (!Sneaking || ActiveSwiftFeet) && CurrentBagWeight <= Stats[Stat.BagWeight] && !CurrentPoison.HasFlag(PoisonType.Paralysis) && !CurrentPoison.HasFlag(PoisonType.LRParalysis) && !CurrentPoison.HasFlag(PoisonType.Frozen); }
        }
        public bool CanAttack
        {
            get
            {
                return !Dead && Envir.Time >= ActionTime && Envir.Time >= AttackTime && !CurrentPoison.HasFlag(PoisonType.Paralysis) && !CurrentPoison.HasFlag(PoisonType.LRParalysis) && !CurrentPoison.HasFlag(PoisonType.Frozen) && !CurrentPoison.HasFlag(PoisonType.Dazed) && Mount.CanAttack && !Fishing;
            }
        }

        public bool CanRegen
        {
            //get { return Envir.Time >= RegenTime && _runCounter == 0; }
            get { return Envir.Time >= RegenTime; }
        }
        public bool CanStandRegen
        {
            get { return Envir.Time >= RegenStandTime && _runCounter == 0; }
        }
        private bool CanCast
        {
            get
            {
                return !Dead && Envir.Time >= ActionTime && Envir.Time >= SpellTime && !CurrentPoison.HasFlag(PoisonType.Stun) && !CurrentPoison.HasFlag(PoisonType.Dazed) &&
                    !CurrentPoison.HasFlag(PoisonType.Paralysis) && !CurrentPoison.HasFlag(PoisonType.Frozen) && Mount.CanAttack && !Fishing;
            }
        }

        public const long YYBDelay = 1000, TurnDelay = 350, MoveDelay = 600, HarvestDelay = 350, RegenDelay = 10000, PotDelay = 200, HealDelay = 600, DuraDelay = 10000, VampDelay = 500, LoyaltyDelay = 1000, FishingCastDelay = 750, FishingDelay = 200, ItemExpireDelay = 60000, MovementDelay = 2000;
        public long RegenStandTime, YYBTime, ActionTime, RunTime, RegenTime, PotTime, HealTime, AttackTime, StruckTime, TorchTime, DuraTime, DecreaseLoyaltyTime, IncreaseLoyaltyTime, ChatTime, ShoutTime, SpellTime, VampTime, SearchTime, FishingTime, LogTime, FishingFoundTime, CreatureTimeLeftTicker, StackingTime, ItemExpireTime, RestedTime, MovementTime;

        public byte ChatTick;

        public bool HasElemental;
        public int ElementsLevel;

        public bool Stacking;

        public bool SendIntelligentCreatureUpdates = false;
        public IntelligentCreatureType SummonedCreatureType = IntelligentCreatureType.None;
        public bool CreatureSummoned;

        public LevelEffects LevelEffects = LevelEffects.None;

        private int _stepCounter, _runCounter, _fishCounter, _restedCounter;

        public NPCScript DefaultNPC
        {
            get
            {
                return Envir.DefaultNPC;
            }
        }

        public uint NPCObjectID;
        public int NPCScriptID;
        public NPCPage NPCPage;
        public Dictionary<NPCSegment, bool> NPCSuccess = new Dictionary<NPCSegment, bool>();
        public bool NPCDelayed;
        public List<string> NPCSpeech = new List<string>();
        public Dictionary<string, object> NPCData = new Dictionary<string, object>();

        public bool UserMatch;
        public string MatchName;
        public ItemType MatchType;
        public MarketPanelType MarketPanelType;
        public short MinShapes, MaxShapes;

        public int PageSent;
        public List<AuctionInfo> Search = new List<AuctionInfo>();
        public List<ItemSets> ItemSets = new List<ItemSets>();
        public List<EquipmentSlot> MirSet = new List<EquipmentSlot>();

        public bool FatalSword, Slaying, TwinDrakeBlade, FlamingSword, MPEater, Hemorrhage, CounterAttack, WhirlWind, IceSword;
        public int MPEaterCount, HemorrhageAttackCount;
        public long FlamingSwordTime, CounterAttackTime, WhirlWindTime, IceSwordTime;
        public bool ActiveBlizzard, ActiveReincarnation, ActiveSwiftFeet, ReincarnationReady;
        public PlayerObject ReincarnationTarget, ReincarnationHost;
        public long ReincarnationExpireTime;

        public float HpDrain = 0;

        public bool UnlockCurse = false;
        public bool FastRun = false;
        public bool CanGainExp = true;

        public bool CanCreateGuild = false;
        public GuildObject MyGuild = null;
        public GuildRank MyGuildRank = null;
        public GuildObject PendingGuildInvite = null;
        public bool GuildNoticeChanged = true; //set to false first time client requests notice list, set to true each time someone in guild edits notice
        public bool GuildMembersChanged = true;//same as above but for members
        public bool GuildCanRequestItems = true;
        public bool RequestedGuildBuffInfo = false;
        public override bool Blocking
        {
            get
            {
                return !Dead && !Observer;
            }
        }
        public bool AllowGroup
        {
            get { return Info.AllowGroup; }
            set { Info.AllowGroup = value; }
        }

        public bool AllowTrade
        {
            get { return Info.AllowTrade; }
            set { Info.AllowTrade = value; }
        }

        public SpecialItemMode SpecialMode;

        public PlayerObject MarriageProposal;
        public PlayerObject DivorceProposal;
        public PlayerObject MentorRequest;

        public PlayerObject GroupInvitation;
        public PlayerObject TradeInvitation;

        public PlayerObject TradePartner = null;
        public bool TradeLocked = false;
        public uint TradeGoldAmount = 0;

        public PlayerObject ItemRentalPartner = null;
        public UserItem ItemRentalDepositedItem = null;
        public uint ItemRentalFeeAmount = 0;
        public uint ItemRentalPeriodLength = 0;
        public bool ItemRentalFeeLocked = false;
        public bool ItemRentalItemLocked = false;

        private long LastRankUpdate = Envir.Time;

        public List<QuestProgressInfo> CurrentQuests
        {
            get { return Info.CurrentQuests; }
        }

        public List<int> CompletedQuests
        {
            get { return Info.CompletedQuests; }
        }

        public PlayerObject(CharacterInfo info, MirConnection connection)
        {
            if (info.Player != null)
                throw new InvalidOperationException("Player.Info not Null.");

            info.Player = this;
            info.Mount = new MountInfo(this);

            Connection = connection;
            Info = info;
            Account = Connection.Account;

            Stats = new Stats();

            Report = new Reporting(this);

            if (Account.AdminAccount)
            {
                IsGM = true;
                MessageQueue.Enqueue(string.Format("{0} is now a GM", Name));
            }

            if (Level == 0) NewCharacter();

            if (Info.GuildIndex != -1)
            {
                MyGuild = Envir.GetGuild(Info.GuildIndex);
            }

            RefreshStats();

            if (HP == 0)
            {
                SetHP(Stats[Stat.HP]);
                SetMP(Stats[Stat.MP]);

                CurrentLocation = BindLocation;
                CurrentMapIndex = BindMapIndex;

                if (Info.PKPoints >= 200)
                {
                    Map temp = Envir.GetMapByNameAndInstance(Settings.PKTownMapName, 1);
                    Point tempLocation = new Point(Settings.PKTownPositionX, Settings.PKTownPositionY);

                    if (temp != null && temp.ValidPoint(tempLocation))
                    {
                        CurrentMapIndex = temp.Info.Index;
                        CurrentLocation = tempLocation;
                    }
                }
            }

            Info.LastLoginDate = Envir.Now;
        }

        public void StopGame(byte reason)
        {
            if (Node == null) return;

            for (int i = 0; i < Pets.Count; i++)
            {
                MonsterObject pet = Pets[i];

                if (pet.Info.AI == 64)//IntelligentCreature
                {
                    //dont save Creatures they will miss alot of AI-Info when they get spawned on login
                    UnSummonIntelligentCreature(((IntelligentCreatureObject)pet).PetType, false);
                    continue;
                }

                if (pet.Info.Name == Settings.SkeletonName0 || 
                    pet.Info.Name == Settings.SkeletonName1 || 
                    pet.Info.Name == Settings.SkeletonName2 || 
                    pet.Info.Name == Settings.SkeletonName3 ||
                    pet.Info.Name == Settings.ShinsuName0 ||
                    pet.Info.Name == Settings.ShinsuName2 ||
                    pet.Info.Name == Settings.ShinsuName4 ||
                    pet.Info.Name == Settings.ShinsuName6 ||
                    pet.Info.Name == Settings.AngelName)
                {
                    pet.Die();
                    continue;
                }

                pet.Master = null;

                if (!pet.Dead)
                {
                    Info.Pets.Add(new PetInfo(pet)
                    {
                        TameTime = pet.TameTime - Envir.Time
                    });

                    Envir.MonsterCount--;
                    pet.CurrentMap.MonsterCount--;

                    pet.CurrentMap.RemoveObject(pet);
                    pet.Despawn();
                }
            }

            Pets.Clear();
            
            for (int i = 0; i < Info.Magics.Count; i++)
            {
                if (Envir.Time < (Info.Magics[i].CastTime + Info.Magics[i].GetDelay()))
                    Info.Magics[i].CastTime -= Envir.Time;
                else
                    Info.Magics[i].CastTime = int.MinValue;
            }

            if (MyGuild != null) MyGuild.PlayerLogged(this, false);
            Envir.Players.Remove(this);
            CurrentMap.RemoveObject(this);
            Despawn();

            if (GroupMembers != null)
            {
                GroupMembers.Remove(this);
                RemoveGroupBuff();

                if (GroupMembers.Count > 1)
                {
                    Packet p = new S.DeleteMember { Name = Name };

                    for (int i = 0; i < GroupMembers.Count; i++)
                        GroupMembers[i].Enqueue(p);
                }
                else
                {
                    GroupMembers[0].Enqueue(new S.DeleteGroup());
                    GroupMembers[0].GroupMembers = null;
                }
                GroupMembers = null;
            }

            for (int i = 0; i < Buffs.Count; i++)
            {
                Buff buff = Buffs[i];
                if (buff.StackType == BuffStackType.Infinite) continue;
                if (buff.Properties.HasFlag(BuffProperty.RemoveOnExit)) continue;

                buff.Caster = null;
                if (!buff.Paused) buff.ExpireTime -= Envir.Time;

                Info.Buffs.Add(buff);
            }

            Buffs.Clear();

            for (int i = 0; i < PoisonList.Count; i++)
            {
                Poison poison = PoisonList[i];
                poison.Owner = null;
                poison.TickTime -= Envir.Time;

                Info.Poisons.Add(poison);
            }

            PoisonList.Clear();

            TradeCancel();
            CancelItemRental();
            RefineCancel();
            LogoutRelationship();
            LogoutMentor();

            string logReason = LogOutReason(reason);

            MessageQueue.Enqueue(logReason);

            Fishing = false;

            Info.LastIP = Connection.IPAddress;
            Info.LastLogoutDate = Envir.Now;

            Report.Disconnected(logReason);

            CleanUp();
        }

        private string LogOutReason(byte reason)
        {
            switch (reason)
            {
                //0-10 are 'senddisconnect to client'
                case 0:
                    return string.Format("{0} Has logged out. Reason: Server closed", Name);
                case 1:
                    return string.Format("{0} Has logged out. Reason: Double login", Name);
                case 2:
                    return string.Format("{0} Has logged out. Reason: Chat message too long", Name);
                case 3:
                    return string.Format("{0} Has logged out. Reason: Server crashed", Name);
                case 4:
                    return string.Format("{0} Has logged out. Reason: Kicked by admin", Name);
                case 5:
                    return string.Format("{0} Has logged out. Reason: Maximum connections reached", Name);
                case 10:
                    return string.Format("{0} Has logged out. Reason: Wrong client version", Name);
                case 20:
                    return string.Format("{0} Has logged out. Reason: User gone missing / disconnected", Name);
                case 21:
                    return string.Format("{0} Has logged out. Reason: Connection timed out", Name);
                case 22:
                    return string.Format("{0} Has logged out. Reason: User closed game", Name);
                case 23:
                    return string.Format("{0} Has logged out. Reason: User returned to select char", Name);
                default:
                    return string.Format("{0} Has logged out. Reason: Unknown", Name);
            }
        }

        private void NewCharacter()
        {
            if (Envir.StartPoints.Count == 0) return;

            SetBind();

            Level = 1;
            Reborn = 0;
            InstanceStage = 0;
            ChallengeStage = 0;
            Hair = (byte)Envir.Random.Next(0, 9);


            for (int i = 0; i < Envir.StartItems.Count; i++)
            {
                ItemInfo info = Envir.StartItems[i];
                if (!CorrectStartItem(info)) continue;

                AddItem(Envir.CreateFreshItem(info));
            }

        }

        public long GetDelayTime(long original)
        {
            if (CurrentPoison.HasFlag(PoisonType.Slow))
            {
                return original * 2;
            }
            return original;
        }

        public override void Process()
        {
            if (Connection == null || Node == null || Info == null) return;

            if (GroupInvitation != null && GroupInvitation.Node == null)
                GroupInvitation = null;

            if (CellTime + 700 < Envir.Time) _stepCounter = 0;

            if (Sneaking) CheckSneakRadius();

            if (FlamingSword && Envir.Time >= FlamingSwordTime)
            {
                FlamingSword = false;
                Enqueue(new S.SpellToggle { Spell = Spell.FlamingSword, CanUse = false });
            }
            if (IceSword && Envir.Time >= IceSwordTime)
            {
                IceSword = false;
                Enqueue(new S.SpellToggle { Spell = Spell.IceSword, CanUse = false });
            }
            if (WhirlWind && Envir.Time >= WhirlWindTime)
            {
                WhirlWind = false;
                Enqueue(new S.SpellToggle { Spell = Spell.WhirlWind, CanUse = false });
            }

            if (CounterAttack && Envir.Time >= CounterAttackTime)
            {
                CounterAttack = false;
            }

            if (ReincarnationReady && Envir.Time >= ReincarnationExpireTime)
            {
                ReincarnationReady = false;
                ActiveReincarnation = false;
                ReincarnationTarget = null;
                ReceiveChat("Reincarnation failed.", ChatType.System);
            }
            if ((ReincarnationReady || ActiveReincarnation) && (ReincarnationTarget == null || !ReincarnationTarget.Dead))
            {
                ReincarnationReady = false;
                ActiveReincarnation = false;
                ReincarnationTarget = null;
            }

            if (Envir.Time > RunTime && _runCounter > 0)
            {
                RunTime = Envir.Time + 1500;
                _runCounter--;
            }

            if (Settings.RestedPeriod > 0 && Envir.Time > RestedTime)
            {
                _restedCounter = InSafeZone ? _restedCounter + 1 : _restedCounter;

                if (_restedCounter > 0)
                {
                    int count = _restedCounter / (Settings.RestedPeriod * 60);

                    GiveRestedBonus(count);
                }

                RestedTime = Envir.Time + Settings.Second;
            }

            if (Stacking && Envir.Time > StackingTime)
            {
                Stacking = false;

                for (int i = 0; i < 8; i++)
                {
                    if (Pushed(this, (MirDirection)i, 1) == 1) break;
                }
            }

            if (NewMail)
            {
                ReceiveChat(GameLanguage.NewMail, ChatType.System);

                GetMail();
            }

            if (Account.HasExpandedStorage && Envir.Now > Account.ExpandedStorageExpiryDate)
            {
                Account.HasExpandedStorage = false;
                ReceiveChat("Expanded storage has expired.", ChatType.System);
                Enqueue(new S.ResizeStorage { Size = Account.Storage.Length, HasExpandedStorage = Account.HasExpandedStorage, ExpiryTime = Account.ExpandedStorageExpiryDate });
            }

            if (Mount.HasMount && Envir.Time > IncreaseLoyaltyTime)
            {
                IncreaseLoyaltyTime = Envir.Time + (LoyaltyDelay * 60);
                IncreaseMountLoyalty(1);
            }

            if (Fishing && Envir.Time > FishingTime)
            {
                _fishCounter++;
                UpdateFish();
            }

            if (Envir.Time > ItemExpireTime)
            {
                ItemExpireTime = Envir.Time + ItemExpireDelay;

                ProcessItems();
            }

            for (int i = Pets.Count() - 1; i >= 0; i--)
            {
                MonsterObject pet = Pets[i];
                if (pet.Dead) Pets.Remove(pet);
            }
            /*
            for (int i = CurrentQuests.Count - 1; i >= 0; i--)
            {
                if (CurrentQuests[i].Info.autoComplete && CurrentQuests[i].HandIn)
                {
                    FinishQuest(CurrentQuests[i].Info.Index, -1, true);
                    continue;
                }
            }
            */
            ProcessBuffs();
            ProcessInfiniteBuffs();
            ProcessRegen();
            ProcessPoison();

            RefreshCreaturesTimeLeft();

            UserItem item;
            if (Envir.Time > TorchTime)
            {
                TorchTime = Envir.Time + 10000;
                item = Info.Equipment[(int)EquipmentSlot.Torch];
                if (item != null)
                {
                    DamageItem(item, 5);

                    if (item.CurrentDura == 0)
                    {
                        Info.Equipment[(int)EquipmentSlot.Torch] = null;
                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                        RefreshStats();
                    }
                }
            }

            if (Envir.Time > DuraTime)
            {
                DuraTime = Envir.Time + DuraDelay;

                for (int i = 0; i < Info.Equipment.Length; i++)
                {
                    item = Info.Equipment[i];
                    if (item == null || !item.DuraChanged) continue; // || item.Info.Type == ItemType.Mount
                    item.DuraChanged = false;
                    Enqueue(new S.DuraChanged { UniqueID = item.UniqueID, CurrentDura = item.CurrentDura });
                }
            }

            base.Process();

            RefreshNameColour();
        }

        public override void SetOperateTime()
        {
            OperateTime = Envir.Time;
        }

        private void ProcessBuffs()
        {
            bool refresh = false;

            for (int i = Buffs.Count - 1; i >= 0; i--)
            {
                Buff buff = Buffs[i];

                switch (buff.Type)
                {
                    case BuffType.Concentration:
                        if (buff.Get<bool>("Interrupted") && buff.Get<long>("InterruptTime") <= Envir.Time)
                        {
                            buff.Set("Interrupted", false);
                            buff.Set("InterruptTime", (long)0);
                            UpdateConcentration(true, false);
                        }
                        break;
                }
             
                if ((Envir.Time <= buff.ExpireTime || buff.StackType == BuffStackType.Infinite || buff.Paused) && !buff.FlagForRemoval) continue;

                Buffs.RemoveAt(i);
                Enqueue(new S.RemoveBuff { Type = buff.Type, ObjectID = ObjectID });

                if (buff.Info.Visible)
                {
                    Broadcast(new S.RemoveBuff { Type = buff.Type, ObjectID = ObjectID });
                }

                switch (buff.Type)
                {
                    case BuffType.Hiding:
                    case BuffType.MoonLight:
                    case BuffType.DarkBody:
                        if (!HasAnyBuffs(buff.Type, BuffType.ClearRing, BuffType.Hiding, BuffType.MoonLight, BuffType.DarkBody))
                        {
                            Hidden = false;
                        }
                        if (buff.Type == BuffType.MoonLight || buff.Type == BuffType.DarkBody)
                        {
                            if (!HasAnyBuffs(buff.Type, BuffType.MoonLight, BuffType.DarkBody))
                            {
                                Sneaking = false;
                            }
                            break;
                        }
                        break;
                    case BuffType.Concentration:
                        UpdateConcentration(false, false);
                        break;
                    case BuffType.SwiftFeet:
                        ActiveSwiftFeet = false;
                        break;
                    case BuffType.MagicShield:
                        CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.MagicShieldDown }, CurrentLocation);
                        break;
                    case BuffType.ElementalBarrier:
                        CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.ElementalBarrierDown }, CurrentLocation);
                        break;
                }

                refresh = true;
            }

            if (refresh) RefreshStats();
        }
        private void ProcessInfiniteBuffs()
        {
            bool skill = false, clearRing = false;

            for (int i = Buffs.Count - 1; i >= 0; i--)
            {
                Buff buff = Buffs[i];

                if (buff.StackType != BuffStackType.Infinite) continue;

                bool removeBuff = false;

                switch (buff.Type)
                {
                    case BuffType.ClearRing:
                        clearRing = true;
                        if (!SpecialMode.HasFlag(SpecialItemMode.ClearRing)) removeBuff = true;
                        break;
                    case BuffType.Skill:
                        skill = true;
                        if (!SpecialMode.HasFlag(SpecialItemMode.Skill)) removeBuff = true;
                        break;
                }

                if (removeBuff)
                {
                    Buffs.RemoveAt(i);
                    Enqueue(new S.RemoveBuff { Type = buff.Type, ObjectID = ObjectID });

                    switch (buff.Type)
                    {
                        case BuffType.ClearRing:
                            if (!HasAnyBuffs(buff.Type, BuffType.Hiding, BuffType.MoonLight, BuffType.DarkBody))
                            {
                                Hidden = false;
                            }
                            break;
                    }
                }
            }

            if (SpecialMode.HasFlag(SpecialItemMode.ClearRing) && !clearRing)
            {
                AddBuff(BuffType.ClearRing, this, 0, new Stats());
            }
            if (SpecialMode.HasFlag(SpecialItemMode.Skill) && !skill)
            {
                AddBuff(BuffType.Skill, this, 0, new Stats { [Stat.SkillGainMultiplier] = 3 }, false);
            }
        }
        private void ProcessRegen()
        {
            if (Dead) return;

            int healthRegen = 0, manaRegen = 0;

            if (CanRegen)
            {
                RegenTime = Envir.Time + Settings.ItemsRegenDelay;

                if (HP < Stats[Stat.HP])
                {
                    healthRegen += 0;
                    healthRegen += (int)(healthRegen + (double)Stats[Stat.HealthRecovery]);
                }

                if (MP < Stats[Stat.MP])
                {
                    manaRegen += 0;
                    manaRegen += (int)(manaRegen + (double)Stats[Stat.SpellRecovery]);
                }
            }

            if (CanStandRegen)
            {
                RegenStandTime = Envir.Time + Settings.RegenStandDelay;


                if (HP < Stats[Stat.HP])
                {
                    healthRegen += (int)(Stats[Stat.HP] * 0.03F) + 1;
                    healthRegen += (int)(healthRegen * ((double)Stats[Stat.HealthRecovery] / Settings.HealthRegenWeight));
                }

                if (MP < Stats[Stat.MP])
                {
                    manaRegen += (int)(Stats[Stat.MP] * 0.03F) + 1;
                    manaRegen += (int)(manaRegen * ((double)Stats[Stat.SpellRecovery] / Settings.ManaRegenWeight));
                }
            }

            if (Envir.Time > PotTime)
            {
                //PotTime = Envir.Time + Math.Max(50,Math.Min(PotDelay, 600 - (Level * 10)));
                //PotTime = Envir.Time + PotDelay;
                //int PerTickRegen = 5 + (Level / 10);

                PotTime = Envir.Time + Settings.PotRegenDelay;
                int PerTickRegen = Settings.PerTickRegen + (Level / 5);  //u can test it now

                if (PotHealthAmount > PerTickRegen)
                {
                    healthRegen += PerTickRegen;
                    PotHealthAmount -= (ushort)PerTickRegen;
                }
                else
                {
                    healthRegen += PotHealthAmount;
                    PotHealthAmount = 0;
                }

                if (PotManaAmount > PerTickRegen)
                {
                    manaRegen += PerTickRegen;
                    PotManaAmount -= (ushort)PerTickRegen;
                }
                else
                {
                    manaRegen += PotManaAmount;
                    PotManaAmount = 0;
                }
            }

            if (Envir.Time > HealTime)
            {
                HealTime = Envir.Time + HealDelay;

                int incHeal = (Level / 10) + (HealAmount / 10);
                if (HealAmount > (5 + incHeal))
                {
                    healthRegen += (5 + incHeal);
                    HealAmount -= (ushort)Math.Min(HealAmount, 5 + incHeal);
                }
                else
                {
                    healthRegen += HealAmount;
                    HealAmount = 0;
                }
            }

            if (Envir.Time > VampTime)
            {
                VampTime = Envir.Time + VampDelay;

                if (VampAmount > 10)
                {
                    healthRegen += 10;
                    VampAmount -= 10;
                }
                else
                {
                    healthRegen += VampAmount;
                    VampAmount = 0;
                }
            }

            if (Envir.Time > YYBTime)
            {
                YYBTime = Envir.Time + YYBDelay;

                int YYBHeal = (Level / 5) + (YYBAmount / 5);
                if (HealAmount > (10 + YYBHeal))
                {
                    healthRegen += (10 + YYBHeal);
                    YYBAmount -= (ushort)Math.Min(YYBAmount, 10 + YYBHeal);
                }
                else
                {
                    healthRegen += YYBAmount;
                    YYBAmount = 0;
                }
            }

            if (healthRegen > 0)
            {
                ChangeHP(healthRegen);
                BroadcastDamageIndicator(DamageType.Hit, healthRegen);
            }

            if (HP == Stats[Stat.HP])
            {
                PotHealthAmount = 0;
                HealAmount = 0;
            }

            if (manaRegen > 0) ChangeMP(manaRegen);
            if (MP == Stats[Stat.MP]) PotManaAmount = 0;
        }
        private void ProcessPoison()
        {
            PoisonType type = PoisonType.None;
            ArmourRate = 1F;
            DamageRate = 1F;

            for (int i = PoisonList.Count - 1; i >= 0; i--)
            {
                if (Dead) return;

                Poison poison = PoisonList[i];

                if (poison.Owner != null && poison.Owner.Node == null)
                {
                    PoisonList.RemoveAt(i);
                    continue;
                }

                if (Envir.Time > poison.TickTime)
                {
                    poison.Time++;
                    poison.TickTime = Envir.Time + poison.TickSpeed;

                    if (poison.Time >= poison.Duration)
                    {
                        PoisonList.RemoveAt(i);
                    }

                    if (poison.PType == PoisonType.Green || poison.PType == PoisonType.Bleeding)
                    {
                        LastHitter = poison.Owner;
                        LastHitTime = Envir.Time + 10000;

                        if (poison.PType == PoisonType.Bleeding)
                        {
                            Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.Bleeding, EffectType = 0 });
                        }

                        PoisonDamage(-poison.Value, poison.Owner);
                        BroadcastDamageIndicator(DamageType.Hit, -poison.Value);
                        
                        if (Dead) break;
                        RegenTime = Envir.Time + RegenDelay;
                        RegenStandTime = Envir.Time + Settings.RegenStandDelay;
                    }

                    if (poison.PType == PoisonType.DelayedExplosion)
                    {
                        if (Envir.Time > ExplosionInflictedTime) ExplosionInflictedStage++;

                        if (!ProcessDelayedExplosion(poison))
                        {
                            if (Dead) break;

                            ExplosionInflictedStage = 0;
                            ExplosionInflictedTime = 0;

                            PoisonList.RemoveAt(i);
                            continue;
                        }
                    }
                }

                switch (poison.PType)
                {
                    case PoisonType.Red:
                        ArmourRate -= 0.10F;
                        break;
                    case PoisonType.Stun:
                        DamageRate += 0.20F;
                        break;
                    case PoisonType.Blindness:
                        break;
                }

                type |= poison.PType;
                /*
                if ((int)type < (int)poison.PType)
                    type = poison.PType;
                */
            }

            if (type == CurrentPoison) return;

            Enqueue(new S.Poisoned { Poison = type });
            Broadcast(new S.ObjectPoisoned { ObjectID = ObjectID, Poison = type });

            CurrentPoison = type;
        }
        private bool ProcessDelayedExplosion(Poison poison)
        {
            if (Dead) return false;

            if (ExplosionInflictedStage == 0)
            {
                Enqueue(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion, EffectType = 0 });
                Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion, EffectType = 0 });
                return true;
            }
            if (ExplosionInflictedStage == 1)
            {
                if (Envir.Time > ExplosionInflictedTime)
                    ExplosionInflictedTime = poison.TickTime + 3000;
                Enqueue(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion, EffectType = 1 });
                Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion, EffectType = 1 });
                return true;
            }
            if (ExplosionInflictedStage == 2)
            {
                Enqueue(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion, EffectType = 2 });
                Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion, EffectType = 2 });
                if (poison.Owner != null)
                {
                    switch (poison.Owner.Race)
                    { 
                        case ObjectType.Player:
                            PlayerObject caster = (PlayerObject)poison.Owner;
                            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time, poison.Owner, caster.GetMagic(Spell.DelayedExplosion), poison.Value, this.CurrentLocation);
                            CurrentMap.ActionList.Add(action);
                            break;
                        case ObjectType.Monster://this is in place so it could be used by mobs if one day someone chooses to
                            Attacked((MonsterObject)poison.Owner, poison.Value, DefenceType.MAC);
                            break;
                    }
                    
                    LastHitter = poison.Owner;
                }
                return false;
            }
            return false;
        }

        private void ProcessItems()
        {
            for (var i = 0; i < Info.Inventory.Length; i++)
            {
                var item = Info.Inventory[i];

                if (item?.ExpireInfo?.ExpiryDate <= Envir.Now)
                {
                    ReceiveChat($"{item.Info.FriendlyName} has just expired from your inventory.", ChatType.Hint);
                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                    Info.Inventory[i] = null;

                    continue;
                }

                if (item?.RentalInformation?.RentalLocked != true ||
                    !(item?.RentalInformation?.ExpiryDate <= Envir.Now))
                    continue;

                ReceiveChat($"The rental lock has been removed from {item.Info.FriendlyName}.", ChatType.Hint);
                item.RentalInformation = null;
            }

            for (var i = 0; i < Info.Equipment.Length; i++)
            {
                var item = Info.Equipment[i];

                if (item?.ExpireInfo?.ExpiryDate <= Envir.Now)
                {
                    ReceiveChat($"{item.Info.FriendlyName} has just expired from your equipment.", ChatType.Hint);
                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                    Info.Equipment[i] = null;

                    continue;
                }

                if (item?.RentalInformation?.RentalLocked != true ||
                    !(item?.RentalInformation?.ExpiryDate <= Envir.Now))
                    continue;

                ReceiveChat($"The rental lock has been removed from {item.Info.FriendlyName}.", ChatType.Hint);
                item.RentalInformation = null;
            }

            for (int i = 0; i < Info.AccountInfo.Storage.Length; i++)
            {
                var item = Info.AccountInfo.Storage[i];
                if (item?.ExpireInfo?.ExpiryDate <= Envir.Now)
                {
                    ReceiveChat($"{item.Info.FriendlyName} has just expired from your storage.", ChatType.Hint);
                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                    Info.AccountInfo.Storage[i] = null;

                    continue;
                }
            }
        }

        public override void Process(DelayedAction action)
        {
            if (action.FlaggedToRemove)
                return;

            switch (action.Type)
            {
                case DelayedType.Magic:
                    CompleteMagic(action.Params);
                    break;
                case DelayedType.Damage:
                    CompleteAttack(action.Params);
                    break;
                case DelayedType.MapMovement:
                    CompleteMapMovement(action.Params);
                    break;
                case DelayedType.Mine:
                    CompleteMine(action.Params);
                    break;
                case DelayedType.NPC:
                    CompleteNPC(action.Params);
                    break;
                case DelayedType.Poison:
                    CompletePoison(action.Params);
                    break;
                case DelayedType.DamageIndicator:
                    CompleteDamageIndicator(action.Params);
                    break;
                case DelayedType.Quest:
                    CompleteQuest(action.Params);
                    break;
            }
        }

        private void SetHP(int amount)
        {
            if (HP == amount) return;

            HP = amount <= Stats[Stat.HP] ? amount : Stats[Stat.HP];
            HP = GMNeverDie ? Stats[Stat.HP] : HP;

            if (!Dead && HP == 0) Die();

            //HealthChanged = true;
            Enqueue(new S.HealthChanged { HP = HP, MP = MP });
            BroadcastHealthChange();
        }
        private void SetMP(int amount)
        {
            if (MP == amount) return;
            //was info.MP
            MP = amount <= Stats[Stat.MP] ? amount : Stats[Stat.MP];
            MP = GMNeverDie ? Stats[Stat.MP] : MP;

            // HealthChanged = true;
            Enqueue(new S.HealthChanged { HP = HP, MP = MP });
            BroadcastHealthChange();
        }

        public void ChangeHP(int amount)
        {
            if (SpecialMode.HasFlag(SpecialItemMode.Protection) && MP > 0 && amount < 0)
            {
                ChangeMP(amount);
                return;
            }

            if (HP + amount > Stats[Stat.HP])
                amount = Stats[Stat.HP] - HP;

            if (amount == 0) return;

            HP += amount;
            HP = GMNeverDie ? Stats[Stat.HP] : HP;

            if (HP < 0) HP = 0;

            if (!Dead && HP == 0) Die();

            // HealthChanged = true;
            Enqueue(new S.HealthChanged { HP = HP, MP = MP });
            BroadcastHealthChange();
        }
        //use this so you can have mobs take no/reduced poison damage
        public void PoisonDamage(int amount, MapObject Attacker)
        {
            ChangeHP(amount);
        }
        public void ChangeMP(int amount)
        {
            if (MP + amount > Stats[Stat.MP])
                amount = Stats[Stat.MP] - MP;

            if (amount == 0) return;

            MP += amount;
            MP = GMNeverDie ? Stats[Stat.MP] : MP;

            if (MP < 0) MP = 0;

            // HealthChanged = true;
            Enqueue(new S.HealthChanged { HP = HP, MP = MP });
            BroadcastHealthChange();
        }
        public override void Die()
        {
            if (SpecialMode.HasFlag(SpecialItemMode.Revival) && Envir.Time > LastRevivalTime)
            {
                LastRevivalTime = Envir.Time + 300000;

                for (var i = (int)EquipmentSlot.RingL; i <= (int)EquipmentSlot.RingR; i++)
                {
                    var item = Info.Equipment[i];

                    if (item == null) continue;
                    if (!(item.Info.Unique.HasFlag(SpecialItemMode.Revival)) || item.CurrentDura < 1000) continue;
                    SetHP(Stats[Stat.HP]);
                    item.CurrentDura = (ushort)(item.CurrentDura - 1000);
                    Enqueue(new S.DuraChanged { UniqueID = item.UniqueID, CurrentDura = item.CurrentDura });
                    RefreshStats();
                    ReceiveChat("You have been given a second chance at life", ChatType.System);
                    return;
                }
            }

            if (LastHitter != null && LastHitter.Race == ObjectType.Player)
            {
                PlayerObject hitter = (PlayerObject)LastHitter;

                if (AtWar(hitter) || WarZone)
                {
                    hitter.ReceiveChat(string.Format("You've been protected by the law"), ChatType.System);
                }
                else if (Envir.Time > BrownTime && PKPoints < 200)
                {
                    UserItem weapon = hitter.Info.Equipment[(byte)EquipmentSlot.Weapon];

                    hitter.PKPoints = Math.Min(int.MaxValue, LastHitter.PKPoints + 100);
                    hitter.ReceiveChat(string.Format("You have murdered {0}", Name), ChatType.System);
                    ReceiveChat(string.Format("You have been murdered by {0}", LastHitter.Name), ChatType.System);

                    if (MyGuild != null && hitter.MyGuild != null && !MyGuild.WarringGuilds.Contains(hitter.MyGuild) && MyGuild.PendingGuild == null)
                    {
                        MyGuild.VoteExpire = DateTime.Now.AddMinutes(3);
                        MyGuild.PendingGuild = hitter.MyGuild;

                        MyGuild.SendMessage($"{Name} has been murdered by {hitter.Name} from {hitter.MyGuild.Name}");
                        MyGuild.SendMessage($"War against {hitter.MyGuild.Name} has been submited to vote,  Vote expire after 3 minutes");
                        MyGuild.SendMessage($"Vote by typing: /yes or /no, Minimum votes required : 5");
                    }

                    if (weapon != null && weapon.AddedStats[Stat.Luck] > (Settings.MaxLuck * -1) && Envir.Random.Next(4) == 0)
                    {
                        weapon.AddedStats[Stat.Luck]--;
                        hitter.ReceiveChat("Your weapon has been cursed.", ChatType.System);
                        hitter.Enqueue(new S.RefreshItem { Item = weapon });
                    }
                }
            }

            UnSummonIntelligentCreature(SummonedCreatureType);

            for (int i = Pets.Count - 1; i >= 0; i--)
            {
                if (Pets[i].Dead) continue;
                Pets[i].Die();
            }

            RemoveBuff(BuffType.MagicShield);
            RemoveBuff(BuffType.ElementalBarrier);

            if (PKPoints > 200)
                RedDeathDrop(LastHitter);
            else if (!InSafeZone)
                DeathDrop(LastHitter);

            HP = 0;
            Dead = true;

            LogTime = Envir.Time;
            BrownTime = Envir.Time;

            Enqueue(new S.Death { Direction = Direction, Location = CurrentLocation });
            Broadcast(new S.ObjectDied { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });

            for (int i = 0; i < Buffs.Count; i++)
            {
                Buff buff = Buffs[i];

                if (!buff.Properties.HasFlag(BuffProperty.RemoveOnDeath)) continue;

                RemoveBuff(buff.Type);
            }

            PoisonList.Clear();
            InTrapRock = false;

            CallDefaultNPC(DefaultNPCType.Die);

            Report.Died(CurrentMap.Info.FileName);
            ExpireTimer("RecallTimer");
        }

        private void DeathDrop(MapObject killer)
        {
            var pkbodydrop = true;
            int currentDropLimit = 0;

            if (CurrentMap.Info.NoDropPlayer && Race == ObjectType.Player)
                return;

            if ((killer == null) || ((pkbodydrop) || (killer.Race != ObjectType.Player)))
            {
                for (var i = 0; i < Info.Equipment.Length; i++)
                {
                    var item = Info.Equipment[i];

                    if (item == null)
                        continue;

                    if (item.Info.Bind.HasFlag(BindMode.DontDeathdrop))
                        continue;

                    // TODO: Check this.
                    if (item.WeddingRing != -1 && Info.Equipment[(int)EquipmentSlot.RingL].UniqueID == item.UniqueID)
                        continue;

                    if (((killer == null) || ((killer != null) && (killer.Race != ObjectType.Player))))
                    {
                        if (item.Info.Bind.HasFlag(BindMode.BreakOnDeath))
                        {
                            Info.Equipment[i] = null;
                            Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                            ReceiveChat($"Your {item.FriendlyName} shattered upon death.", ChatType.System2);
                            Report.ItemChanged(item, item.Count, 1);
                        }
                    }
                    if (ItemSets.Any(set => set.Set == ItemSet.Spirit && !set.SetComplete))
                    {
                        if (item.Info.Set == ItemSet.Spirit)
                        {
                            Info.Equipment[i] = null;
                            Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                            Report.ItemChanged(item, item.Count, 1);
                        }
                    }

                    if (currentDropLimit == Settings.NonRedEquipDropLimit) continue;
                    if (item.Count > 1)
                    {
                        var percent = Envir.RandomomRange(10, 8);
                        var count = (ushort)Math.Ceiling(item.Count / 10F * percent);

                        if (count > item.Count)
                            throw new ArgumentOutOfRangeException();
                        
                        var temp2 = Envir.CreateFreshItem(item.Info);
                        temp2.Count = count;

                        if (!DropItem(temp2, Settings.DropRange, true))
                            continue;
                        currentDropLimit++;

                        if (count == item.Count)
                            Info.Equipment[i] = null;

                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = count });
                        item.Count -= count;

                        Report.ItemChanged( item, count, 1);
                    }
                    else if (Envir.Random.Next(30) == 0)
                    {
                        if (Envir.ReturnRentalItem(item, item.RentalInformation?.OwnerName, Info))
                        {
                            Info.Equipment[i] = null;
                            Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
   
                            ReceiveChat($"You died and {item.Info.FriendlyName} has been returned to it's owner.", ChatType.Hint);
                            Report.ItemMailed(item, 1, 1);

                            continue;
                        }

                        if (!DropItem(item, Settings.DropRange, true))
                            continue;
                        currentDropLimit++;

                        if (item.Info.GlobalDropNotify)
                            foreach (var player in Envir.Players)
                            {
                                player.ReceiveChat($"{Name} has dropped {item.FriendlyName}.", ChatType.System2);
                            }

                        Info.Equipment[i] = null;
                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                        Report.ItemChanged(item, item.Count, 1);
                    }
                }

            }

            currentDropLimit = 0;
            for (var i = 0; i < Info.Inventory.Length; i++)
            {
                var item = Info.Inventory[i];

                if (Settings.NonRedInvDropLimit != -1)
                    if (currentDropLimit >= Settings.NonRedInvDropLimit) continue;

                if (item == null)
                    continue;

                if (item.Info.Bind.HasFlag(BindMode.DontDeathdrop))
                    continue;

                if (item.WeddingRing != -1)
                    continue;

                if (item.Count > 1)
                {
                    var percent = Envir.RandomomRange(10, 8);

                    if (percent == 0)
                        continue;

                    var count = (ushort)Math.Ceiling(item.Count / 10F * percent);

                    if (count > item.Count)
                        throw new ArgumentOutOfRangeException();

                    var temp2 = Envir.CreateFreshItem(item.Info);
                    temp2.Count = count;

                    if (!DropItem(temp2, Settings.DropRange, true))
                        continue;
                    currentDropLimit++;

                    if (count == item.Count)
                        Info.Inventory[i] = null;

                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = count });
                    item.Count -= count;

                    Report.ItemChanged(item, count, 1);
                }
                else if (Envir.Random.Next(10) == 0)
                {
                    if (Envir.ReturnRentalItem(item, item.RentalInformation?.OwnerName, Info))
                    {
                        Info.Inventory[i] = null;
                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                        ReceiveChat($"You died and {item.Info.FriendlyName} has been returned to has been returned to it's owner.", ChatType.Hint);
                        Report.ItemMailed(item, 1, 1);

                        continue;
                    }

                    if (!DropItem(item, Settings.DropRange, true))
                        continue;
                    currentDropLimit++;

                    if (item.Info.GlobalDropNotify)
                        foreach (var player in Envir.Players)
                        {
                            player.ReceiveChat($"{Name} has dropped {item.FriendlyName}.", ChatType.System2);
                        }

                    Info.Inventory[i] = null;
                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                    Report.ItemChanged(item, item.Count, 1);
                }
            }

            RefreshStats();
        }
        private void RedDeathDrop(MapObject killer)
        {
            int currentDroppedEquip = 0;
            if (killer == null || killer.Race != ObjectType.Player)
            {
                for (var i = 0; i < Info.Equipment.Length; i++)
                {
                    var item = Info.Equipment[i];

                    if (item == null)
                        continue;

                    if (item.Info.Bind.HasFlag(BindMode.DontDeathdrop))
                        continue;

                    // TODO: Check this.
                    if ((item.WeddingRing != -1) && (Info.Equipment[(int)EquipmentSlot.RingL].UniqueID == item.UniqueID))
                        continue;

                    if (item.Info.Bind.HasFlag(BindMode.BreakOnDeath))
                    {
                        Info.Equipment[i] = null;
                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                        ReceiveChat($"Your {item.FriendlyName} shattered upon death.", ChatType.System2);
                        Report.ItemChanged(item, item.Count, 1, "RedDeathDrop");
                    }

                    if (currentDroppedEquip == Settings.RedEquipDropLimit) continue;
                    if (item.Count > 1)
                    {
                        var percent = Envir.RandomomRange(10, 4);
                        var count = (ushort)Math.Ceiling(item.Count / 10F * percent);

                        if (count > item.Count)
                            throw new ArgumentOutOfRangeException();

                        var temp2 = Envir.CreateFreshItem(item.Info);
                        temp2.Count = count;

                        if (!DropItem(temp2, Settings.DropRange, true))
                            continue;
                        currentDroppedEquip++;

                        if (count == item.Count)
                            Info.Equipment[i] = null;

                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = count });
                        item.Count -= count;

                        Report.ItemChanged(item, count, 1, "RedDeathDrop");
                    }
                    else if (Envir.Random.Next(10) == 0)
                    {
                        if (Envir.ReturnRentalItem(item, item.RentalInformation?.OwnerName, Info))
                        {
                            Info.Equipment[i] = null;
                            Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                            ReceiveChat($"You died and {item.Info.FriendlyName} has been returned to it's owner.", ChatType.Hint);
                            Report.ItemMailed(item, 1, 1, "Death Dropped Rental Item");

                            continue;
                        }

                        if (!DropItem(item, Settings.DropRange, true))
                            continue;
                        currentDroppedEquip++;

                        if (item.Info.GlobalDropNotify)
                            foreach (var player in Envir.Players)
                            {
                                player.ReceiveChat($"{Name} has dropped {item.FriendlyName}.", ChatType.System2);
                            }

                        Info.Equipment[i] = null;
                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                        Report.ItemChanged(item, item.Count, 1, "RedDeathDrop");
                    }
                }

            }

            currentDroppedEquip = 0;
            for (var i = 0; i < Info.Inventory.Length; i++)
            {
                var item = Info.Inventory[i];

                if (Settings.RedInvDropLimit != -1)
                    if (currentDroppedEquip == Settings.RedInvDropLimit) continue;

                if (item == null)
                    continue;

                if (item.Info.Bind.HasFlag(BindMode.DontDeathdrop))
                    continue;

                if (item.WeddingRing != -1)
                    continue;

                if (Envir.ReturnRentalItem(item, item.RentalInformation?.OwnerName, Info))
                {
                    Info.Inventory[i] = null;
                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                    ReceiveChat($"You died and {item.Info.FriendlyName} has been returned to it's owner.", ChatType.Hint);
                    Report.ItemMailed(item, 1, 1, "Death Dropped Rental Item");

                    continue;
                }

                if (!DropItem(item, Settings.DropRange, true))
                    continue;
                currentDroppedEquip++;

                if (item.Info.GlobalDropNotify)
                    foreach (var player in Envir.Players)
                    {
                        player.ReceiveChat($"{Name} has dropped {item.FriendlyName}.", ChatType.System2);
                    }

                Info.Inventory[i] = null;
                Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                Report.ItemChanged(item, item.Count, 1, "RedDeathDrop");
            }

            RefreshStats();
        }

        public override void WinExp(uint amount, uint targetLevel = 0)
        {
            int expPoint;

            if (Level < targetLevel + 10 || !Settings.ExpMobLevelDifference)
            {
                expPoint = (int)amount;
            }
            else
            {
                expPoint = (int)amount - (int)Math.Round(Math.Max(amount / 15, 1) * ((double)Level - (targetLevel + 10)));
            }

            if (expPoint <= 0) expPoint = 1;

            expPoint = (int)(expPoint * Settings.ExpRate);

            //party
            float[] partyExpRate = { 1.0F, 1.3F, 1.4F, 1.5F, 1.6F, 1.7F, 1.8F, 1.9F, 2F, 2.1F, 2.2F };

            if (GroupMembers != null)
            {
                int sumLevel = 0;
                int nearCount = 0;
                for (int i = 0; i < GroupMembers.Count; i++)
                {
                    PlayerObject player = GroupMembers[i];

                    if (Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        sumLevel += player.Level;
                        nearCount++;
                    }
                }

                if (nearCount > partyExpRate.Length) nearCount = partyExpRate.Length;

                for (int i = 0; i < GroupMembers.Count; i++)
                {
                    PlayerObject player = GroupMembers[i];
                    if (player.CurrentMap == CurrentMap &&
                        Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) && !player.Dead)
                    {
                        player.GainExp((uint)((float)expPoint * partyExpRate[nearCount - 1] * (float)player.Level / (float)sumLevel));
                    }
                }
            }
            else
                GainExp((uint)expPoint);
        }

        public void GainExp(uint amount)
        {
            if (!CanGainExp) return;

            if (amount == 0) return;

            if (Info.Married != 0)
            {
                if (HasBuff(BuffType.RelationshipEXP, out Buff buff))
                {
                    CharacterInfo lover = Envir.GetCharacterInfo(Info.Married);
                    PlayerObject loverPlayer = Envir.GetPlayer(lover.Name);
                    if (loverPlayer != null && loverPlayer.CurrentMap == CurrentMap && Functions.InRange(loverPlayer.CurrentLocation, CurrentLocation, Globals.DataRange) && !loverPlayer.Dead)
                    {
                        amount += (uint)Math.Max(0, (amount * Stats[Stat.LoverExpRatePercent]) / 100);
                    }
                }
            }

            if (Info.Mentor != 0 && !Info.isMentor)
            {
                if (HasBuff(BuffType.Mentee, out _))
                {
                    CharacterInfo mentor = Envir.GetCharacterInfo(Info.Mentor);
                    PlayerObject mentorPlayer = Envir.GetPlayer(mentor.Name);
                    if (mentorPlayer != null && mentorPlayer.CurrentMap == CurrentMap && Functions.InRange(mentorPlayer.CurrentLocation, CurrentLocation, Globals.DataRange) && !mentorPlayer.Dead)
                    {
                        amount += (uint)Math.Max(0, (amount * Stats[Stat.MentorExpRatePercent]) / 100);
                    }
                }
            }

            if (Stats[Stat.ExpRatePercent] > 0)
            {
                amount += (uint)Math.Max(0, (amount * Stats[Stat.ExpRatePercent]) / 100);
                //amount += (uint)(amount * (Stats[Stat.ExpRatePercent] - 1));
            }

            if (Stats[Stat.ExpRate] > 0)
            {
                //amount += (uint)Math.Max(0, (amount * Stats[Stat.ExpRatePercent]) / 100);
                amount += (uint)(amount * (Stats[Stat.ExpRate] - 1));
            }

            if (Info.Mentor != 0 && !Info.isMentor)
            {
                MenteeEXP += (amount * Settings.MenteeExpBank) / 100;
            }

            Experience += amount;

            foreach (var i in Info.Equipment)
            {
                if (i == null) continue;

                var exp = ((int)amount / 10);

                if (exp > 0)
                {
                    if (i.ItemGainExp(exp))
                    {
                        i.ItemLevelUp(Level, Class, Envir.ItemInfoList);
                        ReceiveChat(i.FriendlyName + " has leveled up!", ChatType.System);
                    }

                    Enqueue(new S.RefreshItem { Item = i });
                }
            }

            Enqueue(new S.GainExperience { Amount = amount });


            for (int i = 0; i < Pets.Count; i++)
            {
                MonsterObject monster = Pets[i];
                if (monster.CurrentMap == CurrentMap && Functions.InRange(monster.CurrentLocation, CurrentLocation, Globals.DataRange) && !monster.Dead)
                    monster.PetExp(amount);
            }

            if (MyGuild != null)
                MyGuild.GainExp(amount);

            if (Experience < MaxExperience) return;
            if (Level >= ushort.MaxValue) return;

            //Calculate increased levels
            var experience = Experience;

            while (experience >= MaxExperience)
            {
                Level++;
                experience -= MaxExperience;

                RefreshLevelStats();

                if (Level >= ushort.MaxValue) break;
            }

            Experience = experience;

            LevelUp();
            RebornUp();
            InstanceStageUp();
            ChallengeStageUp();

            if (IsGM) return;
            if ((LastRankUpdate + 3600 * 1000) > Envir.Time)
            {
                LastRankUpdate = Envir.Time;
                if ((Level >= Envir.RankBottomLevel[0]) || (Level >= Envir.RankBottomLevel[(byte)Class + 1]))
                {
                    Envir.CheckRankUpdate(Info);
                }
            }
        }

        public void LevelUp()
        {
            RefreshStats();
            SetHP(Stats[Stat.HP]);
            SetMP(Stats[Stat.MP]);

            CallDefaultNPC(DefaultNPCType.LevelUp);

            Enqueue(new S.LevelChanged { Level = Level, Experience = Experience, MaxExperience = MaxExperience });
            Broadcast(new S.ObjectLeveled { ObjectID = ObjectID });

            if (Info.Mentor != 0 && !Info.isMentor)
            {
                CharacterInfo Mentor = Envir.GetCharacterInfo(Info.Mentor);
                if ((Mentor != null) && ((Info.Level + Settings.MentorLevelGap) > Mentor.Level))
                    MentorBreak();
            }

            for (int i = CurrentMap.NPCs.Count - 1; i >= 0; i--)
            {
                if (Functions.InRange(CurrentMap.NPCs[i].CurrentLocation, CurrentLocation, Globals.DataRange))
                    CurrentMap.NPCs[i].CheckVisible(this);
            }
            Report.Levelled(Level);
            if (IsGM) return;
            if ((Level >= Envir.RankBottomLevel[0]) || (Level >= Envir.RankBottomLevel[(byte)Class + 1]))
            {

                Envir.CheckRankUpdate(Info);
            }
        }
        public void RebornUp()
        {
            RefreshStats();

            CallDefaultNPC(DefaultNPCType.RebornUp);

            Enqueue(new S.RebornChanged { Reborn = Reborn });
            Broadcast(new S.ObjectReborned { ObjectID = ObjectID });
        }
        public void InstanceStageUp()
        {
            RefreshStats();

            CallDefaultNPC(DefaultNPCType.InstanceStageUp);

            Enqueue(new S.InstanceStageChanged { InstanceStage = InstanceStage });
            Broadcast(new S.ObjectInstanceStageed { ObjectID = ObjectID });
        }
        public void ChallengeStageUp()
        {
            RefreshStats();

            CallDefaultNPC(DefaultNPCType.ChallengeStageUp);

            Enqueue(new S.ChallengeStageChanged { ChallengeStage = ChallengeStage });
            Broadcast(new S.ObjectChallengeStageed { ObjectID = ObjectID });
        }

        private static int FreeSpace(IList<UserItem> array)
        {
            int count = 0;

            for (int i = 0; i < array.Count; i++)
                if (array[i] == null) count++;

            return count;
        }

        private void AddQuestItem(UserItem item)
        {
            if (item.Info.StackSize > 1) //Stackable
            {
                for (int i = 0; i < Info.QuestInventory.Length; i++)
                {
                    UserItem temp = Info.QuestInventory[i];
                    if (temp == null || item.Info != temp.Info || temp.Count >= temp.Info.StackSize) continue;

                    if (item.Count + temp.Count <= temp.Info.StackSize)
                    {
                        temp.Count += item.Count;
                        return;
                    }
                    item.Count -= (ushort)(temp.Info.StackSize - temp.Count);
                    temp.Count = temp.Info.StackSize;
                }
            }

            for (int i = 0; i < Info.QuestInventory.Length; i++)
            {
                if (Info.QuestInventory[i] != null) continue;
                Info.QuestInventory[i] = item;

                return;
            }
        }

        private void AddItem(UserItem item)
        {
            if (item.Info.StackSize > 1) //Stackable
            {
                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    UserItem temp = Info.Inventory[i];
                    if (temp == null || item.Info != temp.Info || temp.Count >= temp.Info.StackSize) continue;

                    if (item.Count + temp.Count <= temp.Info.StackSize)
                    {
                        temp.Count += item.Count;
                        return;
                    }
                    item.Count -= (ushort)(temp.Info.StackSize - temp.Count);
                    temp.Count = temp.Info.StackSize;
                }
            }

            if (item.Info.Type == ItemType.Potion || item.Info.Type == ItemType.Scroll || (item.Info.Type == ItemType.Script && item.Info.Effect == 1))
            {
                for (int i = 0; i < 4; i++)
                {
                    if (Info.Inventory[i] != null) continue;
                    Info.Inventory[i] = item;
                    return;
                }
            }
            else if (item.Info.Type == ItemType.Amulet && item.Info.Type == ItemType.TaoPoison)
            {
                for (int i = 4; i < 6; i++)
                {
                    if (Info.Inventory[i] != null) continue;
                    Info.Inventory[i] = item;
                    return;
                }
            }
            else
            {
                for (int i = 6; i < Info.Inventory.Length; i++)
                {
                    if (Info.Inventory[i] != null) continue;
                    Info.Inventory[i] = item;
                    return;
                }
            }

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                if (Info.Inventory[i] != null) continue;
                Info.Inventory[i] = item;
                return;
            }
        }

        private bool CorrectStartItem(ItemInfo info)
        {
            switch (Class)
            {
                case MirClass.Warrior:
                    if (!info.RequiredClass.HasFlag(RequiredClass.Warrior)) return false;
                    break;
                case MirClass.Wizard:
                    if (!info.RequiredClass.HasFlag(RequiredClass.Wizard)) return false;
                    break;
                case MirClass.Taoist:
                    if (!info.RequiredClass.HasFlag(RequiredClass.Taoist)) return false;
                    break;
                case MirClass.Assassin:
                    if (!info.RequiredClass.HasFlag(RequiredClass.Assassin)) return false;
                    break;
                case MirClass.Archer:
                    if (!info.RequiredClass.HasFlag(RequiredClass.Archer)) return false;
                    break;
                default:
                    return false;
            }

            switch (Gender)
            {
                case MirGender.Male:
                    if (!info.RequiredGender.HasFlag(RequiredGender.Male)) return false;
                    break;
                case MirGender.Female:
                    if (!info.RequiredGender.HasFlag(RequiredGender.Female)) return false;
                    break;
                default:
                    return false;
            }

            return true;
        }
        public void CheckItemInfo(ItemInfo info, bool dontLoop = false)
        {
            if ((dontLoop == false) && (info.ClassBased | info.LevelBased)) //send all potential data so client can display it
            {
                for (int i = 0; i < Envir.ItemInfoList.Count; i++)
                {
                    if ((Envir.ItemInfoList[i] != info) && (Envir.ItemInfoList[i].Name.StartsWith(info.Name)))
                        CheckItemInfo(Envir.ItemInfoList[i], true);
                }
            }

            if (Connection.SentItemInfo.Contains(info)) return;
            Enqueue(new S.NewItemInfo { Info = info });
            Connection.SentItemInfo.Add(info);
        }
        public void CheckItem(UserItem item)
        {
            CheckItemInfo(item.Info);

            for (int i = 0; i < item.Slots.Length; i++)
            {
                if (item.Slots[i] == null) continue;

                CheckItemInfo(item.Slots[i].Info);
            }
        }
        public void CheckQuestInfo(QuestInfo info)
        {
            if (Connection.SentQuestInfo.Contains(info)) return;
            Enqueue(new S.NewQuestInfo { Info = info.CreateClientQuestInfo() });
            Connection.SentQuestInfo.Add(info);
        }

        public void CheckRecipeInfo(RecipeInfo info)
        {
            if (Connection.SentRecipeInfo.Contains(info)) return;

            CheckItemInfo(info.Item.Info);

            foreach (var tool in info.Tools)
            {
                CheckItemInfo(tool.Info);
            }

            foreach (var ingredient in info.Ingredients)
            {
                CheckItemInfo(ingredient.Info);
            }

            Enqueue(new S.NewRecipeInfo { Info = info.CreateClientRecipeInfo() });
            Connection.SentRecipeInfo.Add(info);
        }

        private void SetBind()
        {
            SafeZoneInfo szi = Envir.StartPoints[Envir.Random.Next(Envir.StartPoints.Count)];

            BindMapIndex = szi.Info.Index;
            BindLocation = szi.Location;
        }
        public void StartGame()
        {
            Map temp = Envir.GetMap(CurrentMapIndex);

            if (temp != null && temp.Info.NoReconnect)
            {
                Map temp1 = Envir.GetMapByNameAndInstance(temp.Info.NoReconnectMap);
                if (temp1 != null)
                {
                    temp = temp1;
                    CurrentLocation = GetRandomPoint(40, 0, temp);
                }
            }

            if (temp == null || !temp.ValidPoint(CurrentLocation))
            {
                temp = Envir.GetMap(BindMapIndex);

                if (temp == null || !temp.ValidPoint(BindLocation))
                {
                    SetBind();
                    temp = Envir.GetMap(BindMapIndex);

                    if (temp == null || !temp.ValidPoint(BindLocation))
                    {
                        StartGameFailed();
                        return;
                    }
                }
                CurrentMapIndex = BindMapIndex;
                CurrentLocation = BindLocation;
            }
            temp.AddObject(this);
            CurrentMap = temp;
            Envir.Players.Add(this);

            StartGameSuccess();

            //Call Login NPC
            CallDefaultNPC(DefaultNPCType.Login);

            //Call Daily NPC
            if (Info.NewDay)
            {
                CallDefaultNPC(DefaultNPCType.Daily);
            }

            //Call Weekly NPC
            if (Info.NewWeek)
            {
                CallDefaultNPC(DefaultNPCType.Weekly);
            }
        }
        private void StartGameSuccess()
        {
            Connection.Stage = GameStage.Game;
            for (int i = 0; i < Info.Magics.Count; i++)
            {
                Info.Magics[i].CastTime += Envir.Time;

                //long TimeSpend = Info.Magics[i].GetDelay() - Info.Magics[i].CastTime;
                //if (TimeSpend < 0)
                //{
                //    Info.Magics[i].CastTime = 0; 
                //    continue;
                //    //avoid having server owners lower the delays and bug it :p
                //}

                if (Info.Magics[i].CastTime + Info.Magics[i].GetDelay() < Envir.Time)
                {
                    Info.Magics[i].CastTime = int.MinValue;
                }
            }
            Enqueue(new S.StartGame { Result = 4, Resolution = Settings.AllowedResolution });
            ReceiveChat(string.Format(GameLanguage.Welcome, GameLanguage.GameName), ChatType.Hint);

            if (IsGM)
            {
                //Chat("@GAMEMASTER");
                //Chat("@SUPERMAN");
            }

            if (Info.GuildIndex != -1)
            {
                //MyGuild = Envir.GetGuild(Info.GuildIndex);
                if (MyGuild == null)
                {
                    Info.GuildIndex = -1;
                    ReceiveChat("You have been removed from the guild.", ChatType.System);
                }
                else
                {
                    MyGuildRank = MyGuild.FindRank(Info.Name);
                    if (MyGuildRank == null)
                    {
                        MyGuild = null;
                        Info.GuildIndex = -1;
                        ReceiveChat("You have been removed from the guild.", ChatType.System);
                    }
                }
            }

            if (!string.IsNullOrWhiteSpace(Settings.Notice.Message) && Settings.Notice.LastUpdate > Info.LastLogoutDate)
            {
                Enqueue(new S.UpdateNotice { Notice = Settings.Notice });
            }

            Spawned();

            SetLevelEffects();

            GetItemInfo();
            GetMapInfo();
            GetUserInfo();
            GetQuestInfo();
            GetRecipeInfo();

            GetCompletedQuests();

            GetMail();
            GetFriends();
            GetRelationship();
            
            if ((Info.Mentor != 0) && (Info.MentorDate.AddDays(Settings.MentorLength) < DateTime.Now))
                MentorBreak();
            else
                GetMentor();

            CheckConquest();
            if (MyGuild == null || MyGuild.Conquest == null)
            {
                RemoveConquestItems(-1);
            }

            GetGameShop();

            for (int i = 0; i < CurrentQuests.Count; i++)
            {
                CurrentQuests[i].Init(this);
                SendUpdateQuest(CurrentQuests[i], QuestState.Add);
            }

            Enqueue(new S.BaseStatsInfo { Stats = Settings.ClassBaseStats[(byte)Class] });
            GetObjectsPassive();
            Enqueue(new S.TimeOfDay { Lights = Envir.Lights });
            Enqueue(new S.ChangeAMode { Mode = AMode });
            Enqueue(new S.ChangePMode { Mode = PMode });
            Enqueue(new S.SwitchGroup { AllowGroup = AllowGroup });

            Enqueue(new S.DefaultNPC { ObjectID = DefaultNPC.LoadedObjectID });

            Enqueue(new S.GuildBuffList() { GuildBuffs = Settings.Guild_BuffList });
            RequestedGuildBuffInfo = true;

            //ATTRIBUTES SYSTEM
            Enqueue(new S.UpdateAttributes
            {
                CurrentPoints = Info.CurrentAttributePoints,
                Attributes = Info.Attributes
            });

            if (Info.Thrusting) Enqueue(new S.SpellToggle { Spell = Spell.Thrusting, CanUse = true });
            if (Info.HalfMoon) Enqueue(new S.SpellToggle { Spell = Spell.HalfMoon, CanUse = true });
            if (Info.CrossHalfMoon) Enqueue(new S.SpellToggle { Spell = Spell.CrossHalfMoon, CanUse = true });
            if (Info.DoubleSlash) Enqueue(new S.SpellToggle { Spell = Spell.DoubleSlash, CanUse = true });

            for (int i = 0; i < Info.Pets.Count; i++)
            {
                PetInfo info = Info.Pets[i];

                MonsterObject monster = MonsterObject.GetMonster(Envir.GetMonsterInfo(info.MonsterIndex));

                if (monster == null) continue;

                monster.PetLevel = info.Level;
                monster.MaxPetLevel = info.MaxPetLevel;
                monster.PetExperience = info.Experience;

                monster.Master = this;
                Pets.Add(monster);

                monster.RefreshAll();
                if (!monster.Spawn(CurrentMap, Back))
                    monster.Spawn(CurrentMap, CurrentLocation);

                monster.SetHP(info.HP);

                if (!Settings.PetSave)
                {
                    monster.TameTime = Envir.Time + info.TameTime;
                }
            }

            Info.Pets.Clear();

            for (int i = 0; i < Info.Buffs.Count; i++)
            {
                AddBuff(Info.Buffs[i].Type, this, (int)Math.Min(Info.Buffs[i].ExpireTime, int.MaxValue), Info.Buffs[i].Stats, true, Info.Buffs[i].Values);       
            }

            Info.Buffs.Clear();

            Envir.UpdateTop(true);

            for (int i = 0; i < Info.Poisons.Count; i++)
            {
                Poison poison = Info.Poisons[i];
                poison.TickTime += Envir.Time;
                //poison.Owner = this;

                ApplyPoison(poison, poison.Owner);
            }

            Info.Poisons.Clear();

            if (MyGuild != null)
            {
                MyGuild.PlayerLogged(this, true);
                if (MyGuild.BuffList.Count > 0)
                    Enqueue(new S.GuildBuffList() { ActiveBuffs = MyGuild.BuffList});
            }

            if (InSafeZone && Info.LastLogoutDate > DateTime.MinValue)
            {
                double totalMinutes = (Envir.Now - Info.LastLogoutDate).TotalMinutes;

                _restedCounter = (int)(totalMinutes * 60);
            }

            if (Info.Mail.Count > Settings.MailCapacity)
            {
                ReceiveChat("Your mailbox is overflowing.", ChatType.System);
            }

            Report.Connected(Connection.IPAddress);

            MessageQueue.Enqueue(string.Format("{0} has connected.", Info.Name));

            UpdateRebornBuff();
            UpdateInstanceStageBuff();
            UpdateChallengeStageBuff();

            if (IsGM)
            {
                UpdateGMBuff();
            }
            else
            {
                LastRankUpdate = Envir.Time;
                if ((Level >= Envir.RankBottomLevel[0]) || (Level >= Envir.RankBottomLevel[(byte)Class + 1]))
                {
                    Envir.CheckRankUpdate(Info);
                }
            }

            if (GetMagic(Spell.MentalState) != null)
            {
                ShowMentalState();
            }
        }

        private void StartGameFailed()
        {
            Enqueue(new S.StartGame { Result = 3 });
            CleanUp();
        }

        public void SetLevelEffects()
        {
            LevelEffects = LevelEffects.None;

            if (Info.Flags[990]) LevelEffects |= LevelEffects.Mist;
            if (Info.Flags[991]) LevelEffects |= LevelEffects.RedDragon;
            if (Info.Flags[992]) LevelEffects |= LevelEffects.BlueDragon;
        }
        public void GiveRestedBonus(int count)
        {
            if (count > 0)
            {
                long existingTime = 0;

                if (HasBuff(BuffType.Rested, out Buff rested))
                {
                    existingTime = rested.ExpireTime - Envir.Time;
                }

                int duration = (int)Math.Min(int.MaxValue, ((Settings.RestedBuffLength * Settings.Minute) * count) + existingTime);
                int maxDuration = (Settings.RestedBuffLength * Settings.Minute) * Settings.RestedMaxBonus;

                if (duration > maxDuration) duration = maxDuration;

                AddBuff(BuffType.Rested, this, duration, new Stats { [Stat.ExpRatePercent] = Settings.RestedExpBonus });

                _restedCounter = 0;
            }
        }

        public void Revive(int hp, bool effect)
        {
            if (!Dead) return;

            Dead = false;
            SetHP(hp);

            CurrentMap.RemoveObject(this);
            Broadcast(new S.ObjectRemove { ObjectID = ObjectID });

            CurrentMap = this.CurrentMap;
            CurrentLocation = this.CurrentLocation;

            CurrentMap.AddObject(this);

            CurrentRT = 0;

            Enqueue(new S.MapChanged
            {
                FileName = CurrentMap.Info.FileName,
                Title = CurrentMap.Info.Title,
                MiniMap = CurrentMap.Info.MiniMap,
                BigMap = CurrentMap.Info.BigMap,
                Lights = CurrentMap.Info.Light,
                Location = CurrentLocation,
                Direction = Direction,
                MapDarkLight = CurrentMap.Info.MapDarkLight,
                Music = CurrentMap.Info.Music
            });

            GetObjects();

            Enqueue(new S.Revived());
            Broadcast(new S.ObjectRevived { ObjectID = ObjectID, Effect = effect });

            Fishing = false;
            Enqueue(GetFishInfo());
        }
        public void TownRevive()
        {
            if (!Dead) return;

            Map temp = Envir.GetMap(BindMapIndex);
            Point bindLocation = BindLocation;

            if (Info.PKPoints >= 200)
            {
                temp = Envir.GetMapByNameAndInstance(Settings.PKTownMapName, 1);
                bindLocation = new Point(Settings.PKTownPositionX, Settings.PKTownPositionY);

                if (temp == null)
                {
                    temp = Envir.GetMap(BindMapIndex);
                    bindLocation = BindLocation;
                }
            }

            if (temp == null || !temp.ValidPoint(bindLocation)) return;

            Dead = false;
            SetHP(Stats[Stat.HP]);
            SetMP(Stats[Stat.MP]);
            RefreshStats();

            CurrentMap.RemoveObject(this);
            Broadcast(new S.ObjectRemove { ObjectID = ObjectID });

            CurrentMap = temp;
            CurrentLocation = bindLocation;

            CurrentMap.AddObject(this);

            CurrentRT = 0;

            Enqueue(new S.MapChanged
            {
                FileName = CurrentMap.Info.FileName,
                Title = CurrentMap.Info.Title,
                MiniMap = CurrentMap.Info.MiniMap,
                BigMap = CurrentMap.Info.BigMap,
                Lights = CurrentMap.Info.Light,
                Location = CurrentLocation,
                Direction = Direction,
                MapDarkLight = CurrentMap.Info.MapDarkLight,
                Music = CurrentMap.Info.Music
            });

            GetObjects();
            Enqueue(new S.Revived());
            Broadcast(new S.ObjectRevived { ObjectID = ObjectID, Effect = true });


            InSafeZone = true;
            Fishing = false;
            Enqueue(GetFishInfo());
        }

        private void GetItemInfo()
        {
            UserItem item;
            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                item = Info.Inventory[i];
                if (item == null) continue;

                CheckItem(item);
            }

            for (int i = 0; i < Info.Equipment.Length; i++)
            {
                item = Info.Equipment[i];

                if (item == null) continue;

                CheckItem(item);
            }

            for (int i = 0; i < Info.QuestInventory.Length; i++)
            {
                item = Info.QuestInventory[i];

                if (item == null) continue;
                CheckItem(item);
            }
        }
        private void GetUserInfo()
        {
            string guildname = MyGuild != null ? MyGuild.Name : "";
            string guildrank = MyGuild != null ? MyGuildRank.Name : "";
            S.UserInformation packet = new S.UserInformation
            {
                ObjectID = ObjectID,
                RealId = (uint)Info.Index,
                Name = Name,
                GuildName = guildname,
                GuildRank = guildrank,
                NameColour = GetNameColour(this),
                Class = Class,
                Gender = Gender,
                Level = Level,
                Reborn = Reborn,
                InstanceStage = InstanceStage,
                ChallengeStage = ChallengeStage,
                Location = CurrentLocation,
                Direction = Direction,
                Hair = Hair,
                HP = HP,
                MP = MP,

                Experience = Experience,
                MaxExperience = MaxExperience,

                LevelEffects = LevelEffects,

                Inventory = new UserItem[Info.Inventory.Length],
                Equipment = new UserItem[Info.Equipment.Length],
                QuestInventory = new UserItem[Info.QuestInventory.Length],
                Gold = Account.Gold,
                Credit = Account.Credit,
                HuntPoints = Account.HuntPoints,
                HasExpandedStorage = Account.ExpandedStorageExpiryDate > Envir.Now ? true : false,
                ExpandedStorageExpiryTime = Account.ExpandedStorageExpiryDate
            };

            //Copy this method to prevent modification before sending packet information.
            for (int i = 0; i < Info.Magics.Count; i++)
                packet.Magics.Add(Info.Magics[i].CreateClientMagic());

            Info.Inventory.CopyTo(packet.Inventory, 0);
            Info.Equipment.CopyTo(packet.Equipment, 0);
            Info.QuestInventory.CopyTo(packet.QuestInventory, 0);

            //IntelligentCreature
            for (int i = 0; i < Info.IntelligentCreatures.Count; i++)
                packet.IntelligentCreatures.Add(Info.IntelligentCreatures[i].CreateClientIntelligentCreature());
            packet.SummonedCreatureType = SummonedCreatureType;
            packet.CreatureSummoned = CreatureSummoned;

            Enqueue(packet);
        }
        private void GetMapInfo()
        {
            Enqueue(new S.MapInformation
            {
                FileName = CurrentMap.Info.FileName,
                Title = CurrentMap.Info.Title,
                MiniMap = CurrentMap.Info.MiniMap,
                Lights = CurrentMap.Info.Light,
                BigMap = CurrentMap.Info.BigMap,
                Lightning = CurrentMap.Info.Lightning,
                Fire = CurrentMap.Info.Fire,
                MapDarkLight = CurrentMap.Info.MapDarkLight,
                Music = CurrentMap.Info.Music,
            });
        }

        private void GetQuestInfo()
        {
            for (int i = 0; i < Envir.QuestInfoList.Count; i++)
            {
                CheckQuestInfo(Envir.QuestInfoList[i]);
            }
        }
        private void GetRecipeInfo()
        {
            for (int i = 0; i < Envir.RecipeInfoList.Count; i++)
            {
                CheckRecipeInfo(Envir.RecipeInfoList[i]);
            }
        }
        private void GetObjects()
        {
            for (int y = CurrentLocation.Y - Globals.DataRange; y <= CurrentLocation.Y + Globals.DataRange; y++)
            {
                if (y < 0) continue;
                if (y >= CurrentMap.Height) break;

                for (int x = CurrentLocation.X - Globals.DataRange; x <= CurrentLocation.X + Globals.DataRange; x++)
                {
                    if (x < 0) continue;
                    if (x >= CurrentMap.Width) break;
                    if (x < 0 || x >= CurrentMap.Width) continue;

                    Cell cell = CurrentMap.GetCell(x, y);

                    if (!cell.Valid || cell.Objects == null) continue;

                    for (int i = 0; i < cell.Objects.Count; i++)
                    {
                        MapObject ob = cell.Objects[i];

                        //if (ob.Race == ObjectType.Player && ob.Observer) continue;

                        ob.Add(this);
                    }
                }
            }
        }
        private void GetObjectsPassive()
        {
            for (int y = CurrentLocation.Y - Globals.DataRange; y <= CurrentLocation.Y + Globals.DataRange; y++)
            {
                if (y < 0) continue;
                if (y >= CurrentMap.Height) break;

                for (int x = CurrentLocation.X - Globals.DataRange; x <= CurrentLocation.X + Globals.DataRange; x++)
                {
                    if (x < 0) continue;
                    if (x >= CurrentMap.Width) break;
                    if (x < 0 || x >= CurrentMap.Width) continue;

                    Cell cell = CurrentMap.GetCell(x, y);

                    if (!cell.Valid || cell.Objects == null) continue;

                    for (int i = 0; i < cell.Objects.Count; i++)
                    {
                        MapObject ob = cell.Objects[i];
                        if (ob == this) continue;

                        //if (ob.Race == ObjectType.Player && ob.Observer) continue;
                        if (ob.Race == ObjectType.Player)
                        {
                            PlayerObject Player = (PlayerObject)ob;
                            Enqueue(Player.GetInfoEx(this));
                        }
                        else if (ob.Race == ObjectType.Spell)
                        {
                            SpellObject obSpell = (SpellObject)ob;

                            if ((obSpell.Spell != Spell.ExplosiveTrap) || (obSpell.Caster != null && IsFriendlyTarget(obSpell.Caster)))
                                Enqueue(ob.GetInfo());
                        }
                        else if (ob.Race == ObjectType.Merchant)
                        {
                            NPCObject NPC = (NPCObject)ob;

                            NPC.CheckVisible(this);

                            if (NPC.VisibleLog[Info.Index] && NPC.Visible) Enqueue(ob.GetInfo());
                        }
                        else
                        {
                            Enqueue(ob.GetInfo());
                        }

                        if (ob.Race == ObjectType.Player || ob.Race == ObjectType.Monster)
                            ob.SendHealth(this);
                    }
                }
            }
        }

        #region Refresh Stats

        public void RefreshStats()
        {
            if (HasUpdatedBaseStats == false)
            {
                Enqueue(new S.BaseStatsInfo { Stats = Settings.ClassBaseStats[(byte)Class] });
                HasUpdatedBaseStats = true;
            }

            Stats.Clear();

            RefreshAttributeStats();
            RefreshLevelStats();
            RefreshBagWeight();
            RefreshEquipmentStats();
            RefreshItemSetStats();
            RefreshMirSetStats();
            RefreshSkills();
            RefreshBuffs();
            RefreshGuildBuffs();

            //Add any rate percent changes

            Stats[Stat.HP] += (Stats[Stat.HP] * Stats[Stat.HPRatePercent]) / 100;
            Stats[Stat.MP] += (Stats[Stat.MP] * Stats[Stat.MPRatePercent]) / 100;
            Stats[Stat.MinAC] += (Stats[Stat.MinAC] * Stats[Stat.MinACRatePercent]) / 100;
            Stats[Stat.MaxAC] += (Stats[Stat.MaxAC] * Stats[Stat.MaxACRatePercent]) / 100;
            Stats[Stat.MinMAC] += (Stats[Stat.MinMAC] * Stats[Stat.MinMACRatePercent]) / 100;
            Stats[Stat.MaxMAC] += (Stats[Stat.MaxMAC] * Stats[Stat.MaxMACRatePercent]) / 100;

            Stats[Stat.MinDC] += (Stats[Stat.MinDC] * Stats[Stat.MinDCRatePercent]) / 100;
            Stats[Stat.MaxDC] += (Stats[Stat.MaxDC] * Stats[Stat.MaxDCRatePercent]) / 100;
            Stats[Stat.MinMC] += (Stats[Stat.MinMC] * Stats[Stat.MinMCRatePercent]) / 100;
            Stats[Stat.MaxMC] += (Stats[Stat.MaxMC] * Stats[Stat.MaxMCRatePercent]) / 100;
            Stats[Stat.MinSC] += (Stats[Stat.MinSC] * Stats[Stat.MinSCRatePercent]) / 100;
            Stats[Stat.MaxSC] += (Stats[Stat.MaxSC] * Stats[Stat.MaxSCRatePercent]) / 100;
            Stats[Stat.AttackSpeed] += (Stats[Stat.AttackSpeed] * Stats[Stat.AttackSpeedRatePercent]) / 100;

            RefreshStatCaps();

            if (HP > Stats[Stat.HP]) SetHP(Stats[Stat.HP]);
            if (MP > Stats[Stat.MP]) SetMP(Stats[Stat.MP]);

            AttackSpeed = 1400 - ((Stats[Stat.AttackSpeed] * 60) + Math.Min(370, (Level * 14)));

            if (AttackSpeed < 550) AttackSpeed = 550;
        }


        //ATTRIBUTES SYSTEM
        private void RefreshAttributeStats()
        {
            Stats[Stat.HP] = (int)Math.Min(int.MaxValue, Stats[Stat.HP] + Info.Attributes.GetValue("HP"));
            Stats[Stat.MP] = (int)Math.Min(int.MaxValue, Stats[Stat.MP] + Info.Attributes.GetValue("MP"));
            Stats[Stat.MinAC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MinAC] + Info.Attributes.GetValue("MinAC"));
            Stats[Stat.MaxAC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MaxAC] + Info.Attributes.GetValue("MaxAC"));
            Stats[Stat.MinMAC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MinMAC] + Info.Attributes.GetValue("MinMAC"));
            Stats[Stat.MaxMAC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MaxMAC] + Info.Attributes.GetValue("MaxMAC"));
            Stats[Stat.MinDC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MinDC] + Info.Attributes.GetValue("MinDC"));
            Stats[Stat.MaxDC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MaxDC] + Info.Attributes.GetValue("MaxDC"));
            Stats[Stat.MinMC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MinMC] + Info.Attributes.GetValue("MinMC"));
            Stats[Stat.MaxMC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MaxMC] + Info.Attributes.GetValue("MaxMC"));
            Stats[Stat.MinSC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MinSC] + Info.Attributes.GetValue("MinSC"));
            Stats[Stat.MaxSC] = (ushort)Math.Min(ushort.MaxValue, Stats[Stat.MaxSC] + Info.Attributes.GetValue("MaxSC"));
        }

        private void RefreshLevelStats()
        {
            MaxExperience = Level < Settings.ExperienceList.Count ? Settings.ExperienceList[Level - 1] : 0;

            foreach (var stat in Settings.ClassBaseStats[(byte)Class].Stats)
            {
                Stats[stat.Type] = stat.Calculate(Class, Level);
            }

            ushort level = Info.Level;
            ushort old_level = Info.Level;

            Info.Level = level;

            if (old_level != Info.Level)
            {
                Envir.UpdateTop();
            }
        }

        private void RefreshBagWeight()
        {
            CurrentBagWeight = 0;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                UserItem item = Info.Inventory[i];
                if (item != null)
                {
                    CurrentBagWeight += item.Weight;
                }
            }
        }

        private void RefreshEquipmentStats()
        {
            short OldLooks_Weapon = Looks_Weapon;
            short OldLooks_WeaponEffect = Looks_WeaponEffect;
            short OldLooks_Armour = Looks_Armour;
            short Old_MountType = MountType;
            byte OldLooks_Wings = Looks_Wings;
            byte OldLight = Light;

            Looks_Armour = 0;
            Looks_Weapon = -1;
            Looks_WeaponEffect = 0;
            Looks_Wings = 0;
            Light = 0;
            CurrentWearWeight = 0;
            CurrentHandWeight = 0;
            MountType = -1;

            SpecialMode = SpecialItemMode.None;

            FastRun = false;

            Stats[Stat.SkillGainMultiplier] = 1;

            var skillsToAdd = new List<string>();
            var skillsToRemove = new List<string> { Settings.HealRing, Settings.FireRing, Settings.BlinkSkill };

            ItemSets.Clear();
            MirSet.Clear();

            for (int i = 0; i < Info.Equipment.Length; i++)
            {
                UserItem temp = Info.Equipment[i];
                if (temp == null) continue;
                ItemInfo RealItem = Functions.GetRealItem(temp.Info, Info.Level, Info.Class, Envir.ItemInfoList);

                if (RealItem.Type == ItemType.Weapon || RealItem.Type == ItemType.Torch)
                    CurrentHandWeight = (int)Math.Min(int.MaxValue, CurrentHandWeight + temp.Weight);
                else
                    CurrentWearWeight = (int)Math.Min(int.MaxValue, CurrentWearWeight + temp.Weight);

                if (temp.CurrentDura == 0 && temp.Info.Durability > 0) continue;

                if (temp.Info.IsFishingRod) continue;


                Stats.Add(RealItem.Stats);
                Stats.Add(temp.AddedStats);

                Stats[Stat.MinAC] += temp.Awake.GetAC();
                Stats[Stat.MaxAC] += temp.Awake.GetAC();
                Stats[Stat.MinMAC] += temp.Awake.GetMAC();
                Stats[Stat.MaxMAC] += temp.Awake.GetMAC();

                Stats[Stat.MinDC] += temp.Awake.GetDC();
                Stats[Stat.MaxDC] += temp.Awake.GetDC();
                Stats[Stat.MinMC] += temp.Awake.GetMC();
                Stats[Stat.MaxMC] += temp.Awake.GetMC();
                Stats[Stat.MinSC] += temp.Awake.GetSC();
                Stats[Stat.MaxSC] += temp.Awake.GetSC();

                Stats[Stat.HP] += temp.Awake.GetHPMP();
                Stats[Stat.MP] += temp.Awake.GetHPMP();

                if (RealItem.Light > Light) Light = RealItem.Light;
                if (RealItem.Unique != SpecialItemMode.None)
                {
                    SpecialMode |= RealItem.Unique;

                    if (RealItem.Unique.HasFlag(SpecialItemMode.Flame)) skillsToAdd.Add(Settings.FireRing);
                    if (RealItem.Unique.HasFlag(SpecialItemMode.Healing)) skillsToAdd.Add(Settings.HealRing);
                    if (RealItem.Unique.HasFlag(SpecialItemMode.Blink)) skillsToAdd.Add(Settings.BlinkSkill);
                }

                if (RealItem.CanFastRun)
                {
                    FastRun = true;
                }

                RefreshSocketStats(temp, skillsToAdd);

                if (RealItem.Type == ItemType.Armour)
                {
                    Looks_Armour = RealItem.Shape;
                    Looks_Wings = RealItem.Effect;
                }

                if (RealItem.Type == ItemType.Weapon)
                {
                    Looks_Weapon = RealItem.Shape;
                    Looks_WeaponEffect = RealItem.Effect;
                }

                if (RealItem.Type == ItemType.Mount)
                {
                    MountType = RealItem.Shape;
                    //RealItem.Effect;
                }

                if (RealItem.Set == ItemSet.None) continue;

                ItemSets itemSet = ItemSets.Where(set => set.Set == RealItem.Set && !set.Type.Contains(RealItem.Type) && !set.SetComplete).FirstOrDefault();

                if (itemSet != null)
                {
                    itemSet.Type.Add(RealItem.Type);
                    itemSet.Count++;
                }
                else
                {
                    ItemSets.Add(new ItemSets { Count = 1, Set = RealItem.Set, Type = new List<ItemType> { RealItem.Type } });
                }

                //Mir Set
                if (RealItem.Set == ItemSet.Mir)
                {
                    if (!MirSet.Contains((EquipmentSlot)i))
                        MirSet.Add((EquipmentSlot)i);
                }
            }

            AddTempSkills(skillsToAdd);
            RemoveTempSkills(skillsToRemove.Except(skillsToAdd));

            if (SpecialMode.HasFlag(SpecialItemMode.Muscle))
            {
                Stats[Stat.BagWeight] = Stats[Stat.BagWeight] * 2;
                Stats[Stat.WearWeight] = Stats[Stat.WearWeight] * 2;
                Stats[Stat.HandWeight] = Stats[Stat.HandWeight] * 2;
            }

            if ((OldLooks_Armour != Looks_Armour) || (OldLooks_Weapon != Looks_Weapon) || (OldLooks_WeaponEffect != Looks_WeaponEffect) || (OldLooks_Wings != Looks_Wings) || (OldLight != Light))
            {
                Broadcast(GetUpdateInfo());

                if (Globals.FishingRodShapes.Contains(OldLooks_Weapon) != Globals.FishingRodShapes.Contains(Looks_Weapon))
                {
                    Enqueue(GetFishInfo());
                }
            }

            if (Old_MountType != MountType)
            {
                RefreshMount(false);
            }
        }

        private void RefreshSocketStats(UserItem equipItem, List<string> skillsToAdd)
        {
            if (equipItem == null) return;

            if (equipItem.Info.Type == ItemType.Weapon && equipItem.Info.IsFishingRod)
            {
                return;
            }

            if (equipItem.Info.Type == ItemType.Mount && !RidingMount)
            {
                return;
            }

            for (int j = 0; j < equipItem.Slots.Length; j++)
            {
                UserItem temp = equipItem.Slots[j];
                if (temp == null) continue;

                ItemInfo RealItem = Functions.GetRealItem(temp.Info, Info.Level, Info.Class, Envir.ItemInfoList);

                if (RealItem.Type == ItemType.Weapon || RealItem.Type == ItemType.Torch)
                    CurrentHandWeight = (int)Math.Min(int.MaxValue, CurrentHandWeight + temp.Weight);
                else
                    CurrentWearWeight = (int)Math.Min(int.MaxValue, CurrentWearWeight + temp.Weight);

                if (temp.CurrentDura == 0 && temp.Info.Durability > 0) continue;

                Stats.Add(RealItem.Stats);
                Stats.Add(temp.AddedStats);

                if (RealItem.Light > Light) Light = RealItem.Light;
                if (RealItem.Unique != SpecialItemMode.None)
                {
                    SpecialMode |= RealItem.Unique;

                    if (RealItem.Unique.HasFlag(SpecialItemMode.Skill)) Stats[Stat.SkillGainMultiplier] = 3;

                    if (RealItem.Unique.HasFlag(SpecialItemMode.Flame)) skillsToAdd.Add(Settings.FireRing);
                    if (RealItem.Unique.HasFlag(SpecialItemMode.Healing)) skillsToAdd.Add(Settings.HealRing);
                    if (RealItem.Unique.HasFlag(SpecialItemMode.Blink)) skillsToAdd.Add(Settings.BlinkSkill);
                }
            }

            //TODO - Add Socket bonuses
        }

        private void RefreshItemSetStats()
        {
            foreach (var s in ItemSets)
            {
                if ((s.Set == ItemSet.Smash) &&
                    ((s.Type.Contains(ItemType.Ring) && s.Type.Contains(ItemType.Bracelet)) || (s.Type.Contains(ItemType.Ring) && s.Type.Contains(ItemType.Necklace)) || (s.Type.Contains(ItemType.Bracelet) && s.Type.Contains(ItemType.Necklace))))
                {
                    Stats[Stat.AttackSpeed] += 2;
                }

                if ((s.Set == ItemSet.Purity) && (s.Type.Contains(ItemType.Ring)) && (s.Type.Contains(ItemType.Bracelet)))
                {
                    Stats[Stat.Holy] += 3;
                }

                if ((s.Set == ItemSet.HwanDevil) && (s.Type.Contains(ItemType.Ring)) && (s.Type.Contains(ItemType.Bracelet)))
                {
                    Stats[Stat.WearWeight] += 5;
                    Stats[Stat.BagWeight] += 20;
                }

                if ((s.Set == ItemSet.DarkGhost) && (s.Type.Contains(ItemType.Necklace)) && (s.Type.Contains(ItemType.Bracelet)))
                {
                    Stats[Stat.HP] += 25;
                }

                if (!s.SetComplete) continue;

                switch (s.Set)
                {
                    case ItemSet.Mundane:
                        Stats[Stat.HP] += 50;
                        break;
                    case ItemSet.NokChi:
                        Stats[Stat.MP] += 50;
                        break;
                    case ItemSet.TaoProtect:
                        Stats[Stat.HP] += 30;
                        Stats[Stat.MP] += 30;
                        break;
                    case ItemSet.RedOrchid:
                        Stats[Stat.Accuracy] += 2;
                        Stats[Stat.HPDrainRatePercent] += 10;
                        break;
                    case ItemSet.RedFlower:
                        Stats[Stat.HP] += 50;
                        Stats[Stat.MP] -= 25;
                        break;
                    case ItemSet.Smash:
                        Stats[Stat.MinDC] += 1;
                        Stats[Stat.MaxDC] += 3;
                        break;
                    case ItemSet.HwanDevil:
                        Stats[Stat.MinMC] += 1;
                        Stats[Stat.MaxMC] += 2;
                        break;
                    case ItemSet.Purity:
                        Stats[Stat.MinSC] += 1;
                        Stats[Stat.MaxSC] += 2;
                        break;
                    case ItemSet.FiveString:
                        Stats[Stat.HP] += (int)(((double)Stats[Stat.HP] / 100) * 30);
                        Stats[Stat.MinAC] += 2;
                        Stats[Stat.MaxAC] += 2;
                        break;
                    case ItemSet.Spirit:
                        Stats[Stat.MinDC] += 2;
                        Stats[Stat.MaxDC] += 5;
                        Stats[Stat.AttackSpeed] += 2;
                        break;
                    case ItemSet.Bone:
                        Stats[Stat.MaxAC] += 2;
                        Stats[Stat.MaxMC] += 1;
                        Stats[Stat.MaxSC] += 1;
                        break;
                    case ItemSet.Bug:
                        Stats[Stat.MaxDC] += 1;
                        Stats[Stat.MaxMC] += 1;
                        Stats[Stat.MaxSC] += 1;
                        Stats[Stat.MaxMAC] += 1;
                        Stats[Stat.PoisonResist] += 1;
                        break;
                    case ItemSet.WhiteGold:
                        Stats[Stat.MaxDC] += 2;
                        Stats[Stat.MaxAC] += 2;
                        break;
                    case ItemSet.WhiteGoldH:
                        Stats[Stat.MaxDC] += 3;
                        Stats[Stat.HP] += 30;
                        Stats[Stat.AttackSpeed] += 2;
                        break;
                    case ItemSet.RedJade:
                        Stats[Stat.MaxMC] += 2;
                        Stats[Stat.MaxMAC] += 2;
                        break;
                    case ItemSet.RedJadeH:
                        Stats[Stat.MaxMC] += 2;
                        Stats[Stat.MP] += 40;
                        Stats[Stat.Agility] += 2;
                        break;
                    case ItemSet.Nephrite:
                        Stats[Stat.MaxSC] += 2;
                        Stats[Stat.MaxAC] += 1;
                        Stats[Stat.MaxMAC] += 1;
                        break;
                    case ItemSet.NephriteH:
                        Stats[Stat.MaxSC] += 2;
                        Stats[Stat.HP] += 15;
                        Stats[Stat.MP] += 20;
                        Stats[Stat.Holy] += 1;
                        Stats[Stat.Accuracy] += 1;
                        break;
                    case ItemSet.Whisker1:
                        Stats[Stat.MaxDC] += 1;
                        Stats[Stat.BagWeight] += 25;
                        break;
                    case ItemSet.Whisker2:
                        Stats[Stat.MaxMC] += 1;
                        Stats[Stat.BagWeight] += 17;
                        break;
                    case ItemSet.Whisker3:
                        Stats[Stat.MaxSC] += 1;
                        Stats[Stat.BagWeight] += 17;
                        break;
                    case ItemSet.Whisker4:
                        Stats[Stat.MaxDC] += 1;
                        Stats[Stat.BagWeight] += 20;
                        break;
                    case ItemSet.Whisker5:
                        Stats[Stat.MaxDC] += 1;
                        Stats[Stat.BagWeight] += 17;
                        break;
                    case ItemSet.Hyeolryong:
                        Stats[Stat.MaxSC] += 2;
                        Stats[Stat.HP] += 15;
                        Stats[Stat.MP] += 20;
                        Stats[Stat.Holy] += 1;
                        Stats[Stat.Accuracy] += 1;
                        break;
                    case ItemSet.Monitor:
                        Stats[Stat.MagicResist] += 1;
                        Stats[Stat.PoisonResist] += 1;
                        break;
                    case ItemSet.Oppressive:
                        Stats[Stat.MaxAC] += 1;
                        Stats[Stat.Agility] += 1;
                        break;
                    case ItemSet.BlueFrost:
                        Stats[Stat.MinDC] += 1;
                        Stats[Stat.MaxDC] += 1;
                        Stats[Stat.MinMC] += 1;
                        Stats[Stat.MaxMC] += 1;
                        Stats[Stat.HandWeight] += 1;
                        Stats[Stat.WearWeight] += 2;
                        break;
                    case ItemSet.BlueFrostH:
                        Stats[Stat.MinDC] += 1;
                        Stats[Stat.MaxDC] += 2;
                        Stats[Stat.MaxMC] += 2;
                        Stats[Stat.Accuracy] += 1;
                        Stats[Stat.HP] += 50;
                        break;
                    case ItemSet.DarkGhost:
                        Stats[Stat.MP] += 25;
                        Stats[Stat.AttackSpeed] += 2;
                        break;
                }
            }
        }

        private void RefreshMirSetStats()
        {
            if (MirSet.Count() == 10)
            {
                Stats[Stat.MaxAC] += 1;
                Stats[Stat.MaxMAC] += 1;
                Stats[Stat.BagWeight] += 70;
                Stats[Stat.Luck] += 2;
                Stats[Stat.AttackSpeed] += 2;
                Stats[Stat.HP] += 70;
                Stats[Stat.MP] += 80;
                Stats[Stat.MagicResist] += 6;
                Stats[Stat.PoisonResist] += 6;
            }
            
            if (MirSet.Contains(EquipmentSlot.RingL) && MirSet.Contains(EquipmentSlot.RingR))
            {
                Stats[Stat.MaxMAC] += 1;
                Stats[Stat.MaxAC] += 1;
            }
            if (MirSet.Contains(EquipmentSlot.BraceletL) && MirSet.Contains(EquipmentSlot.BraceletR))
            {
                Stats[Stat.MinAC] += 1;
                Stats[Stat.MinMAC] += 1;
            }
            if ((MirSet.Contains(EquipmentSlot.RingL) | MirSet.Contains(EquipmentSlot.RingR)) && (MirSet.Contains(EquipmentSlot.BraceletL) | MirSet.Contains(EquipmentSlot.BraceletR)) && MirSet.Contains(EquipmentSlot.Necklace))
            {
                Stats[Stat.MaxMAC] += 1;
                Stats[Stat.MaxAC] += 1;
                Stats[Stat.BagWeight] += 30;
                Stats[Stat.WearWeight] += 17;
            }
            if (MirSet.Contains(EquipmentSlot.RingL) && MirSet.Contains(EquipmentSlot.RingR) && MirSet.Contains(EquipmentSlot.BraceletL) && MirSet.Contains(EquipmentSlot.BraceletR) && MirSet.Contains(EquipmentSlot.Necklace))
            {
                Stats[Stat.MaxMAC] += 1;
                Stats[Stat.MaxAC] += 1;
                Stats[Stat.BagWeight] += 20;
                Stats[Stat.WearWeight] += 10;
            }
            if (MirSet.Contains(EquipmentSlot.Armour) && MirSet.Contains(EquipmentSlot.Helmet) && MirSet.Contains(EquipmentSlot.Weapon))
            {
                Stats[Stat.MaxDC] += 2;
                Stats[Stat.MaxMC] += 1;
                Stats[Stat.MaxSC] += 1;
                Stats[Stat.Agility] += 1;
            }
            if (MirSet.Contains(EquipmentSlot.Armour) && MirSet.Contains(EquipmentSlot.Boots) && MirSet.Contains(EquipmentSlot.Belt))
            {
                Stats[Stat.MaxDC] += 1;
                Stats[Stat.MaxMC] += 1;
                Stats[Stat.MaxSC] += 1;
                Stats[Stat.HandWeight] += 17;
            }
            if (MirSet.Contains(EquipmentSlot.Armour) && MirSet.Contains(EquipmentSlot.Boots) && MirSet.Contains(EquipmentSlot.Belt) && MirSet.Contains(EquipmentSlot.Helmet) && MirSet.Contains(EquipmentSlot.Weapon))
            {
                Stats[Stat.MinDC] += 1;
                Stats[Stat.MaxDC] += 1;
                Stats[Stat.MinMC] += 1;
                Stats[Stat.MaxMC] += 1;
                Stats[Stat.MinSC] += 1;
                Stats[Stat.MaxSC] += 1;
                Stats[Stat.HandWeight] += 17;
            }
        }

        public void RefreshStatCaps()
        {
            foreach (var cap in Settings.ClassBaseStats[(byte)Class].Caps.Values)
            {
                Stats[cap.Key] = Math.Min(cap.Value, Stats[cap.Key]);
            }

            Stats[Stat.HP] = Math.Max(0, Stats[Stat.HP]);
            Stats[Stat.MP] = Math.Max(0, Stats[Stat.MP]);

            Stats[Stat.MinAC] = Math.Max(0, Stats[Stat.MinAC]);
            Stats[Stat.MaxAC] = Math.Max(0, Stats[Stat.MaxAC]);
            Stats[Stat.MinMAC] = Math.Max(0, Stats[Stat.MinMAC]);
            Stats[Stat.MaxMAC] = Math.Max(0, Stats[Stat.MaxMAC]);
            Stats[Stat.MinDC] = Math.Max(0, Stats[Stat.MinDC]);
            Stats[Stat.MaxDC] = Math.Max(0, Stats[Stat.MaxDC]);
            Stats[Stat.MinMC] = Math.Max(0, Stats[Stat.MinMC]);
            Stats[Stat.MaxMC] = Math.Max(0, Stats[Stat.MaxMC]);
            Stats[Stat.MinSC] = Math.Max(0, Stats[Stat.MinSC]);
            Stats[Stat.MaxSC] = Math.Max(0, Stats[Stat.MaxSC]);

            Stats[Stat.MinDC] = Math.Min(Stats[Stat.MinDC], Stats[Stat.MaxDC]);
            Stats[Stat.MinMC] = Math.Min(Stats[Stat.MinMC], Stats[Stat.MaxMC]);
            Stats[Stat.MinSC] = Math.Min(Stats[Stat.MinSC], Stats[Stat.MaxSC]);
        }

        #endregion

        private void AddTempSkills(IEnumerable<string> skillsToAdd)
        {
            foreach (var skill in skillsToAdd)
            {
                Spell spelltype;
                bool hasSkill = false;

                if (!Enum.TryParse(skill, out spelltype)) return;

                for (var i = Info.Magics.Count - 1; i >= 0; i--)
                    if (Info.Magics[i].Spell == spelltype) hasSkill = true;

                if (hasSkill) continue;

                var magic = new UserMagic(spelltype) { IsTempSpell = true };
                Info.Magics.Add(magic);
                Enqueue(magic.GetInfo());
            }
        }
        private void RemoveTempSkills(IEnumerable<string> skillsToRemove)
        {
            foreach (var skill in skillsToRemove)
            {
                if (!Enum.TryParse(skill, out Spell spelltype)) return;

                for (var i = Info.Magics.Count - 1; i >= 0; i--)
                {
                    if (!Info.Magics[i].IsTempSpell || Info.Magics[i].Spell != spelltype) continue;

                    Info.Magics.RemoveAt(i);
                    Enqueue(new S.RemoveMagic { PlaceId = i });
                }
            }
        }

        private void RefreshSkills()
        {
            int[] spiritSwordLvPlus = { 0, 3, 5, 8 };
            int[] slayingLvPlus = {5, 6, 7, 8};
            for (int i = 0; i < Info.Magics.Count; i++)
            {
                UserMagic magic = Info.Magics[i];
                switch (magic.Spell)
                {
                    case Spell.Fencing:
                        Stats[Stat.Accuracy] += magic.Level * 3;
                        // Stats[Stat.MaxAC] += (magic.Level + 1) * 3;
                        break;
                    // case Spell.FatalSword:
                    case Spell.Slaying:
                        Stats[Stat.Accuracy] += magic.Level;
                        Stats[Stat.MaxDC] += slayingLvPlus[magic.Level];
                        break;
                    case Spell.SpiritSword:
                        Stats[Stat.Accuracy] += spiritSwordLvPlus[magic.Level];
                        // Stats[Stat.Accuracy] += magic.Level;
                        // Stats[Stat.MaxDC] += (int)(Stats[Stat.MaxSC] * (magic.Level + 1) * 0.1F);
                        break;
                }
            }
        }

        private void RefreshBuffs()
        {
            short Old_TransformType = TransformType;

            TransformType = -1;

            for (int i = 0; i < Buffs.Count; i++)
            {
                Buff buff = Buffs[i];

                if (buff.Paused) continue;

                Stats.Add(buff.Stats);

                if (buff.Values != null && buff.Values.Length > 0)
                {
                    switch (buff.Type)
                    {
                        case BuffType.Transform:
                            TransformType = (short)buff.Values[0];
                            FastRun = true;
                            break;
                        case BuffType.ExpRatePercent:
                            Stats[Stat.ExpRatePercent] = (int)Math.Min(int.MaxValue, Stats[Stat.ExpRatePercent] + buff.Values[0]);
                            break;
                        case BuffType.ExpRate:
                            Stats[Stat.ExpRate] = (int)Math.Min(int.MaxValue, Stats[Stat.ExpRate] + buff.Values[0]);
                            break;
                        case BuffType.WonderDrug:
                            break;
                    }
                }
            }

            if (Old_TransformType != TransformType)
            {
                Broadcast(new S.TransformUpdate { ObjectID = ObjectID, TransformType = TransformType });
            }
        }

        public void RefreshGuildBuffs()
        {
            if (MyGuild == null) return;
            if (MyGuild.BuffList.Count == 0) return;

            for (int i = 0; i < MyGuild.BuffList.Count; i++)
            {
                GuildBuff buff = MyGuild.BuffList[i];
                if ((buff.Info == null) || (!buff.Active)) continue;

                Stats.Add(buff.Info.Stats);
            }
        }

        public void RefreshNameColour()
        {
            var prevColor = NameColour;
            Color colour = Color.White;
            
            if (PKPoints >= 200)
                colour = Color.Red;
            else if (WarZone)
            {
                if (MyGuild == null)
                    colour = Color.Green;
                else
                    colour = Color.Blue;
            }
            else if (Envir.Time < BrownTime)
                colour = Color.SaddleBrown;
            else if (PKPoints >= 100)
                colour = Color.Yellow;

            NameColour = colour;

            if (NameColour == Color.White)
            {
                NameColour = TempColour;
            }

            if (prevColor == NameColour) return;

            if ((MyGuild == null) || (!MyGuild.IsAtWar()))
                Enqueue(new S.ColourChanged { NameColour = NameColour });

            BroadcastColourChange();
        }

        public Color GetNameColour(PlayerObject player)
        {
            if (player == null) return NameColour;

            if (WarZone)
            {
                if (MyGuild == null)
                    return Color.Green;
                else
                {
                    if (player.MyGuild == null)
                        return Color.Orange;
                    if (player.MyGuild == MyGuild)
                        return Color.Blue;
                    else
                        return Color.Orange;
                }
            }

            if (MyGuild != null)
                if (MyGuild.IsAtWar())
                    if (player.MyGuild == MyGuild)
                        return Color.Blue;
                    else
                        if (MyGuild.IsEnemy(player.MyGuild))
                            return Color.Orange;
            return NameColour;
        }

        public void BroadcastColourChange()
        {
            if (CurrentMap == null) return;

            for (int i = CurrentMap.Players.Count - 1; i >= 0; i--)
            {
                PlayerObject player = CurrentMap.Players[i];
                if (player == this) continue;

                if (Functions.InRange(CurrentLocation, player.CurrentLocation, Globals.DataRange))
                    player.Enqueue(new S.ObjectColourChanged { ObjectID = ObjectID, NameColour = GetNameColour(this) });
            }
        }

        public override void BroadcastInfo()
        {
            Packet p;
            if (CurrentMap == null) return;

            for (int i = CurrentMap.Players.Count - 1; i >= 0; i--)
            {
                PlayerObject player = CurrentMap.Players[i];
                if (player == this) continue;

                if (Functions.InRange(CurrentLocation, player.CurrentLocation, Globals.DataRange))
                {
                    p = GetInfoEx(player);
                    if (p != null)
                        player.Enqueue(p);
                }
            }
        }

        public void Chat(string message, List<ChatItem> linkedItems = null)
        {
            if (string.IsNullOrEmpty(message)) return;

            MessageQueue.EnqueueChat(string.Format("{0}: {1}", Name, message));

            if (GMLogin)
            {
                if (message == GMPassword)
                {
                    IsGM = true;
                    UpdateGMBuff();
                    MessageQueue.Enqueue(string.Format("{0} is now a GM", Name));
                    ReceiveChat("You have been made a GM", ChatType.System);
                    Envir.RemoveRank(Info);//remove gm chars from ranking to avoid causing bugs in rank list
                }
                else
                {
                    MessageQueue.Enqueue(string.Format("{0} attempted a GM login", Name));
                    ReceiveChat("Incorrect login password", ChatType.System);
                }
                GMLogin = false;
                return;
            }

            if (Info.ChatBanned)
            {
                if (Info.ChatBanExpiryDate > DateTime.Now)
                {
                    ReceiveChat("You are currently banned from chatting.", ChatType.System);
                    return;
                }

                Info.ChatBanned = false;
            }
            else
            {
                if (ChatTime > Envir.Time)
                {
                    if (ChatTick >= 5 & !IsGM)
                    {
                        Info.ChatBanned = true;
                        Info.ChatBanExpiryDate = DateTime.Now.AddMinutes(5);
                        ReceiveChat("You have been banned from chatting for 5 minutes.", ChatType.System);
                        return;
                    }

                    ChatTick++;
                }
                else
                    ChatTick = 0;

                ChatTime = Envir.Time + 2000;
            }

            string[] parts;

            message = Envir.FilterMessage(message);

            message = message.Replace("$pos", Functions.PointToString(CurrentLocation));

            if (MyGuild != null && MyGuild.VoteExpire > DateTime.Now)
            {
                if (message.Contains("/yes"))
                {
                    MyGuild.ProVote = MyGuildRank != null && MyGuildRank.Index == 0 ? MyGuild.ProVote + 3 : MyGuild.ProVote + 1;

                    if (MyGuildRank != null && MyGuildRank.Index == 0)
                        MyGuild.SendMessage($"[Leader]{Name} has voted for war, Pro points: {MyGuild.ProVote}");
                    else
                        MyGuild.SendMessage($"{Name} has voted for war, Pro points: {MyGuild.ProVote}");
                    return;
                }

                if (message.Contains("/no"))
                {
                    MyGuild.ConVote = MyGuildRank != null && MyGuildRank.Index == 0 ? MyGuild.ConVote + 3 : MyGuild.ConVote + 1;

                    if (MyGuildRank != null && MyGuildRank.Index == 0)
                        MyGuild.SendMessage($"[Leader]{Name} has voted againt war, Con points: {MyGuild.ConVote}");
                    else
                        MyGuild.SendMessage($"{Name} has voted againt war, Con points: {MyGuild.ConVote}");
                    return;
                }
            }

            Packet p;
            if (message.StartsWith("/"))
            {
                //Private Message
                message = message.Remove(0, 1);
                parts = message.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                if (parts.Length == 0) return;

                PlayerObject player = Envir.GetPlayer(parts[0]);

                if (player == null)
                {
                    IntelligentCreatureObject creature = GetCreatureByName(parts[0]);
                    if (creature != null)
                    {
                        creature.ReceiveChat(message.Remove(0, parts[0].Length), ChatType.WhisperIn);
                        return;
                    }
                    ReceiveChat(string.Format("Could not find {0}.", parts[0]), ChatType.System);
                    return;
                }

                if (player.Info.Friends.Any(e => e.Info == Info && e.Blocked))
                {
                    ReceiveChat("Player is not accepting your messages.", ChatType.System);
                    return;
                }

                if (Info.Friends.Any(e => e.Info == player.Info && e.Blocked))
                {
                    ReceiveChat("Cannot message player whilst they are on your blacklist.", ChatType.System);
                    return;
                }

                message = ProcessChatItems(message, new List<PlayerObject> { player }, linkedItems);

                ReceiveChat(string.Format("/{0}", message), ChatType.WhisperOut);
                player.ReceiveChat(string.Format("{0}=>{1}", Name, message.Remove(0, parts[0].Length)), ChatType.WhisperIn);
            }
            else if (message.StartsWith("!!"))
            {
                if (GroupMembers == null) return;
                //Group
                message = String.Format("{0}:{1}", Name, message.Remove(0, 2));

                message = ProcessChatItems(message, GroupMembers, linkedItems);

                p = new S.ObjectChat { ObjectID = ObjectID, Text = message, Type = ChatType.Group };

                for (int i = 0; i < GroupMembers.Count; i++)
                    GroupMembers[i].Enqueue(p);
            }
            else if (message.StartsWith("!~"))
            {
                if (MyGuild == null) return;

                //Guild
                message = message.Remove(0, 2);

                message = ProcessChatItems(message, MyGuild.GetOnlinePlayers(), linkedItems);

                MyGuild.SendMessage(String.Format("{0}: {1}", Name, message));

            }
            else if (message.StartsWith("!#"))
            {
                //Mentor Message
                message = message.Remove(0, 2);
                parts = message.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                if (parts.Length == 0) return;

                if (Info.Mentor == 0) return;

                CharacterInfo Mentor = Envir.GetCharacterInfo(Info.Mentor);
                PlayerObject player = Envir.GetPlayer(Mentor.Name);

                if (player == null)
                {
                    ReceiveChat(string.Format("{0} isn't online.", Mentor.Name), ChatType.System);
                    return;
                }

                message = ProcessChatItems(message, new List<PlayerObject> { player }, linkedItems);

                ReceiveChat(string.Format("{0}: {1}", Name, message), ChatType.Mentor);
                player.ReceiveChat(string.Format("{0}: {1}", Name, message), ChatType.Mentor);
            }
            else if (message.StartsWith("!"))
            {
                //Shout
                if (Envir.Time < ShoutTime)
                {
                    ReceiveChat(string.Format("You cannot shout for another {0} seconds.", Math.Ceiling((ShoutTime - Envir.Time) / 1000D)), ChatType.System);
                    return;
                }
                if (Level < 8 && (!HasMapShout && !HasServerShout))
                {
                    ReceiveChat("You need to be level 8 before you can shout.", ChatType.System);
                    return;
                }

                ShoutTime = Envir.Time + 10000;
                message = String.Format("(!){0}:{1}", Name, message.Remove(0, 1));

                if (HasMapShout)
                {
                    message = ProcessChatItems(message, CurrentMap.Players, linkedItems);

                    p = new S.Chat { Message = message, Type = ChatType.Shout2 };
                    HasMapShout = false;

                    for (int i = 0; i < CurrentMap.Players.Count; i++)
                    {
                        CurrentMap.Players[i].Enqueue(p);
                    }
                    return;
                }
                else if (HasServerShout)
                {
                    message = ProcessChatItems(message, Envir.Players, linkedItems);

                    p = new S.Chat { Message = message, Type = ChatType.Shout3 };
                    HasServerShout = false;

                    for (int i = 0; i < Envir.Players.Count; i++)
                    {
                        Envir.Players[i].Enqueue(p);
                    }
                    return;
                }
                else
                {
                    List<PlayerObject> playersInRange = new List<PlayerObject>();

                    for (int i = 0; i < CurrentMap.Players.Count; i++)
                    {
                        if (!Functions.InRange(CurrentLocation, CurrentMap.Players[i].CurrentLocation, Globals.DataRange * 2)) continue;

                        playersInRange.Add(CurrentMap.Players[i]);
                    }

                    message = ProcessChatItems(message, playersInRange, linkedItems);

                    p = new S.Chat { Message = message, Type = ChatType.Shout };

                    for (int i = 0; i < playersInRange.Count; i++)
                    {
                        playersInRange[i].Enqueue(p);
                    }

                }

            }
            else if (message.StartsWith(":)"))
            {
                //Relationship Message
                message = message.Remove(0, 2);
                parts = message.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                if (parts.Length == 0) return;

                if (Info.Married == 0) return;

                CharacterInfo Lover = Envir.GetCharacterInfo(Info.Married);
                PlayerObject player = Envir.GetPlayer(Lover.Name);
            
                if (player == null)
                {
                    ReceiveChat(string.Format("{0} isn't online.", Lover.Name), ChatType.System);
                    return;
                }

                message = ProcessChatItems(message, new List<PlayerObject> { player }, linkedItems);

                ReceiveChat(string.Format("{0}: {1}", Name, message), ChatType.Relationship);
                player.ReceiveChat(string.Format("{0}: {1}", Name, message), ChatType.Relationship);
            }
            else if (message.StartsWith("@!"))
            {
                if (!IsGM) return;

                message = String.Format("(*){0}:{1}", Name, message.Remove(0, 2));

                message = ProcessChatItems(message, Envir.Players, linkedItems);

                p = new S.Chat { Message = message, Type = ChatType.Announcement };

                Envir.Broadcast(p);
            }
            else if (message.StartsWith("@"))
            {
                
                //Command
                message = message.Remove(0, 1);
                parts = message.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                if (parts.Length == 0) return;

                PlayerObject player;
                CharacterInfo data;
                String hintstring;
                UserItem item;

                switch (parts[0].ToUpper())
                {
                    case "LOGIN":
                        GMLogin = true;
                        ReceiveChat("Please type the GM Password", ChatType.Hint);
                        return;

                    case "KILL":
                        if (!IsGM) return;

                        if (parts.Length >= 2)
                        {
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Could not find {0}", parts[0]), ChatType.System);
                                return;
                            }
                            if (!player.GMNeverDie) player.Die();
                        }
                        else
                        {
                            if (!CurrentMap.ValidPoint(Front)) return;

                            Cell cell = CurrentMap.GetCell(Front);

                            if (cell == null || cell.Objects == null) return;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];

                                switch (ob.Race)
                                {
                                    case ObjectType.Player:
                                    case ObjectType.Monster:
                                        if (ob.Dead) continue;
                                        ob.EXPOwner = this;
                                        ob.ExpireTime = Envir.Time + MonsterObject.EXPOwnerDelay;
                                        ob.Die();
                                        break;
                                    default:
                                        continue;
                                }
                            }
                        }
                        return;

                    case "RESTORE":
                        if (!IsGM || parts.Length < 2) return;

                        data = Envir.GetCharacterInfo(parts[1]);

                        if (data == null)
                        {
                            ReceiveChat(string.Format("Player {0} was not found", parts[1]), ChatType.System);
                            return;
                        }

                        if (!data.Deleted) return;
                        data.Deleted = false;

                        ReceiveChat(string.Format("Player {0} has been restored by", data.Name), ChatType.System);
                        MessageQueue.Enqueue(string.Format("Player {0} has been restored by {1}", data.Name, Name));

                        break;

                    case "CHANGEGENDER":
                        if (!IsGM && !Settings.TestServer) return;

                        data = parts.Length < 2 ? Info : Envir.GetCharacterInfo(parts[1]);

                        if (data == null) return;

                        switch (data.Gender)
                        {
                            case MirGender.Male:
                                data.Gender = MirGender.Female;
                                break;
                            case MirGender.Female:
                                data.Gender = MirGender.Male;
                                break;
                        }

                        ReceiveChat(string.Format("Player {0} has been changed to {1}", data.Name, data.Gender), ChatType.System);
                        MessageQueue.Enqueue(string.Format("Player {0} has been changed to {1} by {2}", data.Name, data.Gender, Name));

                        if (data.Player != null)
                            data.Player.Connection.LogOut();

                        break;

                    case "LEVEL":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        ushort level;
                        ushort old;
                        if (parts.Length >= 3)
                        {
                            if (!IsGM) return;

                            if (ushort.TryParse(parts[2], out level))
                            {
                                if (level == 0) return;
                                player = Envir.GetPlayer(parts[1]);
                                if (player == null) return;
                                old = player.Level;
                                player.Level = level;
                                player.LevelUp();

                                ReceiveChat(string.Format("Player {0} has been Leveled {1} -> {2}.", player.Name, old, player.Level), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Leveled {1} -> {2} by {3}", player.Name, old, player.Level, Name));
                                return;
                            }
                        }
                        else
                        {
                            if (parts[1] == "-1")
                            {
                                parts[1] = ushort.MaxValue.ToString();
                            }

                            if (ushort.TryParse(parts[1], out level))
                            {
                                if (level == 0) return;
                                old = Level;
                                Level = level;
                                LevelUp();

                                ReceiveChat(string.Format("{0} {1} -> {2}.", GameLanguage.LevelUp, old, Level), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Leveled {1} -> {2} by {3}", Name, old, Level, Name));
                                return;
                            }
                        }

                        ReceiveChat("Could not level player", ChatType.System);
                        break;

                    case "REBORN":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        ushort reborn;
                        ushort oldreborn;
                        if (parts.Length >= 3)
                        {
                            if (!IsGM) return;

                            if (ushort.TryParse(parts[2], out reborn))
                            {
                                //if (reborn == 0) return;
                                player = Envir.GetPlayer(parts[1]);
                                if (player == null) return;
                                oldreborn = player.Reborn;
                                player.Reborn = reborn;
                                player.RebornUp();
                                //player.Enqueue(new S.RebornChanged { Reborn = player.Reborn });
                                player.UpdateRebornBuff();

                                ReceiveChat(string.Format("{0} {1} -> {2}.", GameLanguage.RebornUp, oldreborn, player.Reborn), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Reborned {1} -> {2} by {3}", player.Name, oldreborn, player.Reborn, Name));
                                return;
                            }
                        }
                        else
                        {
                            if (ushort.TryParse(parts[1], out reborn))
                            {
                                //if (reborn == 0) return;
                                oldreborn = Reborn;
                                Reborn = reborn;
                                RebornUp();
                                //Enqueue(new S.RebornChanged { Reborn = Reborn });
                                UpdateRebornBuff();

                                ReceiveChat(string.Format("{0} {1} -> {2}.", GameLanguage.RebornUp, oldreborn, Reborn), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Reborned {1} -> {2} by {3}", Name, oldreborn, Reborn, Name));
                                return;
                            }
                        }

                        ReceiveChat("Could not reborn player", ChatType.System);
                        break;

                    case "INSTANCESTAGE":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        ushort instance;
                        ushort oldinstance;
                        if (parts.Length >= 3)
                        {
                            if (!IsGM) return;

                            if (ushort.TryParse(parts[2], out instance))
                            {
                                player = Envir.GetPlayer(parts[1]);
                                if (player == null) return;
                                oldinstance = player.InstanceStage;
                                player.InstanceStage = instance;
                                player.InstanceStageUp();
                                player.UpdateInstanceStageBuff();

                                ReceiveChat(string.Format("{0} {1} -> {2}.", GameLanguage.InstanceStageUp, oldinstance, player.InstanceStage), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Reborned {1} -> {2} by {3}", player.Name, oldinstance, player.InstanceStage, Name));
                                return;
                            }
                        }
                        else
                        {
                            if (ushort.TryParse(parts[1], out instance))
                            {
                                oldinstance = InstanceStage;
                                InstanceStage = instance;
                                InstanceStageUp();
                                UpdateInstanceStageBuff();

                                ReceiveChat(string.Format("{0} {1} -> {2}.", GameLanguage.RebornUp, oldinstance, InstanceStage), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Reborned {1} -> {2} by {3}", Name, oldinstance, InstanceStage, Name));
                                return;
                            }
                        }

                        ReceiveChat("Could not reborn player", ChatType.System);
                        break;

                    case "CHALLENGESTAGE":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        ushort challenge;
                        ushort oldchallenge;
                        if (parts.Length >= 3)
                        {
                            if (!IsGM) return;

                            if (ushort.TryParse(parts[2], out challenge))
                            {
                                player = Envir.GetPlayer(parts[1]);
                                if (player == null) return;
                                oldchallenge = player.ChallengeStage;
                                player.ChallengeStage = challenge;
                                player.ChallengeStageUp();
                                player.UpdateChallengeStageBuff();

                                ReceiveChat(string.Format("{0} {1} -> {2}.", GameLanguage.ChallengeStageUp, oldchallenge, player.ChallengeStage), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Reborned {1} -> {2} by {3}", player.Name, oldchallenge, player.ChallengeStage, Name));
                                return;
                            }
                        }
                        else
                        {
                            if (ushort.TryParse(parts[1], out challenge))
                            {
                                oldchallenge = ChallengeStage;
                                ChallengeStage = challenge;
                                ChallengeStageUp();
                                UpdateChallengeStageBuff();

                                ReceiveChat(string.Format("{0} {1} -> {2}.", GameLanguage.ChallengeStageUp, oldchallenge, ChallengeStage), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player {0} has been Reborned {1} -> {2} by {3}", Name, oldchallenge, ChallengeStage, Name));
                                return;
                            }
                        }

                        ReceiveChat("Could not reborn player", ChatType.System);
                        break;

                    case "MAKE":
                        {
                            if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                            ItemInfo iInfo = Envir.GetItemInfo(parts[1]);
                            if (iInfo == null) return;

                            ushort itemCount = 1;
                            if (parts.Length >= 3 && !ushort.TryParse(parts[2], out itemCount))
                                itemCount = 1;

                            var tempCount = itemCount;

                            while (itemCount > 0)
                            {
                                if (iInfo.StackSize >= itemCount)
                                {
                                    item = Envir.CreateDropItem(iInfo);
                                    item.Count = itemCount;

                                    if (CanGainItem(item, false)) GainItem(item);

                                    return;
                                }
                                item = Envir.CreateDropItem(iInfo);
                                item.Count = iInfo.StackSize;
                                itemCount -= iInfo.StackSize;

                                if (!CanGainItem(item, false)) return;
                                GainItem(item);
                            }

                            ReceiveChat(string.Format("{0} x{1} has been created.", iInfo.FriendlyName, tempCount), ChatType.System);
                            MessageQueue.Enqueue(string.Format("Player {0} has attempted to Create {1} x{2}", Name, iInfo.Name, tempCount));
                        }
                        break;
                    case "CLEARBUFFS":
                        foreach (var buff in Buffs)
                        {
                            buff.FlagForRemoval = true;
                            buff.ExpireTime = 0;
                        }
                        break;
                    case "GIVE": //Added by Valhalla
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 3) return;


                        player = Envir.GetPlayer(parts[1]);
                        if (player == null)
                        {
                            ReceiveChat(string.Format("Player " + "'{0}'" + " Could not be found", parts[1]), ChatType.System);
                            return;
                        };



                        ItemInfo iInfo1 = Envir.GetItemInfo(parts[2]);
                        if (iInfo1 == null) return;


                        ushort count1 = 1;
                        if (parts.Length >= 4 && !ushort.TryParse(parts[3], out count1))
                            count1 = 1;


                        var tempCount1 = count1;


                        while (count1 > 0)
                        {
                            if (iInfo1.StackSize >= count1)
                            {
                                item = Envir.CreateDropItem(iInfo1);
                                item.Count = count1;


                                if (CanGainItem(item, false)) player.GainItem(item);
                                ReceiveChat(string.Format("{1} x{2} has been given to '{0}'", player.Name, iInfo1.Name, tempCount1), ChatType.System);
                                MessageQueue.Enqueue(string.Format("Player '{0}' has given {1} x{2} to {3}", Name, iInfo1.Name, tempCount1, player.Name));


                                return;
                            }
                            item = Envir.CreateDropItem(iInfo1);
                            item.Count = iInfo1.StackSize;
                            count1 -= iInfo1.StackSize;


                            if (!CanGainItem(item, false)) return;
                            player.GainItem(item);
                            ReceiveChat(string.Format("{1} x{2} has been given to '{0}'", player.Name, iInfo1.Name, tempCount1), ChatType.System);
                            MessageQueue.Enqueue(string.Format("Player '{0}' has given {1} x{2} to {3}", Name, iInfo1.Name, tempCount1, player.Name));
                        }
                        break;

                    case "CLEARBAG":
                        if (!IsGM && !Settings.TestServer) return;
                        player = this;

                        if (parts.Length >= 2)
                            player = Envir.GetPlayer(parts[1]);

                        if (player == null) return;
                        for (int i = 0; i < player.Info.Inventory.Length; i++)
                        {
                            item = player.Info.Inventory[i];
                            if (item == null) continue;

                            player.Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                            player.Info.Inventory[i] = null;
                        }
                        player.RefreshStats();
                        break;

                    case "SUPERMAN":
                        if (!IsGM && !Settings.TestServer) return;

                        GMNeverDie = !GMNeverDie;

                        hintstring = GMNeverDie ? "Invincible Mode." : "Normal Mode.";
                        ReceiveChat(hintstring, ChatType.Hint);
                        UpdateGMBuff();
                        break;

                    case "GAMEMASTER":
                        if (!IsGM && !Settings.TestServer) return;

                        GMGameMaster = !GMGameMaster;

                        hintstring = GMGameMaster ? "GameMaster Mode." : "Normal Mode.";
                        ReceiveChat(hintstring, ChatType.Hint);
                        UpdateGMBuff();
                        break;

                    case "OBSERVER":
                        if (!IsGM) return;
                        Observer = !Observer;

                        hintstring = Observer ? "Observer Mode." : "Normal Mode.";
                        ReceiveChat(hintstring, ChatType.Hint);
                        UpdateGMBuff();
                        break;
                    case "ALLOWGUILD":
                        EnableGuildInvite = !EnableGuildInvite;
                        hintstring = EnableGuildInvite ? "Guild invites enabled." : "Guild invites disabled.";
                        ReceiveChat(hintstring, ChatType.Hint);
                        break;
                    case "RECALL":
                        if (!IsGM) return;

                        if (parts.Length < 2) return;
                        player = Envir.GetPlayer(parts[1]);

                        if (player == null) return;

                        player.Teleport(CurrentMap, Front);
                        break;
                    case "ENABLEGROUPRECALL":
                        EnableGroupRecall = !EnableGroupRecall;
                        hintstring = EnableGroupRecall ? "Group Recall Enabled." : "Group Recall Disabled.";
                        ReceiveChat(hintstring, ChatType.Hint);
                        break;

                    case "GROUPRECALL":
                        if (GroupMembers == null || GroupMembers[0] != this || Dead)
                            return;

                        if (CurrentMap.Info.NoRecall)
                        {
                            ReceiveChat("You cannot recall people on this map", ChatType.System);
                            return;
                        }

                        if (Envir.Time < LastRecallTime)
                        {
                            ReceiveChat(string.Format("You cannot recall for another {0} seconds", (LastRecallTime - Envir.Time) / 1000), ChatType.System);
                            return;
                        }

                        if (ItemSets.Any(set => set.Set == ItemSet.Recall && set.SetComplete))
                        {
                            LastRecallTime = Envir.Time + 180000;
                            for (var i = 1; i < GroupMembers.Count(); i++)
                            {
                                if (GroupMembers[i].EnableGroupRecall)
                                    GroupMembers[i].Teleport(CurrentMap, CurrentLocation);
                                else
                                    GroupMembers[i].ReceiveChat("A recall was attempted without your permission",
                                        ChatType.System);
                            }
                        }
                        break;
                    case "RECALLMEMBER":
                        if (GroupMembers == null || GroupMembers[0] != this)
                        {
                            ReceiveChat("You are not a group leader.", ChatType.System);
                            return;
                        }

                        if (Dead)
                        {
                            ReceiveChat("You cannot recall when you are dead.", ChatType.System);
                            return;
                        }

                        if (CurrentMap.Info.NoRecall)
                        {
                            ReceiveChat("You cannot recall people on this map", ChatType.System);
                            return;
                        }

                        if (Envir.Time < LastRecallTime)
                        {
                            ReceiveChat(string.Format("You cannot recall for another {0} seconds", (LastRecallTime - Envir.Time) / 1000), ChatType.System);
                            return;
                        }
                        if (ItemSets.Any(set => set.Set == ItemSet.Recall && set.SetComplete))
                        {
                            if (parts.Length < 2) return;
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null || !IsMember(player) || this == player)
                            {
                                ReceiveChat((string.Format("Player {0} could not be found", parts[1])), ChatType.System);
                                return;
                            }
                            if (!player.EnableGroupRecall)
                            {
                                player.ReceiveChat("A recall was attempted without your permission",
                                        ChatType.System);
                                ReceiveChat((string.Format("{0} is blocking grouprecall", player.Name)), ChatType.System);
                                return;
                            }
                            LastRecallTime = Envir.Time + 60000;

                            if (!player.Teleport(CurrentMap, Front))
                                player.Teleport(CurrentMap, CurrentLocation);
                        }
                        else
                        {
                            ReceiveChat("You cannot recall without a recallset.", ChatType.System);
                            return;
                        }
                        break;

                    case "RECALLLOVER":
                        if (Info.Married == 0)
                        {
                            ReceiveChat("You're not married.", ChatType.System);
                            return;
                        }

                        if (Dead)
                        {
                            ReceiveChat("You can't recall when you are dead.", ChatType.System);
                            return;
                        }

                        if (CurrentMap.Info.NoRecall)
                        {
                            ReceiveChat("You cannot recall people on this map", ChatType.System);
                            return;
                        }

                        if (Info.Equipment[(int)EquipmentSlot.RingL] == null)
                        {
                            ReceiveChat("You need to be wearing a Wedding Ring for recall.", ChatType.System);
                            return;
                        }


                        if (Info.Equipment[(int)EquipmentSlot.RingL].WeddingRing == Info.Married)
                        {
                            CharacterInfo Lover = Envir.GetCharacterInfo(Info.Married);

                            if (Lover == null) return;

                            player = Envir.GetPlayer(Lover.Name);

                            if (!Settings.WeddingRingRecall)
                            {
                                ReceiveChat($"Teleportation via Wedding Ring is disabled.", ChatType.System);
                                return;
                            }

                            if (player == null)
                            {
                                ReceiveChat((string.Format("{0} is not online.", Lover.Name)), ChatType.System);
                                return;
                            }

                            if (player.Dead)
                            {
                                ReceiveChat("You can't recall a dead player.", ChatType.System);
                                return;
                            }

                            if (player.Info.Equipment[(int)EquipmentSlot.RingL] == null)
                            {
                                player.ReceiveChat((string.Format("You need to wear a Wedding Ring for recall.", Lover.Name)), ChatType.System);
                                ReceiveChat((string.Format("{0} Isn't wearing a Wedding Ring.", Lover.Name)), ChatType.System);
                                return;
                            }

                            if (player.Info.Equipment[(int)EquipmentSlot.RingL].WeddingRing != player.Info.Married)
                            {
                                player.ReceiveChat((string.Format("You need to wear a Wedding Ring on your left finger for recall.", Lover.Name)), ChatType.System);
                                ReceiveChat((string.Format("{0} Isn't wearing a Wedding Ring.", Lover.Name)), ChatType.System);
                                return;
                            }

                            if (!player.AllowLoverRecall)
                            {
                                player.ReceiveChat("A recall was attempted without your permission",
                                        ChatType.System);
                                ReceiveChat((string.Format("{0} is blocking Lover Recall.", player.Name)), ChatType.System);
                                return;
                            }

                            if ((Envir.Time < LastRecallTime) && (Envir.Time < player.LastRecallTime))
                            {
                                ReceiveChat(string.Format("You cannot recall for another {0} seconds", (LastRecallTime - Envir.Time) / 1000), ChatType.System);
                                return;
                            }

                            LastRecallTime = Envir.Time + 60000;
                            player.LastRecallTime = Envir.Time + 60000;

                            if (!player.Teleport(CurrentMap, Front))
                                player.Teleport(CurrentMap, CurrentLocation);
                        }
                        else
                        {
                            ReceiveChat("You cannot recall your lover without wearing a wedding ring", ChatType.System);
                            return;
                        }
                        break;
                    case "TIME":
                        ReceiveChat(string.Format("The time is : {0}", DateTime.Now.ToString("hh:mm tt")), ChatType.System);
                        break;

                    case "ROLL":
                        int diceNum = Envir.Random.Next(5) + 1;

                        if (GroupMembers == null) { return; }

                        for (int i = 0; i < GroupMembers.Count; i++)
                        {
                            PlayerObject playerSend = GroupMembers[i];
                            playerSend.ReceiveChat(string.Format("{0} has rolled a {1}", Name, diceNum), ChatType.Group);
                        }
                        break;

                    case "MAP":
                        var mapName = CurrentMap.Info.FileName;
                        var mapTitle = CurrentMap.Info.Title;
                        ReceiveChat((string.Format("You are currently in {0}. Map ID: {1}", mapTitle, mapName)), ChatType.System);
                        break;

                    case "SAVEPLAYER":
                        if (!IsGM) return;

                        if (parts.Length < 2) return;

                        CharacterInfo tempInfo = null;

                        System.IO.Directory.CreateDirectory("Character Backups");

                        for (int i = 0; i < Envir.AccountList.Count; i++)
                        {
                            for (int j = 0; j < Envir.AccountList[i].Characters.Count; j++)
                            {
                                if (String.Compare(Envir.AccountList[i].Characters[j].Name, parts[1], StringComparison.OrdinalIgnoreCase) != 0) continue;

                                tempInfo = Envir.AccountList[i].Characters[j];
                                break;
                            }
                        }
                        
                        using (System.IO.FileStream stream = System.IO.File.Create(string.Format("Character Backups/{0}", tempInfo.Name)))
                        {
                            using (System.IO.BinaryWriter writer = new System.IO.BinaryWriter(stream))
                            {
                                tempInfo.Save(writer);
                            }
                        }

                        break;

                    case "LOADPLAYER":
                        if (!IsGM) return;

                        if (parts.Length < 2) return;

                        tempInfo = null;

                        System.IO.Directory.CreateDirectory("Character Backups");

                        for (int i = 0; i < Envir.AccountList.Count; i++)
                        {
                            for (int j = 0; j < Envir.AccountList[i].Characters.Count; j++)
                            {
                                if (String.Compare(Envir.AccountList[i].Characters[j].Name, parts[1], StringComparison.OrdinalIgnoreCase) != 0) continue;

                                tempInfo = Envir.AccountList[i].Characters[j];

                                using (System.IO.FileStream stream = System.IO.File.OpenRead(string.Format("Character Backups/{0}", tempInfo.Name)))
                                {
                                    using (System.IO.BinaryReader reader = new System.IO.BinaryReader(stream))
                                    {
                                        CharacterInfo tt = new CharacterInfo(reader);

                                        if(Envir.AccountList[i].Characters[j].Index != tt.Index)
                                        {
                                            ReceiveChat("Player name was matched however IDs did not. Likely due to player being recreated. Player not restored", ChatType.System);
                                            return;
                                        }

                                        Envir.AccountList[i].Characters[j] = tt;
                                    }
                                }
                            }
                        }
                        
                        Envir.BeginSaveAccounts();
                    break;

                    //ATTRIBUTES SYSTEM
                    case "ADDATTRIBUTEPOINT":
                        {
                            if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                            int tempAttr = 0;

                            player = this;

                            if (parts.Length > 2)
                            {
                                if (!int.TryParse(parts[2], out tempAttr)) return;
                                player = Envir.GetPlayer(parts[1]);

                                if (player == null)
                                {
                                    ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                    return;
                                }
                            }

                            else if (!int.TryParse(parts[1], out tempAttr)) return;

                            if (tempAttr + player.Info.CurrentAttributePoints >= int.MaxValue)
                                tempAttr = int.MaxValue - player.Info.CurrentAttributePoints;

                            player.GainAttributePoint(tempAttr);

                            MessageQueue.Enqueue(string.Format("Player {0} has been given {1} Attribute Points", player.Name, tempAttr));
                            break;
                        }

                    case "MOVE":
                        if (!IsGM && !SpecialMode.HasFlag(SpecialItemMode.Teleport) && !Settings.TestServer) return;
                        if (!IsGM && CurrentMap.Info.NoPosition)
                        {
                            ReceiveChat(("You cannot position move on this map"), ChatType.System);
                            return;
                        }
                        if (Envir.Time < LastTeleportTime)
                        {
                            ReceiveChat(string.Format("You cannot teleport for another {0} seconds", (LastTeleportTime - Envir.Time) / 1000), ChatType.System);
                            return;
                        }

                        int x, y;

                        if (parts.Length <= 2 || !int.TryParse(parts[1], out x) || !int.TryParse(parts[2], out y))
                        {
                            if (!IsGM)
                                LastTeleportTime = Envir.Time + 10000;
                            TeleportRandom(200, 0);
                            return;
                        }
                        if (!IsGM)
                            LastTeleportTime = Envir.Time + 10000;
                        Teleport(CurrentMap, new Point(x, y));
                        break;

                    case "MAPMOVE":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;
                        var instanceID = 1; x = 0; y = 0;

                        if (parts.Length == 3 || parts.Length == 5)
                            int.TryParse(parts[2], out instanceID);

                        if (instanceID < 1) instanceID = 1;

                        var map = Envir.GetMapByNameAndInstance(parts[1], instanceID);
                        if (map == null)
                        {
                            ReceiveChat((string.Format("Map {0}:[{1}] could not be found", parts[1], instanceID)), ChatType.System);
                            return;
                        }

                        if (parts.Length == 4 || parts.Length == 5)
                        {
                            int.TryParse(parts[parts.Length - 2], out x);
                            int.TryParse(parts[parts.Length - 1], out y);
                        }

                        switch (parts.Length)
                        {
                            case 2:
                                ReceiveChat(TeleportRandom(200, 0, map) ? (string.Format("Moved to Map {0}", map.Info.FileName)) :
                                    (string.Format("Failed movement to Map {0}", map.Info.FileName)), ChatType.System);
                                break;
                            case 3:
                                ReceiveChat(TeleportRandom(200, 0, map) ? (string.Format("Moved to Map {0}:[{1}]", map.Info.FileName, instanceID)) :
                                    (string.Format("Failed movement to Map {0}:[{1}]", map.Info.FileName, instanceID)), ChatType.System);
                                break;
                            case 4:
                                ReceiveChat(Teleport(map, new Point(x, y)) ? (string.Format("Moved to Map {0} at {1}:{2}", map.Info.FileName, x, y)) :
                                    (string.Format("Failed movement to Map {0} at {1}:{2}", map.Info.FileName, x, y)), ChatType.System);
                                break;
                            case 5:
                                ReceiveChat(Teleport(map, new Point(x, y)) ? (string.Format("Moved to Map {0}:[{1}] at {2}:{3}", map.Info.FileName, instanceID, x, y)) :
                                    (string.Format("Failed movement to Map {0}:[{1}] at {2}:{3}", map.Info.FileName, instanceID, x, y)), ChatType.System);
                                break;
                        }
                        break;

                    case "GOTO":
                        if (!IsGM) return;

                        if (parts.Length < 2) return;
                        player = Envir.GetPlayer(parts[1]);

                        if (player == null) return;

                        Teleport(player.CurrentMap, player.CurrentLocation);
                        break;

                    case "MOB":
                        if (!IsGM && !Settings.TestServer) return;
                        if (parts.Length < 2)
                        {
                            ReceiveChat("Not enough parameters to spawn monster", ChatType.System);
                            return;
                        }

                        MonsterInfo mInfo = Envir.GetMonsterInfo(parts[1]);
                        if (mInfo == null)
                        {
                            ReceiveChat((string.Format("Monster {0} does not exist", parts[1])), ChatType.System);
                            return;
                        }

                        uint count = 1;
                        if (parts.Length >= 3 && IsGM)
                            if (!uint.TryParse(parts[2], out count)) count = 1;

                        for (int i = 0; i < count; i++)
                        {
                            MonsterObject monster = MonsterObject.GetMonster(mInfo);
                            if (monster == null) return;
                            monster.Spawn(CurrentMap, Front);
                        }

                        ReceiveChat((string.Format("Monster {0} x{1} has been spawned.", mInfo.Name, count)), ChatType.System);
                        break;

                    case "RECALLMOB":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        MonsterInfo mInfo2 = Envir.GetMonsterInfo(parts[1]);
                        if (mInfo2 == null) return;

                        count = 1;
                        byte petlevel = 0;

                        if (parts.Length > 2)
                            if (!uint.TryParse(parts[2], out count) || count > 50) count = 1;

                        if (parts.Length > 3)
                            if (!byte.TryParse(parts[3], out petlevel) || petlevel > 7) petlevel = 0;

                        if (!IsGM && Pets.Count > 4) return;

                        for (int i = 0; i < count; i++)
                        {
                            MonsterObject monster = MonsterObject.GetMonster(mInfo2);
                            if (monster == null) return;
                            monster.PetLevel = petlevel;
                            monster.Master = this;
                            monster.MaxPetLevel = 7;
                            monster.Direction = Direction;
                            monster.ActionTime = Envir.Time + 1000;
                            monster.Spawn(CurrentMap, Front);
                            Pets.Add(monster);
                        }

                        ReceiveChat((string.Format("Pet {0} x{1} has been recalled.", mInfo2.Name, count)), ChatType.System);
                        break;

                    case "RELOADDROPS":
                        if (!IsGM) return;
                        Envir.ReloadDrops();
                        ReceiveChat("Drops Reloaded.", ChatType.Hint);
                        break;

                    case "RELOADNPCS":
                        if (!IsGM) return;

                        Envir.ReloadNPCs();

                        ReceiveChat("NPC Scripts Reloaded.", ChatType.Hint);
                        break;

                    case "SETNAMECOLOR":
                        if (!IsGM) return;
                        if (parts.Length < 1) return;

                        player = this;
                        if (parts.Length > 2)
                        {
                            Color c;
                            c = Color.FromName(parts[2]);
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                return;
                            }
                            else
                            {
                                player.TempColour = c;
                                player.RefreshNameColour();
                                return;
                            }
                        }
                        else
                        {
                            Color c = Color.FromName(parts[1]);
                            TempColour = c;
                            RefreshNameColour();
                        }
                        break;

                    case "GIVEGOLD":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        player = this;

                        if (parts.Length > 2)
                        {
                            if (!IsGM) return;

                            if (!uint.TryParse(parts[2], out count)) return;
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                return;
                            }
                        }

                        else if (!uint.TryParse(parts[1], out count)) return;

                        if (count + player.Account.Gold >= uint.MaxValue)
                            count = uint.MaxValue - player.Account.Gold;

                        player.GainGold(count);
                        MessageQueue.Enqueue(string.Format("Player {0} has been given {1} gold", player.Name, count));
                        break;

                    case "GIVEPEARLS":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        player = this;

                        if (parts.Length > 2)
                        {
                            if (!IsGM) return;

                            if (!uint.TryParse(parts[2], out count)) return;
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                return;
                            }
                        }

                        else if (!uint.TryParse(parts[1], out count)) return;

                        if (count + player.Info.PearlCount >= int.MaxValue)
                            count = (uint)(int.MaxValue - player.Info.PearlCount);

                        player.IntelligentCreatureGainPearls((int)count);
                        if (count > 1)
                            MessageQueue.Enqueue(string.Format("Player {0} has been given {1} pearls", player.Name, count));
                        else
                            MessageQueue.Enqueue(string.Format("Player {0} has been given {1} pearl", player.Name, count));
                        break;
                    case "GIVECREDIT":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        player = this;

                        if (parts.Length > 2)
                        {
                            if (!IsGM) return;

                            if (!uint.TryParse(parts[2], out count)) return;
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                return;
                            }
                        }

                        else if (!uint.TryParse(parts[1], out count)) return;

                        if (count + player.Account.Credit >= uint.MaxValue)
                            count = uint.MaxValue - player.Account.Credit;

                        player.GainCredit(count);
                        MessageQueue.Enqueue(string.Format("Player {0} has been given {1} credit", player.Name, count));
                        break;
                    case "GIVEHUNTPOINTS":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        player = this;

                        uint counth;
                        if (parts.Length > 2)
                        {
                            if (!IsGM) return;

                            if (!uint.TryParse(parts[2], out counth)) return;
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                return;
                            }
                        }

                        else if (!uint.TryParse(parts[1], out counth)) return;

                        if (counth + player.Account.HuntPoints >= uint.MaxValue)
                            counth = uint.MaxValue - player.Account.HuntPoints;

                        player.GainHuntPoints(counth);
                        MessageQueue.Enqueue(string.Format("Player {0} has been given {1} HuntPoints", player.Name, counth));
                        break;
                    case "GIVESKILL":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 3) return;

                        byte spellLevel = 0;

                        player = this;
                        Spell skill;

                        if (!Enum.TryParse(parts.Length > 3 ? parts[2] : parts[1], true, out skill)) return;

                        if (skill == Spell.None) return;

                        spellLevel = byte.TryParse(parts.Length > 3 ? parts[3] : parts[2], out spellLevel) ? Math.Min((byte)10, spellLevel) : (byte)0;

                        if (parts.Length > 3)
                        {
                            if (!IsGM) return;

                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                return;
                            }
                        }

                        var magic = new UserMagic(skill) { Level = spellLevel };

                        if (player.Info.Magics.Any(e => e.Spell == skill))
                        {
                            player.Info.Magics.FirstOrDefault(e => e.Spell == skill).Level = spellLevel;
                            player.ReceiveChat(string.Format("Spell {0} changed to level {1}", skill.ToString(), spellLevel), ChatType.Hint);
                            return;
                        }
                        else
                        {
                            player.ReceiveChat(string.Format("You have learned {0} at level {1}", skill.ToString(), spellLevel), ChatType.Hint);

                            if (player != this)
                            {
                                ReceiveChat(string.Format("{0} has learned {1} at level {2}", player.Name, skill.ToString(), spellLevel), ChatType.Hint);
                            }

                            player.Info.Magics.Add(magic);
                        }

                        player.Enqueue(magic.GetInfo());
                        player.RefreshStats();
                        break;

                    case "FIND":
                        if (!IsGM && !SpecialMode.HasFlag(SpecialItemMode.Probe)) return;

                        if (Envir.Time < LastProbeTime)
                        {
                            ReceiveChat(string.Format("You cannot search for another {0} seconds", (LastProbeTime - Envir.Time) / 1000), ChatType.System);
                            return;
                        }

                        if (parts.Length < 2) return;
                        player = Envir.GetPlayer(parts[1]);

                        if (player == null)
                        {
                            ReceiveChat(parts[1] + " is not online", ChatType.System);
                            return;
                        }
                        if (player.CurrentMap == null) return;
                        if (!IsGM)
                            LastProbeTime = Envir.Time + 180000;
                        ReceiveChat((string.Format("{0} is located at {1} ({2},{3})", player.Name, player.CurrentMap.Info.Title, player.CurrentLocation.X, player.CurrentLocation.Y)), ChatType.System);
                        break;

                    case "LEAVEGUILD":
                        if (MyGuild == null) return;
                        if (MyGuildRank == null) return;
                        if(MyGuild.IsAtWar())
                        {
                            ReceiveChat("Cannot leave guild whilst at war.", ChatType.System);
                            return;
                        }

                        if (MyGuild.Conquest != null)
                        {
                            RemoveConquestItems(MyGuild.Conquest.Info.Index);
                        }

                        MyGuild.DeleteMember(this, Name);
                        break;

                    case "CREATEGUILD":

                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        player = parts.Length < 3 ? this : Envir.GetPlayer(parts[1]);

                        if (player == null)
                        {
                            ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                            return;
                        }
                        if (player.MyGuild != null)
                        {
                            ReceiveChat(string.Format("Player {0} is already in a guild.", player.Name), ChatType.System);
                            return;
                        }

                        String gName = parts.Length < 3 ? parts[1] : parts[2];
                        if ((gName.Length < 3) || (gName.Length > 20))
                        {
                            ReceiveChat("Guildname is restricted to 3-20 characters.", ChatType.System);
                            return;
                        }
                        GuildObject guild = Envir.GetGuild(gName);
                        if (guild != null)
                        {
                            ReceiveChat(string.Format("Guild {0} already exists.", gName), ChatType.System);
                            return;
                        }
                        player.CanCreateGuild = true;
                        if (player.CreateGuild(gName))
                            ReceiveChat(string.Format("Successfully created guild {0}", gName), ChatType.System);
                        else
                            ReceiveChat("Failed to create guild", ChatType.System);
                        player.CanCreateGuild = false;
                        break;

                    case "ALLOWTRADE":
                        AllowTrade = !AllowTrade;

                        if (AllowTrade)
                            ReceiveChat("You are now allowing trade", ChatType.System);
                        else
                            ReceiveChat("You are no longer allowing trade", ChatType.System);
                        break;

                    case "WORLDMAP":
                        if (parts.Length < 2) return;

                        if (parts.Length >= 3)
                        {
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found.", parts[1]), ChatType.System);
                                return;
                            }

                            player.CallDefaultNPC(DefaultNPCType.WorldMap, parts[1]);
                            return;
                        }

                        foreach (var pl in Envir.Players)
                        {
                            pl.CallDefaultNPC(DefaultNPCType.WorldMap, parts[1]);
                        }

                        break;

                    case "RIDE":
                        if (MountType > -1)
                        {
                            RidingMount = !RidingMount;

                            RefreshMount();
                        }
                        else
                            ReceiveChat("You haven't a mount...", ChatType.System);

                        ChatTime = 0;
                        break;
                    case "SETFLAG":
                        if (!IsGM && !Settings.TestServer) return;

                        if (parts.Length < 2) return;

                        int tempInt = 0;

                        if (!int.TryParse(parts[1], out tempInt)) return;

                        if (tempInt > Info.Flags.Length - 1) return;

                        Info.Flags[tempInt] = !Info.Flags[tempInt];

                        for (int f = CurrentMap.NPCs.Count - 1; f >= 0; f--)
                        {
                            if (Functions.InRange(CurrentMap.NPCs[f].CurrentLocation, CurrentLocation, Globals.DataRange))
                                CurrentMap.NPCs[f].CheckVisible(this);
                        }

                        break;

                    case "LISTFLAGS":
                        if (!IsGM && !Settings.TestServer) return;

                        for (int i = 0; i < Info.Flags.Length; i++)
                        {
                            if (Info.Flags[i] == false) continue;

                            ReceiveChat("Flag " + i, ChatType.Hint);
                        }
                        break;

                    case "CLEARFLAGS":
                        if (!IsGM && !Settings.TestServer) return;

                        player = parts.Length > 1 && IsGM ? Envir.GetPlayer(parts[1]) : this;

                        if (player == null)
                        {
                            ReceiveChat(parts[1] + " is not online", ChatType.System);
                            return;
                        }

                        for (int i = 0; i < player.Info.Flags.Length; i++)
                        {
                            player.Info.Flags[i] = false;
                        }
                        break;
                    case "CLEARMOB":
                        if (!IsGM) return;

                        if (parts.Length > 1)
                        {
                            map = Envir.GetMapByNameAndInstance(parts[1]);

                            if (map == null) return;

                        }
                        else
                        {
                            map = CurrentMap;
                        }

                        foreach (var cell in map.Cells)
                        {
                            if (cell == null || cell.Objects == null) continue;

                            int obCount = cell.Objects.Count();

                            for (int m = 0; m < obCount; m++)
                            {
                                MapObject ob = cell.Objects[m];

                                if (ob.Race != ObjectType.Monster) continue;
                                if (ob.Dead) continue;
                                ob.Die();
                            }
                        }

                        break;

                    case "CHANGECLASS": //@changeclass [Player] [Class]
                        if (!IsGM && !Settings.TestServer) return;

                        data = parts.Length <= 2 || !IsGM ? Info : Envir.GetCharacterInfo(parts[1]);

                        if (data == null) return;

                        MirClass mirClass;

                        if (!Enum.TryParse(parts[parts.Length - 1], true, out mirClass) || data.Class == mirClass) return;

                        data.Class = mirClass;

                        ReceiveChat(string.Format("Player {0} has been changed to {1}", data.Name, data.Class), ChatType.System);
                        MessageQueue.Enqueue(string.Format("Player {0} has been changed to {1} by {2}", data.Name, data.Class, Name));

                        if (data.Player != null)
                            data.Player.Connection.LogOut();
                        break;

                    case "DIE":
                        LastHitter = null;
                        Die();
                        break;
                    case "HAIR":
                        if (!IsGM && !Settings.TestServer) return;

                        if (parts.Length < 2)
                        {
                            Info.Hair = (byte)Envir.Random.Next(0, 9);
                        }
                        else
                        {
                            byte tempByte = 0;

                            byte.TryParse(parts[1], out tempByte);

                            Info.Hair = tempByte;
                        }
                        break;

                    case "DECO":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        int.TryParse(parts[1], out tempInt);

                        DecoObject decoOb = new DecoObject
                        {
                            Image = tempInt,
                            CurrentMap = CurrentMap,
                            CurrentLocation = CurrentLocation,
                        };

                        CurrentMap.AddObject(decoOb);
                        decoOb.Spawned();

                        Enqueue(decoOb.GetInfo());

                        break;

                    case "ADJUSTPKPOINT":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                        if (parts.Length > 2)
                        {
                            if (!IsGM) return;

                            player = Envir.GetPlayer(parts[1]);

                            if (player == null) return;


                            int.TryParse(parts[2], out tempInt);
                        }
                        else
                        {
                            player = this;
                            int.TryParse(parts[1], out tempInt);
                        }

                        player.PKPoints = tempInt;

                        break;

                    case "AWAKENING":
                        {
                            if ((!IsGM && !Settings.TestServer) || parts.Length < 3) return;

                            ItemType type;

                            if (!Enum.TryParse(parts[1], true, out type)) return;

                            AwakeType awakeType;

                            if (!Enum.TryParse(parts[2], true, out awakeType)) return;

                            foreach (UserItem temp in Info.Equipment)
                            {
                                if (temp == null) continue;

                                ItemInfo realItem = Functions.GetRealItem(temp.Info, Info.Level, Info.Class, Envir.ItemInfoList);

                                if (realItem.Type == type)
                                {
                                    Awake awake = temp.Awake;
                                    bool[] isHit;
                                    int result = awake.UpgradeAwake(temp, awakeType, out isHit);
                                    switch (result)
                                    {
                                        case -1:
                                            ReceiveChat(string.Format("{0} : Condition Error.", temp.FriendlyName), ChatType.System);
                                            break;
                                        case 0:
                                            ReceiveChat(string.Format("{0} : Upgrade Failed.", temp.FriendlyName), ChatType.System);
                                            break;
                                        case 1:
                                            ReceiveChat(string.Format("{0} : AWAKE Level {1}, value {2}~{3}.", temp.FriendlyName, awake.GetAwakeLevel(), awake.GetAwakeValue(), awake.GetAwakeValue()), ChatType.System);
                                            p = new S.RefreshItem { Item = temp };
                                            Enqueue(p);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                        }
                        break;
                    case "REMOVEAWAKENING":
                        {
                            if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;

                            ItemType type;

                            if (!Enum.TryParse(parts[1], true, out type)) return;

                            foreach (UserItem temp in Info.Equipment)
                            {
                                if (temp == null) continue;

                                ItemInfo realItem = Functions.GetRealItem(temp.Info, Info.Level, Info.Class, Envir.ItemInfoList);

                                if (realItem.Type == type)
                                {
                                    Awake awake = temp.Awake;
                                    int result = awake.RemoveAwake();
                                    switch (result)
                                    {
                                        case 0:
                                            ReceiveChat(string.Format("{0} : Remove failed Level 0", temp.FriendlyName), ChatType.System);
                                            break;
                                        case 1:
                                            ReceiveChat(string.Format("{0} : Remove success. Level {1}", temp.FriendlyName, temp.Awake.GetAwakeLevel()), ChatType.System);
                                            p = new S.RefreshItem { Item = temp };
                                            Enqueue(p);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                        }
                        break;

                    case "STARTWAR":
                        if (!IsGM) return;
                        if (parts.Length < 2) return;

                        GuildObject enemyGuild = Envir.GetGuild(parts[1]);

                        if (MyGuild == null)
                        {
                            ReceiveChat(GameLanguage.NotInGuild, ChatType.System);
                        }

                        if (MyGuild.Ranks[0] != MyGuildRank)
                        {
                            ReceiveChat("You must be a leader to start a war.", ChatType.System);
                            return;
                        }

                        if (enemyGuild == null)
                        {
                            ReceiveChat(string.Format("Could not find guild {0}.", parts[1]), ChatType.System);
                            return;
                        }

                        if (MyGuild == enemyGuild)
                        {
                            ReceiveChat("Cannot go to war with your own guild.", ChatType.System);
                            return;
                        }

                        if (MyGuild.WarringGuilds.Contains(enemyGuild))
                        {
                            ReceiveChat("Already at war with this guild.", ChatType.System);
                            return;
                        }

                        if (MyGuild.GoToWar(enemyGuild))
                        {
                            ReceiveChat(string.Format("You started a war with {0}.", parts[1]), ChatType.System);
                            enemyGuild.SendMessage(string.Format("{0} has started a war", MyGuild.Name), ChatType.System);
                        }

                        break;

                    case "ADDINVENTORY":
                        {
                            int openLevel = (int)((Info.Inventory.Length - 46) / 4);
                            uint openGold = (uint)(1000000 + openLevel * 1000000);
                            if (Account.Gold >= openGold)
                            {
                                Account.Gold -= openGold;
                                Enqueue(new S.LoseGold { Gold = openGold });
                                Enqueue(new S.ResizeInventory { Size = Info.ResizeInventory() });
                                ReceiveChat(GameLanguage.InventoryIncreased, ChatType.System);
                            }
                            else
                            {
                                ReceiveChat(GameLanguage.LowGold, ChatType.System);
                            }
                            ChatTime = 0;
                        }
                        break;

                    case "ADDSTORAGE":
                        {
                            TimeSpan addedTime = new TimeSpan(10, 0, 0, 0);
                            uint cost = 1000000;

                            if (Account.Gold >= cost)
                            {
                                Account.Gold -= cost;
                                Account.HasExpandedStorage = true;

                                if (Account.ExpandedStorageExpiryDate > Envir.Now)
                                {
                                    Account.ExpandedStorageExpiryDate = Account.ExpandedStorageExpiryDate + addedTime;
                                    ReceiveChat(GameLanguage.ExpandedStorageExpiresOn + Account.ExpandedStorageExpiryDate.ToString(), ChatType.System);
                                }
                                else
                                {
                                    Account.ExpandedStorageExpiryDate = Envir.Now + addedTime;
                                    ReceiveChat(GameLanguage.ExpandedStorageExpiresOn + Account.ExpandedStorageExpiryDate.ToString(), ChatType.System);
                                }

                                Enqueue(new S.LoseGold { Gold = cost });
                                Enqueue(new S.ResizeStorage { Size = Account.ExpandStorage(), HasExpandedStorage = Account.HasExpandedStorage, ExpiryTime = Account.ExpandedStorageExpiryDate });
                            }
                            else
                            {
                                ReceiveChat(GameLanguage.LowGold, ChatType.System);
                            }
                            ChatTime = 0;
                        }
                        break;

                    case "INFO":
                        {
                            if (!IsGM && !Settings.TestServer) return;

                            MapObject ob = null;

                            if (parts.Length < 2)
                            {
                                Point target = Functions.PointMove(CurrentLocation, Direction, 1);
                                Cell cell = CurrentMap.GetCell(target);

                                if (cell.Objects == null || cell.Objects.Count < 1) return;

                                ob = cell.Objects[0];
                            }
                            else
                            {
                                ob = Envir.GetPlayer(parts[1]);
                            }

                            if (ob == null) return;

                            switch (ob.Race)
                            {
                                case ObjectType.Player:
                                    PlayerObject plOb = (PlayerObject)ob;
                                    ReceiveChat("--Player Info--", ChatType.System2);
                                    ReceiveChat(string.Format("Name : {0}, Level : {1}, X : {2}, Y : {3}", plOb.Name, plOb.Level, plOb.CurrentLocation.X, plOb.CurrentLocation.Y), ChatType.System2);
                                    break;
                                case ObjectType.Monster:
                                    MonsterObject monOb = (MonsterObject)ob;
                                    ReceiveChat("--Monster Info--", ChatType.System2);
                                    ReceiveChat(string.Format("ID : {0}, Name : {1}", monOb.Info.Index, monOb.Name), ChatType.System2);
                                    ReceiveChat(string.Format("Level : {0}, X : {1}, Y : {2}", monOb.Level, monOb.CurrentLocation.X, monOb.CurrentLocation.Y), ChatType.System2);
                                    ReceiveChat(string.Format("HP : {0}, MinDC : {1}, MaxDC : {2}", monOb.Info.Stats[Stat.HP], monOb.Stats[Stat.MinDC], monOb.Stats[Stat.MaxDC]), ChatType.System2);
                                    break;
                                case ObjectType.Merchant:
                                    NPCObject npcOb = (NPCObject)ob;
                                    ReceiveChat("--NPC Info--", ChatType.System2);
                                    ReceiveChat(string.Format("ID : {0}, Name : {1}", npcOb.Info.Index, npcOb.Name), ChatType.System2);
                                    ReceiveChat(string.Format("X : {0}, Y : {1}", ob.CurrentLocation.X, ob.CurrentLocation.Y), ChatType.System2);
                                    ReceiveChat(string.Format("File : {0}", npcOb.Info.FileName), ChatType.System2);
                                    break;
                            }
                        }
                        break;

                    case "CLEARQUESTS":
                        if (!IsGM && !Settings.TestServer) return;

                        player = parts.Length > 1 && IsGM ? Envir.GetPlayer(parts[1]) : this;

                        if (player == null)
                        {
                            ReceiveChat(parts[1] + " is not online", ChatType.System);
                            return;
                        }

                        for (int i = player.CurrentQuests.Count - 1; i >= 0; i--)
                        {
                            SendUpdateQuest(player.CurrentQuests[i], QuestState.Remove);
                        }

                        player.CompletedQuests.Clear();
                        player.GetCompletedQuests();

                        break;

                    case "SETQUEST":
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 3) return;

                        player = parts.Length > 3 && IsGM ? Envir.GetPlayer(parts[3]) : this;

                        if (player == null)
                        {
                            ReceiveChat(parts[3] + " is not online", ChatType.System);
                            return;
                        }

                        int questid = 0;
                        int questState = 0;

                        int.TryParse(parts[1], out questid);
                        int.TryParse(parts[2], out questState);

                        if (questid < 1) return;

                        var activeQuest = player.CurrentQuests.FirstOrDefault(e => e.Index == questid);

                        //remove from active list
                        if (activeQuest != null)
                        {
                            player.SendUpdateQuest(activeQuest, QuestState.Remove);
                        }

                        switch (questState)
                        {
                            case 0: //cancel
                                if (player.CompletedQuests.Contains(questid))
                                {
                                    player.CompletedQuests.Remove(questid);
                                }
                                break;
                            case 1: //complete
                                if (!player.CompletedQuests.Contains(questid))
                                {
                                    player.CompletedQuests.Add(questid);
                                }
                                break;
                        }

                        player.GetCompletedQuests();
                        break;

                    case "TOGGLETRANSFORM":
                        if (HasBuff(BuffType.Transform, out Buff transform))
                        {
                            if (transform.Paused)
                            {
                                UnpauseBuff(transform);
                            }
                            else
                            {
                                PauseBuff(transform);
                            }
                            RefreshStats();

                            hintstring = transform.Paused ? "Transform Disabled." : "Transform Enabled.";
                            ReceiveChat(hintstring, ChatType.Hint);
                        }                   
                        break;

                    case "STARTCONQUEST":
                        //Needs some work, but does job for now.
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;
                        int ConquestID;

                        if (parts.Length < 1)
                        {
                            ReceiveChat(string.Format("The Syntax is /StartConquest [ConquestID]"), ChatType.System);
                            return;
                        }

                        if (MyGuild == null)
                        {
                            ReceiveChat(string.Format("You need to be in a guild to start a War"), ChatType.System);
                            return;
                        }
                
                        else if (!int.TryParse(parts[1], out ConquestID)) return;

                        ConquestObject tempConq = Envir.Conquests.FirstOrDefault(t => t.Info.Index == ConquestID);

                        if (tempConq != null)
                        {
                            tempConq.StartType = ConquestType.Forced;
                            tempConq.WarIsOn = !tempConq.WarIsOn;
                            tempConq.AttackerID = MyGuild.Guildindex;
                        }
                        else return;
                        ReceiveChat(string.Format("{0} War Started.", tempConq.Info.Name), ChatType.System);
                        MessageQueue.Enqueue(string.Format("{0} War Started.", tempConq.Info.Name));
                        break;
                    case "RESETCONQUEST":
                        //Needs some work, but does job for now.
                        if ((!IsGM && !Settings.TestServer) || parts.Length < 2) return;
                        int ConquestNum;

                        if (parts.Length < 1)
                        {
                            ReceiveChat(string.Format("The Syntax is /ResetConquest [ConquestID]"), ChatType.System);
                            return;
                        }

                        if (MyGuild == null)
                        {
                            ReceiveChat(string.Format("You need to be in a guild to start a War"), ChatType.System);
                            return;
                        }

                        else if (!int.TryParse(parts[1], out ConquestNum)) return;

                        ConquestObject ResetConq = Envir.Conquests.FirstOrDefault(t => t.Info.Index == ConquestNum);

                        if (ResetConq != null && !ResetConq.WarIsOn)
                        {
                            ResetConq.Reset();
                        }
                        else
                        {
                            ReceiveChat("Conquest not found or War is currently on.", ChatType.System);
                            return;
                        }
                        ReceiveChat(string.Format("{0} has been reset.", ResetConq.Info.Name), ChatType.System);
                        break;
                    case "GATES":

                        if (MyGuild == null || MyGuild.Conquest == null || !MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeRank) || MyGuild.Conquest.WarIsOn)
                        {
                            ReceiveChat(string.Format("You don't have access to control any gates at the moment."), ChatType.System);
                            return;
                        }

                        bool OpenClose = false;

                        if (parts.Length > 1)
                        {
                            string openclose = parts[1];

                            if (openclose.ToUpper() == "CLOSE") OpenClose = true;
                            else if (openclose.ToUpper() == "OPEN") OpenClose = false;
                            else
                            {
                                ReceiveChat(string.Format("You must type /Gates Open or /Gates Close."), ChatType.System);
                                return;
                            }

                            for (int i = 0; i < MyGuild.Conquest.GateList.Count; i++)
                                if (MyGuild.Conquest.GateList[i].Gate != null && !MyGuild.Conquest.GateList[i].Gate.Dead)
                                    if (OpenClose)
                                        MyGuild.Conquest.GateList[i].Gate.CloseDoor();
                                    else
                                        MyGuild.Conquest.GateList[i].Gate.OpenDoor();
                        }
                        else
                        {
                            for (int i = 0; i < MyGuild.Conquest.GateList.Count; i++)
                                if (MyGuild.Conquest.GateList[i].Gate != null && !MyGuild.Conquest.GateList[i].Gate.Dead)
                                    if (!MyGuild.Conquest.GateList[i].Gate.Closed)
                                    {
                                        MyGuild.Conquest.GateList[i].Gate.CloseDoor();
                                        OpenClose = true;
                                    }
                                    else
                                    {
                                        MyGuild.Conquest.GateList[i].Gate.OpenDoor();
                                        OpenClose = false;
                                    }
                        }

                        if (OpenClose)
                            ReceiveChat(string.Format("The gates at {0} have been closed.", MyGuild.Conquest.Info.Name), ChatType.System);
                        else
                            ReceiveChat(string.Format("The gates at {0} have been opened.", MyGuild.Conquest.Info.Name), ChatType.System);
                        break;

                    case "CHANGEFLAG":
                        if (MyGuild == null || MyGuild.Conquest == null || !MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeRank) || MyGuild.Conquest.WarIsOn)
                        {
                            ReceiveChat(string.Format("You don't have access to change any flags at the moment."), ChatType.System);
                            return;
                        }

                        ushort flag = (ushort)Envir.Random.Next(12);

                        if(parts.Length > 1)
                        {
                            ushort temp;

                            ushort.TryParse(parts[1], out temp);

                            if (temp <= 11) flag = temp;
                        }

                        MyGuild.FlagImage = (ushort)(1000 + flag);

                        for (int i = 0; i < MyGuild.Conquest.FlagList.Count; i++)
                        {
                            MyGuild.Conquest.FlagList[i].UpdateImage();
                        }

                        break;
                    case "CHANGEFLAGCOLOUR":
                        {
                            if (MyGuild == null || MyGuild.Conquest == null || !MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeRank) || MyGuild.Conquest.WarIsOn)
                            {
                                ReceiveChat(string.Format("You don't have access to change any flags at the moment."), ChatType.System);
                                return;
                            }

                            byte r1 = (byte)Envir.Random.Next(255);
                            byte g1 = (byte)Envir.Random.Next(255);
                            byte b1 = (byte)Envir.Random.Next(255);

                            if (parts.Length > 3)
                            {
                                byte.TryParse(parts[1], out r1);
                                byte.TryParse(parts[2], out g1);
                                byte.TryParse(parts[3], out b1);
                            }

                            MyGuild.FlagColour = Color.FromArgb(255, r1, g1, b1);

                            for (int i = 0; i < MyGuild.Conquest.FlagList.Count; i++)
                            {
                                MyGuild.Conquest.FlagList[i].UpdateColour();
                            }
                        }
                        break;
                    case "REVIVE":
                        if (!IsGM) return;

                        if (parts.Length < 2)
                        {
                            RefreshStats();
                            SetHP(Stats[Stat.HP]);
                            SetMP(Stats[Stat.MP]);
                            Revive(MaxHealth, true);
                        }
                        else
                        {
                            player = Envir.GetPlayer(parts[1]);
                            if (player == null) return;
                            player.Revive(MaxHealth, true);
                        }
                        break;
                    case "DELETESKILL":
                        if ((!IsGM) || parts.Length < 2) return;
                        Spell skill1;

                        if (!Enum.TryParse(parts.Length > 2 ? parts[2] : parts[1], true, out skill1)) return;

                        if (skill1 == Spell.None) return;

                        if (parts.Length > 2)
                        {
                            if (!IsGM) return;
                            player = Envir.GetPlayer(parts[1]);

                            if (player == null)
                            {
                                ReceiveChat(string.Format("Player {0} was not found!", parts[1]), ChatType.System);
                                return;
                            }
                        }
                        else
                            player = this;

                        if (player == null) return;

                        var magics = new UserMagic(skill1);
                        bool removed = false;

                        for (var i = player.Info.Magics.Count - 1; i >= 0; i--)
                        {
                            if (player.Info.Magics[i].Spell != skill1) continue;

                            player.Info.Magics.RemoveAt(i);
                            player.Enqueue(new S.RemoveMagic { PlaceId = i });
                            removed = true;
                        }

                        if (removed)
                        {
                            ReceiveChat(string.Format("You have deleted skill {0} from player {1}", skill1.ToString(), player.Name), ChatType.Hint);
                            player.ReceiveChat(string.Format("{0} has been removed from you.", skill1), ChatType.Hint);
                        }
                        else ReceiveChat(string.Format("Unable to delete skill, skill not found"), ChatType.Hint);

                        break;
                    case "SETTIMER":
                        if (parts.Length < 4) return;

                        string key = parts[1];

                        if (!int.TryParse(parts[2], out int seconds)) return;
                        if (!byte.TryParse(parts[3], out byte timerType)) return;

                        SetTimer(key, seconds, timerType);

                        break;
                    case "SETLIGHT":
                        if ((!IsGM) || parts.Length < 2) return;

                        if (!byte.TryParse(parts[1], out byte light)) return;

                        Light = light;

                        Enqueue(GetUpdateInfo());
                        Broadcast(GetUpdateInfo());
                        break;
                    default:
                        break;
                }

                foreach (string command in Envir.CustomCommands)
                {
                    if (string.Compare(parts[0], command, true) != 0) continue;
                    CallDefaultNPC(DefaultNPCType.CustomCommand, parts[0]);
                }

                foreach (string command in Envir.WorldMap)
                {
                    if (string.Compare(parts[0], command, true) != 0) continue;
                    CallDefaultNPC(DefaultNPCType.WorldMap, parts[0]);
                }
            }
            else
            {
                message = String.Format("{0}:{1}", CurrentMap.Info.NoNames ? "?????" : Name, message);

                message = ProcessChatItems(message, null, linkedItems);

                p = new S.ObjectChat { ObjectID = ObjectID, Text = message, Type = ChatType.Normal };

                Enqueue(p);
                Broadcast(p);
            }
        }

        private string ProcessChatItems(string text, List<PlayerObject> recipients, List<ChatItem> chatItems)
        {
            if (chatItems == null)
            {
                return text;
            }

            foreach (var chatItem in chatItems)
            {
                Regex r = new Regex(chatItem.RegexInternalName, RegexOptions.IgnoreCase);

                text = r.Replace(text, chatItem.InternalName, 1);

                UserItem[] array;

                switch (chatItem.Grid)
                {
                    case MirGridType.Inventory:
                        array = Info.Inventory;
                        break;
                    case MirGridType.Storage:
                        array = Info.AccountInfo.Storage;
                        break;
                    default:
                        continue;
                }

                UserItem item = null;

                for (int i = 0; i < array.Length; i++)
                {
                    item = array[i];
                    if (item == null || item.UniqueID != chatItem.UniqueID) continue;
                    break;
                }

                if (item != null)
                {
                    if (recipients == null)
                    {
                        for (int i = CurrentMap.Players.Count - 1; i >= 0; i--)
                        {
                            PlayerObject player = CurrentMap.Players[i];
                            if (player == this) continue;

                            if (Functions.InRange(CurrentLocation, player.CurrentLocation, Globals.DataRange))
                            {
                                player.CheckItem(item);

                                if (!player.Connection.SentChatItem.Contains(item))
                                {
                                    player.Enqueue(new S.NewChatItem { Item = item });
                                    player.Connection.SentChatItem.Add(item);
                                }
                            }
                        }
                    }
                    else
                    {
                        for (int i = 0; i < recipients.Count; i++)
                        {
                            PlayerObject player = recipients[i];
                            if (player == this) continue;

                            player.CheckItem(item);

                            if (!player.Connection.SentChatItem.Contains(item))
                            {
                                player.Enqueue(new S.NewChatItem { Item = item });
                                player.Connection.SentChatItem.Add(item);
                            }
                        }
                    }

                    if (!Connection.SentChatItem.Contains(item))
                    {
                        Enqueue(new S.NewChatItem { Item = item });
                        Connection.SentChatItem.Add(item);
                    }
                }
            }

            return text;
        }

        public void Turn(MirDirection dir)
        {
            _stepCounter = 0;

            if (CanMove)
            {
                ActionTime = Envir.Time + GetDelayTime(TurnDelay);

                Direction = dir;
                if (CheckMovement(CurrentLocation)) return;

                SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

                if (szi != null)
                {
                    BindLocation = szi.Location;
                    BindMapIndex = CurrentMapIndex;
                    InSafeZone = true;
                }
                else
                    InSafeZone = false;

                Cell cell = CurrentMap.GetCell(CurrentLocation);

                for (int i = 0; i < cell.Objects.Count; i++)
                {
                    if (cell.Objects[i].Race != ObjectType.Spell) continue;
                    SpellObject ob = (SpellObject)cell.Objects[i];

                    ob.ProcessSpell(this);
                    //break;
                }

                if (TradePartner != null)
                    TradeCancel();

                if (ItemRentalPartner != null)
                    CancelItemRental();

                Broadcast(new S.ObjectTurn { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });
            }

            Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
        }
        public void Harvest(MirDirection dir)
        {
            if (!CanMove)
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            ActionTime = Envir.Time + HarvestDelay;

            Direction = dir;

            Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
            Broadcast(new S.ObjectHarvest { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });

            Point front = Front;
            bool send = false;
            for (int d = 0; d <= 1; d++)
            {
                for (int y = front.Y - d; y <= front.Y + d; y++)
                {
                    if (y < 0) continue;
                    if (y >= CurrentMap.Height) break;

                    for (int x = front.X - d; x <= front.X + d; x += Math.Abs(y - front.Y) == d ? 1 : d * 2)
                    {
                        if (x < 0) continue;
                        if (x >= CurrentMap.Width) break;
                        if (!CurrentMap.ValidPoint(x, y)) continue;

                        Cell cell = CurrentMap.GetCell(x, y);
                        if (cell.Objects == null) continue;

                        for (int i = 0; i < cell.Objects.Count; i++)
                        {
                            MapObject ob = cell.Objects[i];
                            if (ob.Race != ObjectType.Monster || !ob.Dead || ob.Harvested) continue;

                            if (ob.EXPOwner != null && ob.EXPOwner != this && !IsMember(ob))
                            {
                                send = true;
                                continue;
                            }

                            if (ob.Harvest(this)) return;
                        }
                    }
                }
            }

            if (send)
                ReceiveChat("You do not own any nearby carcasses.", ChatType.System);
        }

        public void RemoveConquestItems(int conquestID)
        {
            for (int i = 0; i < Info.Equipment.Length; i++)
            {
                var item = Info.Equipment[i];

                if (item == null || item.Info.RequiredType != RequiredType.Conquest || (item.Info.RequiredAmount != conquestID && conquestID > -1)) continue;

                Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                Info.Equipment[i] = null;
            }

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                var item = Info.Inventory[i];

                if (item == null || item.Info.RequiredType != RequiredType.Conquest || (item.Info.RequiredAmount != conquestID && conquestID > -1)) continue;

                Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                Info.Inventory[i] = null;
            }

            for (int i = 0; i < Account.Storage.Length; i++)
            {
                var item = Account.Storage[i];

                if (item == null || item.Info.RequiredType != RequiredType.Conquest || (item.Info.RequiredAmount != conquestID && conquestID > -1)) continue;

                Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                Account.Storage[i] = null;
            }
        }
        public void Walk(MirDirection dir)
        {
            if (!CanMove || !CanWalk)
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            Point location = Functions.PointMove(CurrentLocation, dir, 1);

            if (!CurrentMap.ValidPoint(location))
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            if (!CurrentMap.CheckDoorOpen(location))
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }


            Cell cell = CurrentMap.GetCell(location);
            if (cell.Objects != null)
            {
                for (int i = 0; i < cell.Objects.Count; i++)
                {
                    MapObject ob = cell.Objects[i];

                    if (ob.Race == ObjectType.Merchant)
                    {
                        NPCObject NPC = (NPCObject)ob;
                        if (!NPC.Visible || !NPC.VisibleLog[Info.Index]) continue;
                    }
                    else
                        if (!ob.Blocking || ob.CellTime >= Envir.Time) continue;

                    Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                    return;
                }
            }

            if (HasBuff(BuffType.Concentration, out Buff concentration))
            {
                concentration.Set("InterruptTime", Envir.Time + (Settings.Second * 3));

                if (!concentration.Get<bool>("Interrupted"))
                {
                    concentration.Set("Interrupted", true);
                    UpdateConcentration(true, true);
                }
            }

            if (Hidden)
            {
                RemoveBuff(BuffType.Hiding);
            }

            Direction = dir;
            if (CheckMovement(location)) return;

            CurrentMap.GetCell(CurrentLocation).Remove(this);
            RemoveObjects(dir, 1);

            CurrentLocation = location;
            CurrentMap.GetCell(CurrentLocation).Add(this);
            AddObjects(dir, 1);

            _stepCounter++;

            SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

            if (szi != null)
            {
                BindLocation = szi.Location;
                BindMapIndex = CurrentMapIndex;
                InSafeZone = true;
            }
            else
                InSafeZone = false;


            CheckConquest();

            CellTime = Envir.Time + 500;
            ActionTime = Envir.Time + GetDelayTime(MoveDelay);

            if (TradePartner != null)
                TradeCancel();

            if (ItemRentalPartner != null)
                CancelItemRental();

            if (RidingMount) DecreaseMountLoyalty(1);

            Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
            Broadcast(new S.ObjectWalk { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });


            cell = CurrentMap.GetCell(CurrentLocation);

            for (int i = 0; i < cell.Objects.Count; i++)
            {
                if (cell.Objects[i].Race != ObjectType.Spell) continue;
                SpellObject ob = (SpellObject)cell.Objects[i];

                ob.ProcessSpell(this);
                //break;
            }

        }
        public void Run(MirDirection dir)
        {
            var steps = RidingMount || ActiveSwiftFeet && !Sneaking? 3 : 2;

            if (!CanMove || !CanWalk || !CanRun)
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            if (HasBuff(BuffType.Concentration, out Buff concentration))
            {
                concentration.Set("InterruptTime", Envir.Time + (Settings.Second * 3));

                if (!concentration.Get<bool>("Interrupted"))
                {
                    concentration.Set("Interrupted", true);
                    UpdateConcentration(true, true);
                }
            }

            if (TradePartner != null)
                TradeCancel();

            if (ItemRentalPartner != null)
                CancelItemRental();

            if (Hidden && !Sneaking)
            {
                RemoveBuff(BuffType.Hiding);
                RemoveBuff(BuffType.MoonLight);
                RemoveBuff(BuffType.DarkBody);
            }

            Direction = dir;
            Point location = Functions.PointMove(CurrentLocation, dir, 1);
            for (int j = 1; j <= steps; j++)
            {
                location = Functions.PointMove(CurrentLocation, dir, j);
                if (!CurrentMap.ValidPoint(location))
                {
                    Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                    return;
                }
                if (!CurrentMap.CheckDoorOpen(location))
                {
                    Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                    return;
                }
                Cell cell = CurrentMap.GetCell(location);

                if (cell.Objects != null)
                {
                    for (int i = 0; i < cell.Objects.Count; i++)
                    {
                        MapObject ob = cell.Objects[i];

                        if (ob.Race == ObjectType.Merchant)
                        {
                            NPCObject NPC = (NPCObject)ob;
                            if (!NPC.Visible || !NPC.VisibleLog[Info.Index]) continue;
                        }
                        else
                            if (!ob.Blocking || ob.CellTime >= Envir.Time) continue;

                        Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                        return;
                    }

                    
                }
                if (CheckMovement(location)) return;

            }
            if (RidingMount && !Sneaking)
            {
                DecreaseMountLoyalty(2);
            }

            Direction = dir;

            CurrentMap.GetCell(CurrentLocation).Remove(this);
            RemoveObjects(dir, steps);

            Point OldLocation = CurrentLocation;
            CurrentLocation = location;
            CurrentMap.GetCell(CurrentLocation).Add(this);
            AddObjects(dir, steps);


            SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

            if (szi != null)
            {
                BindLocation = szi.Location;
                BindMapIndex = CurrentMapIndex;
                InSafeZone = true;
            }
            else
                InSafeZone = false;


            CheckConquest();



            CellTime = Envir.Time + 500;
            ActionTime = Envir.Time + GetDelayTime(MoveDelay);

            if (!RidingMount)
                _runCounter++;

            if (_runCounter > 10)
            {
                _runCounter -= 8;
                ChangeHP(-1);
            }

            Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
            Broadcast(new S.ObjectRun { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });


            for (int j = 1; j <= steps; j++)
            {
                location = Functions.PointMove(OldLocation, dir, j);
                Cell cell = CurrentMap.GetCell(location);
                if (cell.Objects == null) continue;
                for (int i = 0; i < cell.Objects.Count; i++)
                {
                    if (cell.Objects[i].Race != ObjectType.Spell) continue;
                    SpellObject ob = (SpellObject)cell.Objects[i];

                    ob.ProcessSpell(this);
                    //break;
                }
            }

        }
        public override int Pushed(MapObject pusher, MirDirection dir, int distance)
        {
            int result = 0;
            MirDirection reverse = Functions.ReverseDirection(dir);
            Cell cell;
            for (int i = 0; i < distance; i++)
            {
                Point location = Functions.PointMove(CurrentLocation, dir, 1);

                if (!CurrentMap.ValidPoint(location)) return result;

                cell = CurrentMap.GetCell(location);

                bool stop = false;
                if (cell.Objects != null)
                    for (int c = 0; c < cell.Objects.Count; c++)
                    {
                        MapObject ob = cell.Objects[c];
                        if (!ob.Blocking) continue;
                        stop = true;
                    }
                if (stop) break;

                CurrentMap.GetCell(CurrentLocation).Remove(this);

                Direction = reverse;
                RemoveObjects(dir, 1);
                CurrentLocation = location;
                CurrentMap.GetCell(CurrentLocation).Add(this);
                AddObjects(dir, 1);

                if (TradePartner != null)
                    TradeCancel();

                if (ItemRentalPartner != null)
                    CancelItemRental();

                Enqueue(new S.Pushed { Direction = Direction, Location = CurrentLocation });
                Broadcast(new S.ObjectPushed { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });

                result++;
            }

            if (result > 0)
            {
                if (HasBuff(BuffType.Concentration, out Buff concentration))
                {
                    concentration.Set("InterruptTime", Envir.Time + (Settings.Second * 3));

                    if (!concentration.Get<bool>("Interrupted"))
                    {
                        concentration.Set("Interrupted", true);
                        UpdateConcentration(true, true);
                    }
                }

                cell = CurrentMap.GetCell(CurrentLocation);

                for (int i = 0; i < cell.Objects.Count; i++)
                {
                    if (cell.Objects[i].Race != ObjectType.Spell) continue;
                    SpellObject ob = (SpellObject)cell.Objects[i];

                    ob.ProcessSpell(this);
                    //break;
                }

                SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

                if (szi != null)
                {
                    BindLocation = szi.Location;
                    BindMapIndex = CurrentMapIndex;
                    InSafeZone = true;
                }
                else
                    InSafeZone = false;
            }

            ActionTime = Envir.Time + 500;
            return result;
        }

        public void RangeAttack(MirDirection dir, Point location, uint targetID)
        {
            LogTime = Envir.Time + Globals.LogDelay;

            if (Info.Equipment[(int)EquipmentSlot.Weapon] == null) return;
            ItemInfo RealItem = Functions.GetRealItem(Info.Equipment[(int)EquipmentSlot.Weapon].Info, Info.Level, Info.Class, Envir.ItemInfoList);

            if ((RealItem.Shape / Globals.ClassWeaponCount) != 2) return;
            if (Functions.InRange(CurrentLocation, location, Globals.MaxAttackRange) == false) return;

            MapObject target = null;

            if (targetID == ObjectID)
                target = this;
            else if (targetID > 0)
                target = FindObject(targetID, 10);

            if (target != null && target.Dead) return;

            if (target != null && target.Race != ObjectType.Monster && target.Race != ObjectType.Player) return;

            Direction = dir;

            Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });

            UserMagic magic;
            Spell spell = Spell.None;
            bool focus = false;

            if (target != null && !CanFly(target.CurrentLocation) && (Info.MentalState != 1))
            {
                target = null;
                targetID = 0;
            }

            if (target != null)
            {
                magic = GetMagic(Spell.Focus);

                if (magic != null && Envir.Random.Next(5) <= magic.Level)
                {
                    focus = true;
                    LevelMagic(magic);
                    spell = Spell.Focus;
                }

                int distance = Functions.MaxDistance(CurrentLocation, target.CurrentLocation);

                int damage = GetRangeAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC], distance);

                damage = ApplyArcherState(damage);

                int chanceToHit = (100 + Settings.RangeAccuracyBonus - ((100 / Globals.MaxAttackRange) * distance)) * (focus ? 2 : 1);

                if (chanceToHit < 0) chanceToHit = 0;

                int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500 + 50; //50 MS per Step

                if (Envir.Random.Next(100) < chanceToHit)
                {
                    if (target.CurrentLocation != location)
                        location = target.CurrentLocation;

                    DelayedAction action = new DelayedAction(DelayedType.Damage, Envir.Time + delay, target, damage, DefenceType.ACAgility, true);
                    ActionList.Add(action);
                }
                else
                {
                    DelayedAction action = new DelayedAction(DelayedType.DamageIndicator, Envir.Time + delay, target, DamageType.Miss);
                    ActionList.Add(action);
                }
            }
            else
                targetID = 0;

            Enqueue(new S.RangeAttack { TargetID = targetID, Target = location, Spell = spell });
            Broadcast(new S.ObjectRangeAttack { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation, TargetID = targetID, Target = location, Spell = spell });

            AttackTime = Envir.Time + AttackSpeed;
            ActionTime = Envir.Time + 550;
            //RegenTime = Envir.Time + RegenDelay;
            RegenStandTime = Envir.Time + Settings.RegenStandDelay;
        }

        public void Attack(MirDirection dir, Spell spell)
        {
            LogTime = Envir.Time + Globals.LogDelay;

            bool Mined = false;
            bool MoonLightAttack = false;
            bool DarkBodyAttack = false;

            if (!CanAttack)
            {
                switch (spell)
                {
                    case Spell.Slaying:
                        Slaying = false;
                        break;
                }

                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            if (Hidden)
            {
                for (int i = 0; i < Buffs.Count; i++)
                {
                    switch (Buffs[i].Type)
                    {
                        case BuffType.MoonLight:
                            MoonLightAttack = true;
                            break;
                        case BuffType.DarkBody:
                            DarkBodyAttack = true;
                            break;
                    }
                }

                RemoveBuff(BuffType.MoonLight);
                RemoveBuff(BuffType.DarkBody);
            }

            byte level = 0;
            UserMagic magic;

            if (RidingMount)
            {
                spell = Spell.None;
            }

            switch (spell)
            {
                case Spell.Slaying:
                    if (!Slaying)
                        spell = Spell.None;
                    else
                    {
                        magic = GetMagic(Spell.Slaying);
                        level = magic.Level;
                    }

                    Slaying = false;
                    break;
                case Spell.DoubleSlash:
                    magic = GetMagic(spell);
                    if (magic == null || magic.Info.BaseCost + (magic.Level * magic.Info.LevelCost) > MP)
                    {
                        spell = Spell.None;
                        break;
                    }
                    level = magic.Level;
                    ChangeMP(-(magic.Info.BaseCost + magic.Level * magic.Info.LevelCost));
                    break;
                case Spell.Thrusting:
                case Spell.FlamingSword:
                    magic = GetMagic(spell);
                    if ((magic == null) || (!FlamingSword && (spell == Spell.FlamingSword)))
                    {
                        spell = Spell.None;
                        break;
                    }
                    level = magic.Level;
                    break;
                case Spell.WhirlWind:
                    magic = GetMagic(spell);
                    if ((magic == null) || (!WhirlWind && (spell == Spell.WhirlWind)))
                    {
                        spell = Spell.None;
                        break;
                    }
                    level = magic.Level;
                    break;
                case Spell.IceSword:
                    magic = GetMagic(spell);
                    if ((magic == null) || (!IceSword && (spell == Spell.IceSword)))
                    {
                        spell = Spell.None;
                        break;
                    }
                    level = magic.Level;
                    break;
                case Spell.HalfMoon:
                case Spell.CrossHalfMoon:
                    magic = GetMagic(spell);
                    if (magic == null || magic.Info.BaseCost + (magic.Level * magic.Info.LevelCost) > MP)
                    {
                        spell = Spell.None;
                        break;
                    }
                    level = magic.Level;
                    ChangeMP(-(magic.Info.BaseCost + magic.Level * magic.Info.LevelCost));
                    break;
                case Spell.TwinDrakeBlade:
                    magic = GetMagic(spell);
                    if (!TwinDrakeBlade || magic == null || magic.Info.BaseCost + magic.Level * magic.Info.LevelCost > MP)
                    {
                        spell = Spell.None;
                        break;
                    }
                    level = magic.Level;
                    ChangeMP(-(magic.Info.BaseCost + magic.Level * magic.Info.LevelCost));
                    break;
                default:
                    spell = Spell.None;
                    break;
            }


            if (!Slaying)
            {
                magic = GetMagic(Spell.Slaying);

                if (magic != null && Envir.Random.Next(12) <= magic.Level)
                {
                    Slaying = true;
                    Enqueue(new S.SpellToggle { Spell = Spell.Slaying, CanUse = Slaying });
                }
            }

            Direction = dir;

            if (RidingMount) DecreaseMountLoyalty(3);

            Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
            Broadcast(new S.ObjectAttack { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation, Spell = spell, Level = level });

            AttackTime = Envir.Time + AttackSpeed;
            ActionTime = Envir.Time + 550;
            //RegenTime = Envir.Time + RegenDelay;
            RegenStandTime = Envir.Time + Settings.RegenStandDelay;

            Point target = Functions.PointMove(CurrentLocation, dir, 1);

            //damabeBase = the original damage from your gear (+ bonus from moonlight and darkbody)
            int damageBase = GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]);
            //damageFinal = the damage you're gonna do with skills added
            int damageFinal;

            if (MoonLightAttack || DarkBodyAttack)
            {
                magic = MoonLightAttack ? GetMagic(Spell.MoonLight) : GetMagic(Spell.DarkBody);

                if (magic != null)
                {
                    damageBase += magic.GetPower();
                }
            }

            if (!CurrentMap.ValidPoint(target))
            {
                switch (spell)
                {
                    case Spell.Thrusting:
                        goto Thrusting;
                    case Spell.HalfMoon:
                        goto HalfMoon;
                    case Spell.CrossHalfMoon:
                        goto CrossHalfMoon;
                    case Spell.WhirlWind:
                        goto WhirlWind;
                    case Spell.None:
                        Mined = true;
                        goto Mining;
                }
                return;
            }

            Cell cell = CurrentMap.GetCell(target);

            if (cell.Objects == null)
            {
                switch (spell)
                {
                    case Spell.Thrusting:
                        goto Thrusting;
                    case Spell.HalfMoon:
                        goto HalfMoon;
                    case Spell.CrossHalfMoon:
                        goto CrossHalfMoon;
                    case Spell.WhirlWind:
                        goto WhirlWind;
                }
                return;
            }

            damageFinal = damageBase;//incase we're not using skills
            for (int i = 0; i < cell.Objects.Count; i++)
            {
                MapObject ob = cell.Objects[i];
                if (ob.Race != ObjectType.Player && ob.Race != ObjectType.Monster) continue;
                if (!ob.IsAttackTarget(this)) continue;

                //Only undead targets
                if (ob.Undead)
                {
                    damageBase = Math.Min(int.MaxValue, damageBase + Stats[Stat.Holy]);
                    damageFinal = damageBase;//incase we're not using skills
                }

                #region FatalSword
                magic = GetMagic(Spell.FatalSword);

                DefenceType defence = DefenceType.ACAgility;

                if (magic != null)
                {
                    if (FatalSword)
                        damageBase = magic.GetDamage(damageBase);

                    if (!FatalSword && Envir.Random.Next(10) == 0)
                        FatalSword = true;
                }
                #endregion

                #region MPEater
                magic = GetMagic(Spell.MPEater);

                if (magic != null)
                {
                    int baseCount = 1 + Stats[Stat.Accuracy] / 2;
                    int maxCount = baseCount + magic.Level * 5;
                    MPEaterCount += Envir.Random.Next(baseCount, maxCount);
                    if (MPEater)
                    {
                        LevelMagic(magic);
                        damageFinal = magic.GetDamage(damageBase);
                        defence = DefenceType.ACAgility;

                        S.ObjectEffect p = new S.ObjectEffect { ObjectID = ob.ObjectID, Effect = SpellEffect.MPEater, EffectType = ObjectID };
                        CurrentMap.Broadcast(p, ob.CurrentLocation);

                        int addMp = 5 * (magic.Level + Stats[Stat.Accuracy] / 4);

                        if (ob.Race == ObjectType.Player)
                        {
                            ((PlayerObject)ob).ChangeMP(-addMp);
                        }

                        ChangeMP(addMp);
                        MPEaterCount = 0;
                        MPEater = false;
                    }
                    else if (!MPEater && 100 <= MPEaterCount) MPEater = true;
                }
                #endregion

                #region Hemorrhage
                magic = GetMagic(Spell.Hemorrhage);

                if (magic != null)
                {
                    HemorrhageAttackCount += Envir.Random.Next(1, 1 + magic.Level * 2);
                    if (Hemorrhage)
                    {
                        damageFinal = magic.GetDamage(damageBase);
                        LevelMagic(magic);
                        S.ObjectEffect ef = new S.ObjectEffect { ObjectID = ob.ObjectID, Effect = SpellEffect.Hemorrhage };

                        CurrentMap.Broadcast(ef, ob.CurrentLocation);

                        if (ob == null || ob.Node == null) continue;

                        long calcDuration = magic.Level * 2 + Stats[Stat.Luck] / 6;

                        ob.ApplyPoison(new Poison
                        {
                            Duration = (calcDuration <= 0) ? 1 : calcDuration,
                            Owner = this,
                            PType = PoisonType.Bleeding,
                            TickSpeed = 1000,
                            Value = Stats[Stat.MaxDC] + 1
                        }, this);

                        ob.OperateTime = 0;
                        HemorrhageAttackCount = 0;
                        Hemorrhage = false;
                    }
                    else if (!Hemorrhage && 55 <= HemorrhageAttackCount) Hemorrhage = true;
                }
                #endregion

                DelayedAction action;
                switch (spell)
                {
                    case Spell.Slaying:
                        magic = GetMagic(Spell.Slaying);
                        damageFinal = magic.GetDamage(damageBase);
                        LevelMagic(magic);
                        break;
                    case Spell.DoubleSlash:
                        magic = GetMagic(Spell.DoubleSlash);
                        damageFinal = magic.GetDamage(damageBase);

                        if (defence == DefenceType.ACAgility) defence = DefenceType.MACAgility;

                        action = new DelayedAction(DelayedType.Damage, Envir.Time + 400, ob, damageFinal, DefenceType.Agility, false);
                        ActionList.Add(action);
                        LevelMagic(magic);
                        break;
                    case Spell.Thrusting:
                        magic = GetMagic(Spell.Thrusting);
                        LevelMagic(magic);
                        break;
                    case Spell.HalfMoon:
                        magic = GetMagic(Spell.HalfMoon);
                        LevelMagic(magic);
                        break;
                    case Spell.CrossHalfMoon:
                        magic = GetMagic(Spell.CrossHalfMoon);
                        LevelMagic(magic);
                        break;
                    case Spell.TwinDrakeBlade:
                        magic = GetMagic(Spell.TwinDrakeBlade);
                        if (ob.Race == ObjectType.Player)
                            damageFinal = magic.PvPGetDamage(damageBase);
                        else
                            damageFinal = magic.GetDamage(damageBase);
                        TwinDrakeBlade = false;
                        action = new DelayedAction(DelayedType.Damage, Envir.Time + 400,
                            ob,                     //Object (Target)
                            damageFinal,            //Damage
                            DefenceType.Agility,    //Defence to target
                            false,                  //Damage Weapon
                            magic,                  //Magic
                            true);                  //Final hit
                        ActionList.Add(action);
                        LevelMagic(magic);
                        break;
                    case Spell.FlamingSword:
                        magic = GetMagic(Spell.FlamingSword);
                        if (ob.Race == ObjectType.Player)
                            damageFinal = magic.PvPGetDamage(damageBase);
                        else
                            damageFinal = magic.GetDamage(damageBase);
                        FlamingSword = false;
                        defence = DefenceType.AC;
                        //action = new DelayedAction(DelayedType.Damage, Envir.Time + 400, ob, damage, DefenceType.Agility, true);
                        //ActionList.Add(action);
                        LevelMagic(magic);
                        break;
                    case Spell.WhirlWind:
                        magic = GetMagic(Spell.WhirlWind);
                        if (ob.Race == ObjectType.Player)
                            damageFinal = magic.PvPGetDamage(damageBase);
                        else
                            damageFinal = magic.GetDamage(damageBase);
                        WhirlWind = false;
                        //defence = DefenceType.AC;
                        LevelMagic(magic);
                        break;
                    case Spell.IceSword:
                        magic = GetMagic(Spell.IceSword);
                        if (ob.Race == ObjectType.Player)
                            damageFinal = magic.PvPGetDamage(damageBase);
                        else
                            damageFinal = magic.GetDamage(damageBase);
                        IceSword = false;
                        action = new DelayedAction(DelayedType.Damage, Envir.Time + 400, ob, damageFinal, DefenceType.ACAgility, false);
                        ActionList.Add(action);
                        LevelMagic(magic);

                        if (ob.Race != ObjectType.Player &&
                            ob.Level < Level + 10 &&
                            Envir.Random.Next(20) == 0)
                        {
                            ob.ApplyPoison(new Poison { PType = PoisonType.Frozen, Duration = 1 + magic.Level, TickSpeed = 1000 }, this);
                        }
                        break;
                }

                //if (ob.Attacked(this, damage, defence) <= 0) break;
                action = new DelayedAction(DelayedType.Damage, Envir.Time + 300, ob, damageFinal, defence, true);
                ActionList.Add(action);
                break;
            }

        Thrusting:
            if (spell == Spell.Thrusting)
            {
                target = Functions.PointMove(target, dir, 1);

                if (!CurrentMap.ValidPoint(target)) return;

                cell = CurrentMap.GetCell(target);

                if (cell.Objects == null) return;

                for (int i = 0; i < cell.Objects.Count; i++)
                {
                    MapObject ob = cell.Objects[i];
                    if (ob.Race != ObjectType.Player && ob.Race != ObjectType.Monster) continue;
                    if (!ob.IsAttackTarget(this)) continue;

                    magic = GetMagic(spell);
                    if (ob.Race == ObjectType.Player)
                        damageFinal = magic.PvPGetDamage(damageBase);
                    else
                        damageFinal = magic.GetDamage(damageBase);
                    ob.Attacked(this, damageFinal, DefenceType.Agility, false);
                    break;
                }


            }
        HalfMoon:
            if (spell == Spell.HalfMoon)
            {
                dir = Functions.PreviousDir(dir);

                magic = GetMagic(spell);

                for (int i = 0; i < 4; i++)
                {
                    target = Functions.PointMove(CurrentLocation, dir, 1);
                    dir = Functions.NextDir(dir);
                    if (target == Front) continue;

                    if (!CurrentMap.ValidPoint(target)) continue;

                    cell = CurrentMap.GetCell(target);

                    if (cell.Objects == null) continue;

                    for (int o = 0; o < cell.Objects.Count; o++)
                    {
                        MapObject ob = cell.Objects[o];
                        if (ob.Race != ObjectType.Player && ob.Race != ObjectType.Monster) continue;
                        if (!ob.IsAttackTarget(this)) continue;

                        if (ob.Race == ObjectType.Player)
                            damageFinal = magic.PvPGetDamage(damageBase);
                        else
                            damageFinal = magic.GetDamage(damageBase);

                        ob.Attacked(this, damageFinal, DefenceType.Agility, false);
                        break;
                    }
                }
            }

        CrossHalfMoon:
            if (spell == Spell.CrossHalfMoon)
            {
                magic = GetMagic(spell);
                for (int i = 0; i < 8; i++)
                {
                    target = Functions.PointMove(CurrentLocation, dir, 1);
                    dir = Functions.NextDir(dir);
                    if (target == Front) continue;

                    if (!CurrentMap.ValidPoint(target)) continue;

                    cell = CurrentMap.GetCell(target);

                    if (cell.Objects == null) continue;

                    for (int o = 0; o < cell.Objects.Count; o++)
                    {
                        MapObject ob = cell.Objects[o];
                        if (ob.Race != ObjectType.Player && ob.Race != ObjectType.Monster) continue;
                        if (!ob.IsAttackTarget(this)) continue;
                        if (ob.Race == ObjectType.Player)
                            damageFinal = magic.PvPGetDamage(damageBase);
                        else
                            damageFinal = magic.GetDamage(damageBase);

                        ob.Attacked(this, damageFinal, DefenceType.Agility, false);
                        break;
                    }
                }
            }

            WhirlWind:
            if (spell == Spell.WhirlWind)
            {
                magic = GetMagic(spell);
                for (int i = 0; i < 8; i++)
                {
                    target = Functions.PointMove(CurrentLocation, dir, 1);
                    dir = Functions.NextDir(dir);
                    if (target == Front) continue;

                    if (!CurrentMap.ValidPoint(target)) continue;

                    cell = CurrentMap.GetCell(target);

                    if (cell.Objects == null) continue;

                    for (int o = 0; o < cell.Objects.Count; o++)
                    {
                        MapObject ob = cell.Objects[o];
                        if (ob.Race != ObjectType.Player && ob.Race != ObjectType.Monster) continue;
                        if (!ob.IsAttackTarget(this)) continue;

                        if (ob.Race == ObjectType.Player)
                            damageFinal = magic.PvPGetDamage(damageBase);
                        else
                            damageFinal = magic.GetDamage(damageBase);
                        ob.Attacked(this, damageFinal / 2, DefenceType.MAC, false);
                        break;
                    }
                }
            }

            Mining:
            if (Mined)
            {
                if (Info.Equipment[(int)EquipmentSlot.Weapon] == null) return;
                if (!Info.Equipment[(int)EquipmentSlot.Weapon].Info.CanMine) return;
                if (Info.Equipment[(int)EquipmentSlot.Weapon].CurrentDura <= 0)//Stop dura 0 working. use below if you wish to break the item.
                /*{
                    Enqueue(new S.DeleteItem { UniqueID = Info.Equipment[(int)EquipmentSlot.Weapon].UniqueID, Count = Info.Equipment[(int)EquipmentSlot.Weapon].Count });
                    Info.Equipment[(int)EquipmentSlot.Weapon] = null;
                    RefreshStats();*/
                    return;
                /*}*/
                if (CurrentMap.Mine == null) return;
                MineSpot Mine = CurrentMap.Mine[target.X, target.Y];
                if ((Mine == null) || (Mine.Mine == null)) return;
                if (Mine.StonesLeft > 0)
                {
                    Mine.StonesLeft--;
                    if (Envir.Random.Next(100) < (Mine.Mine.HitRate + (Info.Equipment[(int)EquipmentSlot.Weapon].GetTotal(Stat.Accuracy)) * 10))
                    {
                        //create some rubble on the floor (or increase whats there)
                        SpellObject Rubble = null;
                        Cell minecell = CurrentMap.GetCell(CurrentLocation);
                        for (int i = 0; i < minecell.Objects.Count; i++)
                        {
                            if (minecell.Objects[i].Race != ObjectType.Spell) continue;
                            SpellObject ob = (SpellObject)minecell.Objects[i];

                            if (ob.Spell != Spell.Rubble) continue;
                            Rubble = ob;
                            Rubble.ExpireTime = Envir.Time + (5 * 60 * 1000);
                            break;
                        }
                        if (Rubble == null)
                        {
                            Rubble = new SpellObject
                            {
                                Spell = Spell.Rubble,
                                Value = 1,
                                ExpireTime = Envir.Time + (5 * 60 * 1000),
                                TickSpeed = 2000,
                                Caster = null,
                                CurrentLocation = CurrentLocation,
                                CurrentMap = this.CurrentMap,
                                Direction = MirDirection.Up
                            };
                            CurrentMap.AddObject(Rubble);
                            Rubble.Spawned();
                        }
                        if (Rubble != null)
                        {
                            ActionList.Add(new DelayedAction(DelayedType.Mine, Envir.Time + 400, Rubble));
                        }

                        //check if we get a payout
                        if (Envir.Random.Next(100) < (Mine.Mine.DropRate + Stats[Stat.MineRatePercent]))
                        {
                            GetMinePayout(Mine.Mine);
                        }

                        DamageItem(Info.Equipment[(int)EquipmentSlot.Weapon], 5 + Envir.Random.Next(15));
                    }
                }
                else
                {
                    if (Envir.Time > Mine.LastRegenTick)
                    {
                        Mine.LastRegenTick = Envir.Time + Mine.Mine.SpotRegenRate * 60 * 1000;
                        Mine.StonesLeft = (byte)Envir.Random.Next(Mine.Mine.MaxStones);
                    }
                }
            }
        }

        public void GetMinePayout(MineSet Mine)
        {
            if ((Mine.Drops == null) || (Mine.Drops.Count == 0)) return;
            if (FreeSpace(Info.Inventory) == 0) return;
            byte Slot = (byte)Envir.Random.Next(Mine.TotalSlots);
            for (int i = 0; i < Mine.Drops.Count; i++)
            {
                MineDrop Drop = Mine.Drops[i];
                if ((Drop.MinSlot <= Slot) && (Drop.MaxSlot >= Slot) && (Drop.Item != null))
                {
                    var info = Envir.GetItemInfo(Drop.Item.Index);

                    UserItem item = Envir.CreateDropItem(info);
                    if (item.Info.Type == ItemType.Ore)
                    {
                        item.CurrentDura = (ushort)Math.Min(ushort.MaxValue, (Drop.MinDura + Envir.Random.Next(Math.Max(0, Drop.MaxDura - Drop.MinDura))) * 1000);
                        if ((Drop.BonusChance > 0) && (Envir.Random.Next(100) <= Drop.BonusChance))
                            item.CurrentDura = (ushort)Math.Min(ushort.MaxValue, item.CurrentDura + (Envir.Random.Next(Drop.MaxBonusDura) * 1000));
                    }

                    if (CheckGroupQuestItem(item)) continue;

                    if (CanGainItem(item, false))
                    {
                        GainItem(item);
                        Report.ItemChanged(item, item.Count, 2);
                    }
                    return;
                }
            }

        }

        public void Magic(Spell spell, MirDirection dir, uint targetID, Point location)
        {
            if (!CanCast)
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            UserMagic magic = GetMagic(spell);

            if (magic == null)
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            if ((location.X != 0) && (location.Y != 0) && magic.Info.Range != 0 && Functions.InRange(CurrentLocation, location, magic.Info.Range) == false) return;

            if (Hidden)
            {
                RemoveBuff(BuffType.MoonLight);
                RemoveBuff(BuffType.DarkBody);
            }

            AttackTime = Envir.Time + MoveDelay;
            SpellTime = Envir.Time + 1800; //Spell Delay

            if (spell != Spell.ShoulderDash && spell != Spell.FlyingThrust)
            {
                ActionTime = Envir.Time + MoveDelay;
            }

            LogTime = Envir.Time + Globals.LogDelay;

            long delay = magic.GetDelay();

            if (magic != null && Envir.Time < (magic.CastTime + delay))
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            int cost = magic.Info.BaseCost + magic.Info.LevelCost * magic.Level;

            if (spell == Spell.Teleport || spell == Spell.Blink || spell == Spell.StormEscape)
            {
                if (Stats[Stat.TeleportManaPenaltyPercent] > 0)
                {
                    cost += (cost * Stats[Stat.TeleportManaPenaltyPercent]) / 100;
                }
            }

            if (Stats[Stat.ManaPenaltyPercent] > 0)
            {
                cost += (cost * Stats[Stat.ManaPenaltyPercent]) / 100;
            }
            
            if (spell == Spell.Plague)
            {
                cost = Stats[Stat.MaxSC] + Stats[Stat.MinSC];
            }
            
            if (cost > MP)
            {
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });
                return;
            }

            //RegenTime = Envir.Time + RegenDelay;
            RegenStandTime = Envir.Time + Settings.RegenStandDelay;
            ChangeMP(-cost);

            Direction = dir;
            if (spell != Spell.ShoulderDash && spell != Spell.FlyingThrust && spell != Spell.BackStep && spell != Spell.FlashDash)
                Enqueue(new S.UserLocation { Direction = Direction, Location = CurrentLocation });

            MapObject target = null;

            if (targetID == ObjectID)
            {
                target = this;
            }
            else if (targetID > 0)
            {
                target = FindObject(targetID, 10);
            }

            if (target != null && target.Race != ObjectType.Monster && target.Race != ObjectType.Player)
            {
                target = null;
            }

            bool cast = true;
            byte level = magic.Level;
            switch (spell)
            {
                case Spell.FlyingThrust:
                    FlyingThrust(magic);
                    return;
                case Spell.PheonixExplosion:
                    if (!PheonixExplosion(target, magic)) cast = true;
                    PheonixExplosion(magic, target == null ? location : target.CurrentLocation);
                    break;
                case Spell.AlmightyPush:
                    if (!AlmightyPush(target, magic)) targetID = 0;
                    break;
                case Spell.FireExplode:
                    if (!FireExplode(target, magic)) cast = true;
                    FireExplode(magic, target == null ? location : target.CurrentLocation);
                    break;
                case Spell.FireExplodeFW:
                    FireExplodeFW(magic, location, out cast);
                    break;
                case Spell.YinYangBurst:
                    YinYangBurst(target, magic);
                    break;
                case Spell.SwordsOfLight:
                    SwordsOfLight(magic, target == null ? location : target.CurrentLocation);
                    break;
                case Spell.HeavenAndHell:
                    HeavenAndHell(magic, location, out cast);
                    break;
                case Spell.FireBall:
                case Spell.GreatFireBall:
                case Spell.FrostCrunch:
                    if (!Fireball(target, magic)) targetID = 0;
                    break;
                case Spell.Healing:
                    if (target == null)
                    {
                        target = this;
                        targetID = ObjectID;
                    }
                    Healing(target, magic);
                    break;
                case Spell.Repulsion:
                case Spell.EnergyRepulsor:
                case Spell.FireBurst:
                    Repulsion(magic);
                    break;
                case Spell.ElectricShock:
                    ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, target as MonsterObject));
                    break;
                case Spell.Poisoning:
                    if (!Poisoning(target, magic)) cast = false;
                    break;
                case Spell.HellFire:
                    HellFire(magic);
                    break;
                case Spell.ThunderBolt:
                    ThunderBolt(target, magic);
                    break;
                case Spell.SoulFireBall:
                    if (!SoulFireball(target, magic, out cast)) targetID = 0;
                    break;
                case Spell.SummonSkeleton:
                    SummonSkeleton(magic);
                    break;
                case Spell.Teleport:
                case Spell.Blink:
                    ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 200, magic, location));
                    break;
                case Spell.Hiding:
                    Hiding(magic);
                    break;
                case Spell.Haste:
                case Spell.LightBody:
                    ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic));
                    break;
                case Spell.Fury:
                    FurySpell(magic, out cast);
                    break;
                case Spell.ImmortalSkin:
                    ImmortalSkin(magic, out cast);
                    break;
                case Spell.FireBang:
                case Spell.IceStorm:
                    FireBang(magic, target == null ? location : target.CurrentLocation);
                    break;
                case Spell.MassHiding:
                    MassHiding(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.SoulShield:
                    SoulShield(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.BlessedArmour:
                    BlessedArmour(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.FireWall:
                    FireWall(magic, target == null ? location : target.CurrentLocation);
                    break;
                case Spell.Lightning:
                    Lightning(magic);
                    break;
                case Spell.HeavenlySword:
                    HeavenlySword(magic);
                    break;
                case Spell.MassHealing:
                    MassHealing(magic, target == null ? location : target.CurrentLocation);
                    break;
                case Spell.ShoulderDash:
                    ShoulderDash(magic);
                    return;
                case Spell.ThunderStorm:
                case Spell.FlameField:
                case Spell.StormEscape:
                    ThunderStorm(magic);
                    if (spell == Spell.FlameField)
                        SpellTime = Envir.Time + 2500; //Spell Delay
                    if (spell == Spell.StormEscape)
                        //Start teleport.
                        ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 750, magic, location));
                    break;
                case Spell.MagicShield:
                    ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, magic.GetPower(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]) + 15)));
                    break;
                case Spell.FlameDisruptor:
                    FlameDisruptor(target, magic);
                    break;
                case Spell.TurnUndead:
                    TurnUndead(target, magic);
                    break;
                case Spell.MagicBooster:
                    MagicBooster(magic);
                    break;
                case Spell.Vampirism:
                    Vampirism(target, magic);
                    break;
                case Spell.SummonShinsu:
                    SummonShinsu(magic);
                    break;
                case Spell.Purification:
                    if (target == null)
                    {
                        target = this;
                        targetID = ObjectID;
                    }
                    Purification(target, magic);
                    break;
                case Spell.LionRoar:
                case Spell.BattleCry:
                    CurrentMap.ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, CurrentLocation));
                    break;
                case Spell.Revelation:
                    Revelation(target, magic);
                    break;
                case Spell.PoisonCloud:
                    PoisonCloud(magic, location, out cast);
                    break;
                case Spell.Entrapment:
                    Entrapment(target, magic);
                    break;
                case Spell.BladeAvalanche:
                    BladeAvalanche(magic);
                    break;
                case Spell.SlashingBurst:
                    SlashingBurst(magic, out cast);
                    break;
                case Spell.Rage:
                    Rage(magic);
                    break;
                case Spell.Mirroring:
                    Mirroring(magic);
                    break;
                case Spell.Blizzard:
                    Blizzard(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.MeteorStrike:
                    MeteorStrike(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.IceThrust:
                    IceThrust(magic);
                    break;

                case Spell.ProtectionField:
                    ProtectionField(magic);
                    break;
                case Spell.PetEnhancer:
                    PetEnhancer(target, magic, out cast);
                    break;
                case Spell.TrapHexagon:
                    TrapHexagon(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.Reincarnation:
                    if (!CurrentMap.Info.NoReincarnation)
                        Reincarnation(magic, target == null ? null : target as PlayerObject, out cast);
                    break;
                case Spell.Curse:
                    Curse(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.SummonHolyDeva:
                    SummonHolyDeva(magic);
                    break;
                case Spell.Hallucination:
                    Hallucination(target, magic);
                    break;
                case Spell.EnergyShield:
                    EnergyShield(target, magic, out cast);
                    break;
                case Spell.UltimateEnhancer:
                    UltimateEnhancer(target, magic, out cast);
                    break;
                case Spell.Plague:
                    Plague(magic, target == null ? location : target.CurrentLocation, out cast);
                    break;
                case Spell.SwiftFeet:
                    SwiftFeet(magic, out cast);
                    break;
                case Spell.MoonLight:
                    MoonLight(magic);
                    break;
                case Spell.Trap:
                    Trap(magic, target, out cast);
                    break;
                case Spell.PoisonSword:
                    PoisonSword(magic);
                    break;
                case Spell.DarkBody:
                    DarkBody(target, magic);
                    break;
                case Spell.FlashDash:
                    FlashDash(magic);
                    return;
                case Spell.CrescentSlash:
                    CrescentSlash(magic);
                    break;
                case Spell.StraightShot:
                    if (!StraightShot(target, magic)) targetID = 0;
                    break;
                case Spell.DoubleShot:
                    if (!DoubleShot(target, magic)) targetID = 0;
                    break;
                case Spell.BackStep:
                    BackStep(magic);
                    return;
                case Spell.ExplosiveTrap:
                    ExplosiveTrap(magic, Front);
                    break;
                case Spell.DelayedExplosion:
                    if (!DelayedExplosion(target, magic)) targetID = 0;
                    break;
                case Spell.Concentration:
                    Concentration(magic);
                    break;
                case Spell.ElementalShot:
                    if (!ElementalShot(target, magic)) targetID = 0;
                    break;
                case Spell.ElementalBarrier:
                    ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, magic.GetPower(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]))));
                    break;
                case Spell.BindingShot:
                    BindingShot(magic, target, out cast);
                    break;
                case Spell.SummonVampire:
                case Spell.SummonToad:
                case Spell.SummonSnakes:
                    ArcherSummon(magic, target, location);
                    break;
                case Spell.VampireShot:
                case Spell.PoisonShot:
                case Spell.CrippleShot:
                    SpecialArrowShot(target, magic);
                    break;
                case Spell.NapalmShot:
                    NapalmShot(target, magic);
                    break;
                case Spell.OneWithNature:
                    OneWithNature(target, magic);
                    break;

                //Custom Spells
                case Spell.Portal:
                    Portal(magic, location, out cast);
                    break;
                case Spell.MeteorShower:
                    if (!MeteorShower(target, magic)) targetID = 0;
                    return;
                case Spell.FireBounce:
                    if (!FireBounce(target, magic, this)) targetID = 0;
                    break;
                default:
                    cast = false;
                    break;
            }

            if (cast)
            {
                magic.CastTime = Envir.Time;
            }

            Enqueue(new S.Magic { Spell = spell, TargetID = targetID, Target = location, Cast = cast, Level = level });
            Broadcast(new S.ObjectMagic { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation, Spell = spell, TargetID = targetID, Target = location, Cast = cast, Level = level });
        }

        #region Elemental System
        private void Concentration(UserMagic magic)
        {
            int duration = 45 + (15 * magic.Level);

            var buff = AddBuff(BuffType.Concentration, this, Settings.Second * duration, new Stats());

            buff.Set("InterruptTime", (long)0);
            buff.Set("Interrupted", false);

            LevelMagic(magic);
            OperateTime = 0;

            UpdateConcentration(true, false);
        }

        public void UpdateConcentration(bool concentrating, bool interrupted)
        {
            Enqueue(new S.SetConcentration { ObjectID = ObjectID, Enabled = concentrating, Interrupted = interrupted });
            Broadcast(new S.SetConcentration { ObjectID = ObjectID, Enabled = concentrating, Interrupted = interrupted });
        }

        private bool ElementalShot(MapObject target, UserMagic magic)
        {
            if (HasElemental)
            {
                if (target == null || !target.IsAttackTarget(this)) return false;
                if ((Info.MentalState != 1) && !CanFly(target.CurrentLocation)) return false;

                int orbPower = GetElementalOrbPower(false);//base power + orbpower

                int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]) + orbPower);
                int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

                DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, target.CurrentLocation);
                ActionList.Add(action);
            }
            else
            {
                ObtainElement(true);//gather orb through casting
                LevelMagic(magic);
                return false;
            }
            return true;
        }

        public void GatherElement()
        {
            UserMagic magic = GetMagic(Spell.Meditation);

            if (magic == null) return;

            int meditationLvl = magic.Level;
            int concentrateChance = 0;

            if (HasBuff(BuffType.Concentration, out Buff concentration) && !concentration.Get<bool>("Interrupted"))
            {
                magic = GetMagic(Spell.Concentration);

                if (magic != null)
                {
                    concentrateChance = magic.Level + 1;
                }
            }

            if (meditationLvl >= 0)
            {
                int rnd = Envir.Random.Next(10);
                if (rnd >= (8 - meditationLvl - concentrateChance))
                {
                    ObtainElement(false);
                    LevelMagic(GetMagic(Spell.Meditation));
                }
            }
        }

        public void ObtainElement(bool cast)
        {
            int orbType = 0;
            int meditateLevel = 0;

            UserMagic spell = GetMagic(Spell.Meditation);

            if (spell == null)
            {
                ReceiveChat("Skill requires meditation.", ChatType.System);
                return;
            }

            meditateLevel = spell.Level;

            int maxOrbs = (int)Settings.OrbsExpList[Settings.OrbsExpList.Count - 1];

            if (cast)
            {
                ElementsLevel = (int)Settings.OrbsExpList[0];
                orbType = 1;
                if (Settings.GatherOrbsPerLevel)//Meditation Orbs per level
                    if (meditateLevel == 3)
                    {
                        Enqueue(new S.SetElemental { ObjectID = ObjectID, Enabled = true, Value = (uint)Settings.OrbsExpList[0], ElementType = 1, ExpLast = (uint)maxOrbs });
                        Broadcast(new S.SetElemental { ObjectID = ObjectID, Enabled = true, Casted = true, Value = (uint)Settings.OrbsExpList[0], ElementType = 1, ExpLast = (uint)maxOrbs });
                        ElementsLevel = (int)Settings.OrbsExpList[1];
                        orbType = 2;
                    }

                HasElemental = true;
            }
            else
            {
                HasElemental = false;
                ElementsLevel++;

                if (Settings.GatherOrbsPerLevel)//Meditation Orbs per level
                    if (ElementsLevel > Settings.OrbsExpList[GetMagic(Spell.Meditation).Level])
                    {
                        HasElemental = true;
                        ElementsLevel = (int)Settings.OrbsExpList[GetMagic(Spell.Meditation).Level];
                        return;
                    }

                if (ElementsLevel >= Settings.OrbsExpList[0]) HasElemental = true;
                for (int i = 0; i <= Settings.OrbsExpList.Count - 1; i++)
                {
                    if (Settings.OrbsExpList[i] != ElementsLevel) continue;
                    orbType = i + 1;
                    break;
                }
            }

            Enqueue(new S.SetElemental { ObjectID = ObjectID, Enabled = HasElemental, Value = (uint)ElementsLevel, ElementType = (uint)orbType, ExpLast = (uint)maxOrbs });
            Broadcast(new S.SetElemental { ObjectID = ObjectID, Enabled = HasElemental, Casted = cast, Value = (uint)ElementsLevel, ElementType = (uint)orbType, ExpLast = (uint)maxOrbs });
        }

        public int GetElementalOrbCount()
        {
            int OrbCount = 0;
            for (int i = Settings.OrbsExpList.Count - 1; i >= 0; i--)
            {
                if (ElementsLevel >= Settings.OrbsExpList[i])
                {
                    OrbCount = i + 1;
                    break;
                }
            }
            return OrbCount;
        }
        public int GetElementalOrbPower(bool defensive)
        {
            if (!HasElemental) return 0;

            if (defensive)
                return (int)Settings.OrbsDefList[GetElementalOrbCount() - 1];

            if (!defensive)
                return (int)Settings.OrbsDmgList[GetElementalOrbCount() - 1];

            return 0;
        }
        #endregion

        #region Wizard Skills
        private bool PheonixExplosion(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation)) return false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, PvPDamage);

            ActionList.Add(action);

            return true;
        }
        private bool AlmightyPush(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation)) return false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, PvPDamage);
            ActionList.Add(action);

            return true;
        }
        private void PheonixExplosion(UserMagic magic, Point location)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 800, this, magic, damage / 2, location, PvPDamage / 2);
            CurrentMap.ActionList.Add(action);
        }
        private bool FireExplode(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation)) return false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, PvPDamage);

            ActionList.Add(action);

            return true;
        }
        private void FireExplode(UserMagic magic, Point location)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 800, this, magic, damage / 2, location, PvPDamage / 2);
            CurrentMap.ActionList.Add(action);
        }
        private void FireExplodeFW(UserMagic magic, Point location, out bool cast)
        {
            cast = false;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, damage / 2, location, PvPDamage / 2);

            CurrentMap.ActionList.Add(action);
            cast = true;
        }
        private void FireExplode(UserMagic magic, out bool cast)
        {
            cast = true;

            ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic));

        }

        private void FireWall(UserMagic magic, out bool cast)
        {
            cast = false;

            ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic));

        }
        private bool Fireball(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation)) return false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, pvpDamage, target, target.CurrentLocation);

            ActionList.Add(action);

            return true;
        }
        private void Repulsion(UserMagic magic)
        {
            bool result = false;
            for (int d = 0; d <= 1; d++)
            {
                for (int y = CurrentLocation.Y - d; y <= CurrentLocation.Y + d; y++)
                {
                    if (y < 0) continue;
                    if (y >= CurrentMap.Height) break;

                    for (int x = CurrentLocation.X - d; x <= CurrentLocation.X + d; x += Math.Abs(y - CurrentLocation.Y) == d ? 1 : d * 2)
                    {
                        if (x < 0) continue;
                        if (x >= CurrentMap.Width) break;

                        Cell cell = CurrentMap.GetCell(x, y);
                        if (!cell.Valid || cell.Objects == null) continue;

                        for (int i = 0; cell.Objects != null && i < cell.Objects.Count; i++)
                        {
                            MapObject ob = cell.Objects[i];
                            if (ob.Race != ObjectType.Monster && ob.Race != ObjectType.Player) continue;

                            if (!ob.IsAttackTarget(this) || ob.Level >= Level) continue;

                            if (Envir.Random.Next(20) >= 6 + magic.Level * 3 + Level - ob.Level) continue;

                            int distance = 1 + Math.Max(0, magic.Level - 1) + Envir.Random.Next(2);
                            MirDirection dir = Functions.DirectionFromPoint(CurrentLocation, ob.CurrentLocation);

                            if (ob.Pushed(this, dir, distance) == 0) continue;

                            if (ob.Race == ObjectType.Player)
                            {
                                SafeZoneInfo szi = CurrentMap.GetSafeZone(ob.CurrentLocation);

                                if (szi != null)
                                {
                                    ((PlayerObject)ob).BindLocation = szi.Location;
                                    ((PlayerObject)ob).BindMapIndex = CurrentMapIndex;
                                    ob.InSafeZone = true;
                                }
                                else
                                    ob.InSafeZone = false;

                                ob.Attacked(this, magic.GetDamage(0), DefenceType.None, false);
                            }
                            result = true;
                        }
                    }
                }
            }

            if (result) LevelMagic(magic);
        }
        private void ElectricShock(MonsterObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return;

            if (Envir.Random.Next(4 - magic.Level) > 0)
            {
                if (Envir.Random.Next(2) == 0) LevelMagic(magic);
                return;
            }

            LevelMagic(magic);

            if (target.Master == this)
            {
                target.ShockTime = Envir.Time + (magic.Level * 5 + 10) * 1000;
                target.Target = null;
                return;
            }

            if (Envir.Random.Next(2) > 0)
            {
                target.ShockTime = Envir.Time + (magic.Level * 5 + 10) * 1000;
                target.Target = null;
                return;
            }

            if (target.Level > Level + 2 || !target.Info.CanTame) return;

            if (Envir.Random.Next(Level + 20 + magic.Level * 5) <= target.Level + 10)
            {
                if (Envir.Random.Next(5) > 0 && target.Master == null)
                {
                    target.RageTime = Envir.Time + (Envir.Random.Next(20) + 10) * 1000;
                    target.Target = null;
                }
                return;
            }

            if (Pets.Count(t => !t.Dead && t.GetType() != typeof(IntelligentCreatureObject)) >= magic.Level + 2) return;

            int rate = (int)(target.Stats[Stat.HP] / 100);
            if (rate <= 2) rate = 2;
            else rate *= 2;

            if (Envir.Random.Next(rate) != 0) return;
            //else if (Envir.Random.Next(20) == 0) target.Die();

            if (target.Master != null)
            {
                target.SetHP(target.Stats[Stat.HP] / 10);
                target.Master.Pets.Remove(target);
            }
            else if (target.Respawn != null)
            {
                target.Respawn.Count--;
                Envir.MonsterCount--;
                CurrentMap.MonsterCount--;
                target.Respawn = null;
            }

            target.Master = this;
            //target.HealthChanged = true;
            target.BroadcastHealthChange();
            Pets.Add(target);
            target.Target = null;
            target.RageTime = 0;
            target.ShockTime = 0;
            target.OperateTime = 0;
            target.MaxPetLevel = (byte)(1 + magic.Level * 2);

            if (!Settings.PetSave)
            {
                target.TameTime = Envir.Time + (Settings.Minute * 60);
            }

            target.Broadcast(new S.ObjectName { ObjectID = target.ObjectID, Name = target.Name });
        }
        private void HellFire(UserMagic magic)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, pvpDamage, CurrentLocation, Direction, 4);
            CurrentMap.ActionList.Add(action);

            if (magic.Level != 3) return;

            MirDirection dir = (MirDirection)(((int)Direction + 1) % 8);
            action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, CurrentLocation, dir, 4);
            CurrentMap.ActionList.Add(action);

            dir = (MirDirection)(((int)Direction - 1 + 8) % 8);
            action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, CurrentLocation, dir, 4);
            CurrentMap.ActionList.Add(action);
        }
        private void ThunderBolt(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            if (target.Undead) damage = (int)(damage * 1.5F);

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, damage, pvpDamage, target, target.CurrentLocation);

            ActionList.Add(action);
        }
        private void Vampirism(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, damage, pvpDamage, target);

            ActionList.Add(action);
        }
        private void FireBang(UserMagic magic, Point location)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, pvpDamage, damage, location);
            CurrentMap.ActionList.Add(action);
        }
        private void FireWall(UserMagic magic, Point location)
        {
            if (CurrentMap.Info.FireWall)
            {
                var currentFirewalls = Envir.GetObjects(CurrentMapIndex, ObjectType.Spell).Count(x => (((SpellObject)x).Spell == Spell.FireWall) && ((SpellObject)x).Caster == this);
                //var currentFirewalls = Envir.Spells.Count(x => x.Spell == Spell.FireWall && x.Caster == this);

                if (currentFirewalls >= (CurrentMap.Info.FireWallCount))
                {
                    ReceiveChat(("Max firewalls reached on this map."), ChatType.System);
                    return;
                }
            }
            
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, location, pvpDamage);
            CurrentMap.ActionList.Add(action);
        }
        private void Lightning(UserMagic magic)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, pvpDamage, CurrentLocation, Direction);
            CurrentMap.ActionList.Add(action);
        }
        private void TurnUndead(MapObject target, UserMagic magic)
        {
            if (target == null || target.Race != ObjectType.Monster || !target.Undead || !target.IsAttackTarget(this)) return;

            if (Envir.Random.Next(2) + Level - 1 <= target.Level)
            {
                target.Target = this;
                return;
            }

            int dif = Level - target.Level + 15;

            if (Envir.Random.Next(100) >= (magic.Level + 1 << 3) + dif)
            {
                target.Target = this;
                return;
            }

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, target);
            ActionList.Add(action);
        }
        private void FlameDisruptor(MapObject target, UserMagic magic)
        {
            if (target == null || (target.Race != ObjectType.Player && target.Race != ObjectType.Monster) || !target.IsAttackTarget(this)) return;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            if (!target.Undead) damage = (int)(damage * 1.5F);

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, damage, pvpDamage, target, target.CurrentLocation);

            ActionList.Add(action);
        }
        private void ThunderStorm(UserMagic magic)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, pvpDamage, CurrentLocation);
            CurrentMap.ActionList.Add(action);
        }
        private void Mirroring(UserMagic magic)
        {
            MonsterObject monster;
            DelayedAction action;
            for (int i = 0; i < Pets.Count; i++)
            {
                monster = Pets[i];
                if ((monster.Info.Name != Settings.CloneName) || monster.Dead) continue;
                if (monster.Node == null) continue;
                action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, monster, Front, true);
                CurrentMap.ActionList.Add(action);
                return;
            }

            MonsterInfo info = Envir.GetMonsterInfo(Settings.CloneName);
            if (info == null) return;


            LevelMagic(magic);

            monster = MonsterObject.GetMonster(info);
            monster.Master = this;
            monster.ActionTime = Envir.Time + 1000;
            monster.RefreshNameColour(false);

            Pets.Add(monster);

            action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, monster, Front, false);
            CurrentMap.ActionList.Add(action);
        }
        private void Blizzard(UserMagic magic, Point location, out bool cast)
        {
            cast = false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, pvpDamage, location);

            ActiveBlizzard = true;
            CurrentMap.ActionList.Add(action);
            cast = true;
        }
        private void MeteorStrike(UserMagic magic, Point location, out bool cast)
        {
            cast = false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, pvpDamage, location);

            ActiveBlizzard = true;
            CurrentMap.ActionList.Add(action);
            cast = true;
        }

        private void IceThrust(UserMagic magic)
        {
            int damageBase = GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]);
            if (Envir.Random.Next(100) < (1 + Stats[Stat.Luck]))
                damageBase += damageBase;
            int damageFinish = magic.GetDamage(damageBase);
            int PvPDamage = magic.PvPGetDamage(damageBase);

            Point location = Functions.PointMove(CurrentLocation, Direction, 1);

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 1500, this, magic, location, Direction, damageFinish, (int)(damageFinish * 0.6), PvPDamage);

            CurrentMap.ActionList.Add(action);
        }

        private void MagicBooster(UserMagic magic)
        {
            int MBRate = magic.Level == 0 ? Settings.MBRateLv0 : magic.Level == 1 ? Settings.MBRateLv1 : magic.Level == 2 ? Settings.MBRateLv2 : Settings.MBRateLv3;
            int duration = magic.Level == 0 ? Settings.MBTimeLv0 : magic.Level == 1 ? Settings.MBTimeLv1 : magic.Level == 2 ? Settings.MBTimeLv2 : Settings.MBTimeLv3;
            int addValue = (int)(Stats[Stat.MaxMC] * MBRate / 100);

            int ManaRate = magic.Level == 0 ? Settings.ManaRateLv0 : magic.Level == 1 ? Settings.ManaRateLv1 : magic.Level == 2 ? Settings.ManaRateLv2 : Settings.ManaRateLv3;
            int AddManaPenalty = Stats[Stat.ManaPenaltyPercent] + ManaRate;

            AddBuff(BuffType.MagicBooster, this, Settings.Second * duration, new Stats { [Stat.MaxMC] = addValue, [Stat.MinMC] = addValue, [Stat.ManaPenaltyPercent] = AddManaPenalty });
            LevelMagic(magic);
        }

        #endregion

        #region Taoist Skills
        private void YinYangBurst(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, damage, target, PvPDamage);

            ActionList.Add(action);
        }
        private void SwordsOfLight(UserMagic magic, Point location)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, location, PvPDamage);
            CurrentMap.ActionList.Add(action);
        }
        private void HeavenAndHell(UserMagic magic, Point location, out bool cast)
        {
            cast = false;

            UserItem amulet = GetAmulet(5);
            if (amulet == null) return;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, damage, location, PvPDamage);

            ConsumeItem(amulet, 5);

            CurrentMap.ActionList.Add(action);
            cast = true;
        }
        private void PoisonCloud(UserMagic magic, Point location, out bool cast)
        {
            cast = false;

            UserItem amulet = GetAmulet(5);
            if (amulet == null) return;

            UserItem poison = GetPoison(5, 1);
            if (poison == null) return;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int PvPDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, damage, location, (byte)Envir.Random.Next(Stats[Stat.PoisonAttack]), PvPDamage);

            ConsumeItem(amulet, 5);
            ConsumeItem(poison, 5);

            CurrentMap.ActionList.Add(action);
            cast = true;
        }
        private void Healing(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsFriendlyTarget(this)) return;

            int health = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]) * 2) + Level;

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, health, target);

            ActionList.Add(action);
        }
        private bool Poisoning(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return false;

            UserItem item = GetPoison(1);
            if (item == null) return false;

            int power = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int pvppower = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, power, pvppower, target, item);
            ActionList.Add(action);
            ConsumeItem(item, 1);
            return true;
        }
        private bool SoulFireball(MapObject target, UserMagic magic, out bool cast)
        {
            cast = false;
            UserItem item = GetAmulet(1);
            if (item == null) return false;
            cast = true;

            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation)) return false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, pvpDamage, target, target.CurrentLocation);

            ActionList.Add(action);
            ConsumeItem(item, 1);

            return true;
        }
        private void SummonSkeleton(UserMagic magic)
        {
            if (CurrentMap.Info.NoPets)
            {
                ReceiveChat(("You cannot use Pets on this map"), ChatType.System);
                return;
            }

            MonsterObject monster;
            for (int i = 0; i < Pets.Count; i++)
            {
                monster = Pets[i];
                if ((monster.Info.Name != Settings.SkeletonName0 && 
                     monster.Info.Name != Settings.SkeletonName1 && 
                     monster.Info.Name != Settings.SkeletonName2 && 
                     monster.Info.Name != Settings.SkeletonName3) || monster.Dead) continue;
                if (monster.Node == null) continue;
                monster.ActionList.Add(new DelayedAction(DelayedType.Recall, Envir.Time + 500));
                return;
            }

            if (Pets.Where(x => x.Race == ObjectType.Monster).Count() > 1) return;

            UserItem item = GetAmulet(1);
            if (item == null) return;

            MonsterInfo info;
            if (magic.Level == 3)
                info = Envir.GetMonsterInfo(Settings.SkeletonName3);
            else
            if (magic.Level == 2)
                info = Envir.GetMonsterInfo(Settings.SkeletonName2);
            else
            if (magic.Level == 1)
                info = Envir.GetMonsterInfo(Settings.SkeletonName1);
            else
                info = Envir.GetMonsterInfo(Settings.SkeletonName0);

            if (info == null) return;

            LevelMagic(magic);
            ConsumeItem(item, 1);

            monster = MonsterObject.GetMonster(info);
            monster.PetLevel = magic.Level;
            monster.Master = this;
            monster.MaxPetLevel = (byte)(4 + magic.Level);
            monster.ActionTime = Envir.Time + 1000;
            monster.RefreshNameColour(false);

            //Pets.Add(monster);

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, monster, Front);
            CurrentMap.ActionList.Add(action);
        }
        private void Purification(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsFriendlyTarget(this)) return;

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, target);

            ActionList.Add(action);
        }
        private void SummonShinsu(UserMagic magic)
        {
            if (CurrentMap.Info.NoPets)
            {
                ReceiveChat(("You cannot use Pets on this map"), ChatType.System);
                return;
            }
            MonsterObject monster;
            for (int i = 0; i < Pets.Count; i++)
            {
                monster = Pets[i];
                if ((monster.Info.Name != Settings.ShinsuName0 && 
                     monster.Info.Name != Settings.ShinsuName2 &&
                     monster.Info.Name != Settings.ShinsuName4 &&
                     monster.Info.Name != Settings.ShinsuName6) || monster.Dead) continue;
                if (monster.Node == null) continue;
                monster.ActionList.Add(new DelayedAction(DelayedType.Recall, Envir.Time + 500));
                return;
            }

            if (Pets.Where(x => x.Race == ObjectType.Monster).Count() > 1) return;

            UserItem item = GetAmulet(5);
            if (item == null) return;

            MonsterInfo info;
            if (magic.Level == 3)
                info = Envir.GetMonsterInfo(Settings.ShinsuName6);
            else
            if (magic.Level == 2)
                info = Envir.GetMonsterInfo(Settings.ShinsuName4);
            else
            if (magic.Level == 1)
                info = Envir.GetMonsterInfo(Settings.ShinsuName2);
            else
                info = Envir.GetMonsterInfo(Settings.ShinsuName0);

            if (info == null) return;

            LevelMagic(magic);
            ConsumeItem(item, 5);

            monster = MonsterObject.GetMonster(info);
            monster.PetLevel = magic.Level;
            monster.Master = this;
            monster.MaxPetLevel = (byte)(1 + magic.Level * 2);
            monster.Direction = Direction;
            monster.ActionTime = Envir.Time + 1000;

            //Pets.Add(monster);

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, monster, Front);
            CurrentMap.ActionList.Add(action);
        }
        private void Hiding(UserMagic magic)
        {
            UserItem item = GetAmulet(1);
            if (item == null) return;

            ConsumeItem(item, 1);

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]) + (magic.Level + 1) * 5);
            ActionList.Add(action);

        }
        private void MassHiding(UserMagic magic, Point location, out bool cast)
        {
            cast = false;
            UserItem item = GetAmulet(1);
            if (item == null) return;
            cast = true;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]) / 2 + (magic.Level + 1) * 2, location);
            CurrentMap.ActionList.Add(action);
        }
        private void SoulShield(UserMagic magic, Point location, out bool cast)
        {
            cast = false;
            UserItem item = GetAmulet(1);
            if (item == null) return;
            cast = true;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step

            int ExpireTime = magic.Level == 0 ? Settings.SoulShieldTimeLv0 : magic.Level == 1 ? Settings.SoulShieldTimeLv1 : magic.Level == 2 ? Settings.SoulShieldTimeLv2 : Settings.SoulShieldTimeLv3;
            int SSRate = magic.Level == 0 ? Settings.SoulShieldRateLv0 : magic.Level == 1 ? Settings.SoulShieldRateLv1 : magic.Level == 2 ? Settings.SoulShieldRateLv2 : Settings.SoulShieldRateLv3;
            int value2 = (int)(Stats[Stat.MaxSC] * SSRate / 100);

            AddBuff(BuffType.SoulShield, this, Settings.Second * ExpireTime, new Stats { [Stat.MaxAC] = value2, [Stat.MinAC] = value2 });

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, ExpireTime, location, value2);
            CurrentMap.ActionList.Add(action);

            ConsumeItem(item, 1);
        }
        private void BlessedArmour(UserMagic magic, Point location, out bool cast)
        {
            cast = false;
            UserItem item = GetAmulet(1);
            if (item == null) return;
            cast = true;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step

            int ExpireTime = magic.Level == 0 ? Settings.BlessedArmourTimeLv0 : magic.Level == 1 ? Settings.BlessedArmourTimeLv1 : magic.Level == 2 ? Settings.BlessedArmourTimeLv2 : Settings.BlessedArmourTimeLv3;
            int BARate = magic.Level == 0 ? Settings.BlessedArmourRateLv0 : magic.Level == 1 ? Settings.BlessedArmourRateLv1 : magic.Level == 2 ? Settings.BlessedArmourRateLv2 : Settings.BlessedArmourRateLv3;
            int value2 = (int)(Stats[Stat.MaxSC] * BARate / 100);

            AddBuff(BuffType.BlessedArmour, this, Settings.Second * ExpireTime, new Stats { [Stat.MaxMAC] = value2, [Stat.MinMAC] = value2 });

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, ExpireTime, location, value2);
            CurrentMap.ActionList.Add(action);

            ConsumeItem(item, 1);
        }
        private void MassHealing(UserMagic magic, Point location)
        {
            int value = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, value, location);
            CurrentMap.ActionList.Add(action);
        }
        private void Revelation(MapObject target, UserMagic magic)
        {
            if (target == null) return;

            int value = GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]) + magic.GetPower();

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, value, target);

            ActionList.Add(action);
        }
        private void TrapHexagon(UserMagic magic, Point location, out bool cast)
        {
            cast = false;
            bool anyTargetsFound = false;
            for (int x = location.X - 1; x <= location.X + 1; x++)
            {
                if (x < 0 || x >= CurrentMap.Width) continue;
                for (int y = location.Y - 1; y < location.Y + 1; y++)
                {
                    if (y < 0 || y >= CurrentMap.Height) continue;
                    if (!CurrentMap.ValidPoint(x, y)) continue;
                    var cell = CurrentMap.GetCell(x, y);
                    if (cell == null ||
                        cell.Objects == null ||
                        cell.Objects.Count <= 0) continue;
                    foreach (var target in cell.Objects)
                    {
                        switch (target.Race)
                        {
                            case ObjectType.Monster:
                                if (!target.IsAttackTarget(this)) continue;
                                if (target.Level > Level + 2) continue;
                                anyTargetsFound = true;
                                break;
                        }
                    }
                }
            }
            if (!anyTargetsFound)
                return;

            UserItem item = GetAmulet(1);
            //Point location = target.CurrentLocation;

            if (item == null) return;

            LevelMagic(magic);
            uint duration = (uint)((magic.Level * 5 + 10) * 1000);
            int value = (int)duration;

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, value, location);
            CurrentMap.ActionList.Add(action);

            ConsumeItem(item, 1);
            cast = true;
        }
        private void Reincarnation(UserMagic magic, PlayerObject target, out bool cast)
        {
            cast = true;

            if (target == null || !target.Dead) return;

            // checks for amulet of revival
            UserItem item = GetAmulet(1, 3);
            if (item == null) return;

            if (!ActiveReincarnation && !ReincarnationReady)
            {
                cast = false;
                int CastTime = Math.Abs(((magic.Level + 1) * 1000) - 9000);
                ExpireTime = Envir.Time + CastTime;
                ReincarnationReady = true;
                ActiveReincarnation = true;
                ReincarnationTarget = target;
                ReincarnationExpireTime = ExpireTime + 5000;

                target.ReincarnationHost = this;

                SpellObject ob = new SpellObject
                {
                    Spell = Spell.Reincarnation,
                    ExpireTime = ExpireTime,
                    TickSpeed = 1000,
                    Caster = this,
                    CurrentLocation = CurrentLocation,
                    CastLocation = CurrentLocation,
                    Show = true,
                    CurrentMap = CurrentMap,
                };
                Packet p = new S.Chat { Message = string.Format("{0} is attempting to revive {1}", Name, target.Name), Type = ChatType.Shout };

                for (int i = 0; i < CurrentMap.Players.Count; i++)
                {
                    if (!Functions.InRange(CurrentLocation, CurrentMap.Players[i].CurrentLocation, Globals.DataRange * 2)) continue;
                    CurrentMap.Players[i].Enqueue(p);
                }

                CurrentMap.AddObject(ob);
                ob.Spawned();
                ConsumeItem(item, 1);
                // chance of failing Reincarnation when casting
                if (Envir.Random.Next(30) > (1 + magic.Level) * 10)
                {
                    return;
                }

                DelayedAction action = new DelayedAction(DelayedType.Magic, ExpireTime, magic);

                ActionList.Add(action);
                return;
            }
            return;
        }
        private void SummonHolyDeva(UserMagic magic)
        {
            if (CurrentMap.Info.NoPets)
            {
                ReceiveChat(("You cannot use Pets on this map"), ChatType.System);
                return;
            }
            MonsterObject monster;
            for (int i = 0; i < Pets.Count; i++)
            {
                monster = Pets[i];
                if ((monster.Info.Name != Settings.AngelName) || monster.Dead) continue;
                if (monster.Node == null) continue;
                monster.ActionList.Add(new DelayedAction(DelayedType.Recall, Envir.Time + 500));
                return;
            }

            if (Pets.Where(x => x.Race == ObjectType.Monster).Count() > 1) return;

            UserItem item = GetAmulet(2);
            if (item == null) return;

            MonsterInfo info = Envir.GetMonsterInfo(Settings.AngelName);
            if (info == null) return;

            LevelMagic(magic);
            ConsumeItem(item, 2);

            monster = MonsterObject.GetMonster(info);
            monster.PetLevel = magic.Level;
            monster.Master = this;
            monster.MaxPetLevel = (byte)(1 + magic.Level * 2);
            monster.Direction = Direction;
            monster.ActionTime = Envir.Time + 1000;

            //Pets.Add(monster);

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 1500, this, magic, monster, Front);
            CurrentMap.ActionList.Add(action);
        }
        private void Hallucination(MapObject target, UserMagic magic)
        {
            if (target == null || target.Race != ObjectType.Monster || !target.IsAttackTarget(this)) return;

            int damage = 0;
            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, delay, magic, damage, target);

            ActionList.Add(action);
        }
        private void EnergyShield(MapObject target, UserMagic magic, out bool cast)
        {
            cast = false;
            
            if (target == null || !target.IsFriendlyTarget(this)) target = this; //offical is only party target

            int duration = 30 + 50 * magic.Level;
            int power = magic.GetPower(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            int chance = (10 - (Stats[Stat.Luck] / 3 + magic.Level + 1));

            if (chance < 2) chance = 2;

            var stats = new Stats 
            { 
                [Stat.EnergyShieldPercent] = (int)Math.Round((1 / (decimal)chance) * 100), 
                [Stat.EnergyShieldHPGain] = power 
            };

            switch (target.Race)
            {
                case ObjectType.Player:
                    //Only targets
                    if (target.IsFriendlyTarget(this))
                    {
                        target.AddBuff(BuffType.EnergyShield, this, (Settings.Second * duration), stats);
                        target.OperateTime = 0;
                        LevelMagic(magic);
                        cast = true;
                    }
                    break;
            }
        }
        private void UltimateEnhancer(MapObject target, UserMagic magic, out bool cast)
        {
            cast = false;

            if (target == null || !target.IsFriendlyTarget(this)) return;
            UserItem item = GetAmulet(1);
            if (item == null) return;

            int expiretime = magic.Level == 0 ? Settings.UltimateEnhancerTimeLv0 : magic.Level == 1 ? Settings.UltimateEnhancerTimeLv1 : magic.Level == 2 ? Settings.UltimateEnhancerTimeLv2 : Settings.UltimateEnhancerTimeLv3;
            int UERate = magic.Level == 0 ? Settings.UltimateEnhancerLv0 : magic.Level == 1 ? Settings.UltimateEnhancerLv1 : magic.Level == 2 ? Settings.UltimateEnhancerLv2 : Settings.UltimateEnhancerLv3;
            int value = (int)(Stats[Stat.MaxSC] * UERate / 100);

            switch (target.Race)
            {
                case ObjectType.Monster:
                case ObjectType.Player:
                    //Only targets
                    if (target.IsFriendlyTarget(this))
                    {
                        var stats = new Stats();

                        if (target.Race == ObjectType.Monster || ((PlayerObject)target).Class == MirClass.Warrior || ((PlayerObject)target).Class == MirClass.Assassin)
                        {
                            stats[Stat.MaxDC] = value;
                        }
                        else if  (((PlayerObject)target).Class == MirClass.Wizard || ((PlayerObject)target).Class == MirClass.Archer)
                        {
                            stats[Stat.MaxMC] = value;
                        }
                        else if (((PlayerObject)target).Class == MirClass.Taoist)
                        {
                            stats[Stat.MaxSC] = value;
                        }

                        target.AddBuff(BuffType.UltimateEnhancer, this, Settings.Second * expiretime, stats);
                        target.OperateTime = 0;
                        LevelMagic(magic);
                        ConsumeItem(item, 1);
                        cast = true;
                    }
                    break;
            }
        }
        private void Plague(UserMagic magic, Point location, out bool cast)
        {
            cast = false;
            UserItem item = GetAmulet(1);
            if (item == null) return;
            cast = true;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step


            PoisonType pType = PoisonType.None;

            UserItem itemp = GetPoison(1, 1);

            if (itemp != null)
                pType = PoisonType.Green;
            else
            {
                itemp = GetPoison(1, 2);

                if (itemp != null)
                    pType = PoisonType.Red;
            }
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, damage, pvpDamage, location, pType);
            CurrentMap.ActionList.Add(action);

            ConsumeItem(item, 1);
            if (itemp != null) ConsumeItem(itemp, 1);
        }
        private void Curse(UserMagic magic, Point location, out bool cast)
        {
            cast = false;
            UserItem item = GetAmulet(1);
            if (item == null) return;
            cast = true;

            ConsumeItem(item, 1);

            if (Envir.Random.Next(10 - ((magic.Level + 1) * 2)) > 2) return;

            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));
            int pvpDamage = magic.PvPGetDamage(GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, damage, pvpDamage, location, 1 + ((magic.Level + 1) * 2));
            CurrentMap.ActionList.Add(action);

        }


        private void PetEnhancer(MapObject target, UserMagic magic, out bool cast)
        {
            cast = false;

            if (target == null || target.Race != ObjectType.Monster || !target.IsFriendlyTarget(this)) return;

            int duration = GetAttackPower(Stats[Stat.MinSC], Stats[Stat.MaxSC]) + magic.GetPower();

            cast = true;

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, duration, target);

            ActionList.Add(action);
        }
        #endregion

        #region Warrior Skills
        private void FlyingThrust(UserMagic magic)
        {
            if (InTrapRock) return;
            if (!CanWalk) return;
            ActionTime = Envir.Time + MoveDelay;

            int dist = 1;
            int travel = 0;
            bool wall = true;
            Point location = CurrentLocation;
            MapObject target = null;
            for (int i = 0; i < dist; i++)
            {
                location = Functions.PointMove(location, Direction, 1);

                if (!CurrentMap.ValidPoint(location)) break;


                Cell cell = CurrentMap.GetCell(location);

                bool blocking = false;
                if (cell.Objects != null)
                {
                    for (int c = cell.Objects.Count - 1; c >= 0; c--)
                    {
                        MapObject ob = cell.Objects[c];
                        if (!ob.Blocking) continue;
                        wall = false;
                        if (ob.Race != ObjectType.Monster && ob.Race != ObjectType.Player)
                        {
                            blocking = true;
                            break;
                        }

                        if (target == null && ob.Race == ObjectType.Player)
                            target = ob;

                        if (Envir.Random.Next(0) >= 6 + magic.Level * 3 + Level - ob.Level || !ob.IsAttackTarget(this) || ob.Level >= Level || ob.Pushed(this, Direction, 1) == 0)
                        {
                            if (target == ob)
                                target = null;
                            blocking = true;
                            break;
                        }

                        if (cell.Objects == null) break;

                    }
                }

                if (blocking)
                {
                    if (magic.Level != 3) break;

                    Point location2 = Functions.PointMove(location, Direction, 1);

                    if (!CurrentMap.ValidPoint(location2)) break;

                    cell = CurrentMap.GetCell(location2);

                    blocking = false;
                    if (cell.Objects != null)
                    {
                        for (int c = cell.Objects.Count - 1; c >= 0; c--)
                        {
                            MapObject ob = cell.Objects[c];
                            if (!ob.Blocking) continue;
                            if (ob.Race != ObjectType.Monster && ob.Race != ObjectType.Player)
                            {
                                blocking = true;
                                break;
                            }

                            if (!ob.IsAttackTarget(this) || ob.Level >= Level || ob.Pushed(this, Direction, 1) == 0)
                            {
                                blocking = true;
                                break;
                            }

                            if (cell.Objects == null) break;
                        }
                    }

                    if (blocking) break;

                    cell = CurrentMap.GetCell(location);

                    if (cell.Objects != null)
                    {
                        for (int c = cell.Objects.Count - 1; c >= 0; c--)
                        {
                            MapObject ob = cell.Objects[c];
                            if (!ob.Blocking) continue;
                            if (ob.Race != ObjectType.Monster && ob.Race != ObjectType.Player)
                            {
                                blocking = true;
                                break;
                            }

                            if (Envir.Random.Next(0) >= 6 + magic.Level * 3 + Level - ob.Level || !ob.IsAttackTarget(this) || ob.Level >= Level || ob.Pushed(this, Direction, 1) == 0)
                            {
                                blocking = true;
                                break;
                            }

                            if (cell.Objects == null) break;
                        }
                    }

                    if (blocking) break;
                }

                travel++;
                CurrentMap.GetCell(CurrentLocation).Remove(this);
                RemoveObjects(Direction, 1);

                CurrentLocation = location;

                Enqueue(new S.UserDash { Direction = Direction, Location = location });
                Broadcast(new S.ObjectDash { ObjectID = ObjectID, Direction = Direction, Location = location });

                CurrentMap.GetCell(CurrentLocation).Add(this);
                AddObjects(Direction, 1);
            }

            if (travel > 0 && !wall)
            {
                if (target != null)
                {
                    if (target.IsAttackTarget(this))
                    {
                        int damageBase = GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]);
                        int damage = magic.GetDamage(damageBase);
                        int PvPDamage = magic.PvPGetDamage(damageBase);
                        if (target.Race == ObjectType.Player &&
                            target.Attacked(this, PvPDamage, DefenceType.MAC, false) > 0) LevelMagic(magic);
                        else if (target.Race != ObjectType.Player &&
                            target.Attacked(this, damage, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    }
                    LevelMagic(magic);
                }
            }

            if (travel > 0)
            {
                ActionTime = Envir.Time + (travel * MoveDelay / 2);

                Cell cell = CurrentMap.GetCell(CurrentLocation);
                for (int i = 0; i < cell.Objects.Count; i++)
                {
                    if (cell.Objects[i].Race != ObjectType.Spell) continue;
                    SpellObject ob = (SpellObject)cell.Objects[i];

                    if (ob.Spell != Spell.FireWall || !IsAttackTarget(ob.Caster)) continue;
                    Attacked((PlayerObject)ob.Caster, ob.Value, DefenceType.MAC, false);
                    break;
                }
            }

            if (travel == 0 || wall && dist != travel)
            {
                if (travel > 0)
                {
                    Enqueue(new S.UserDash { Direction = Direction, Location = Front });
                    Broadcast(new S.ObjectDash { ObjectID = ObjectID, Direction = Direction, Location = Front });

                    SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

                    if (szi != null)
                    {
                        BindLocation = szi.Location;
                        BindMapIndex = CurrentMapIndex;
                        InSafeZone = true;
                    }
                    else
                        InSafeZone = false;
                }
                else
                    Broadcast(new S.ObjectDash { ObjectID = ObjectID, Direction = Direction, Location = Front });

                Enqueue(new S.UserDashFail { Direction = Direction, Location = CurrentLocation });
                Broadcast(new S.ObjectDashFail { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });
                ReceiveChat("Not enough pushing Power.", ChatType.System);
            }


            magic.CastTime = Envir.Time;
            _stepCounter = 0;

            Enqueue(new S.MagicCast { Spell = magic.Spell });

            CellTime = Envir.Time + 500;
        }
        private void Entrapment(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return;

            int damage = 0;

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic, damage, target);

            ActionList.Add(action);
        }
        private void BladeAvalanche(UserMagic magic)
        {
            int damageBase = GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]);
            if (Envir.Random.Next(0,100) <= (1 + Stats[Stat.Luck])) 
                damageBase += damageBase;//crit should do something like double dmg, not double max dc dmg!
            int damageFinal = magic.GetDamage(damageBase);
            int pvpdamage = magic.PvPGetDamage(damageBase);

            int col = 3;
            int row = 3;

            Point[] loc = new Point[col]; //0 = left 1 = center 2 = right
            loc[0] = Functions.PointMove(CurrentLocation, Functions.PreviousDir(Direction), 1);
            loc[1] = Functions.PointMove(CurrentLocation, Direction, 1);
            loc[2] = Functions.PointMove(CurrentLocation, Functions.NextDir(Direction), 1);
            bool train = false;
            for (int i = 0; i < col; i++)
            {
                Point startPoint = loc[i];
                for (int j = 0; j < row; j++)
                {
                    Point hitPoint = Functions.PointMove(startPoint, Direction, j);

                    if (!CurrentMap.ValidPoint(hitPoint)) continue;

                    Cell cell = CurrentMap.GetCell(hitPoint);

                    if (cell.Objects == null) continue;

                    for (int k = 0; k < cell.Objects.Count; k++)
                    {
                        MapObject target = cell.Objects[k];
                        switch (target.Race)
                        {
                            case ObjectType.Monster:
                            case ObjectType.Player:
                                //Only targets
                                if (target.IsAttackTarget(this))
                                {
                                    if (target.Race == ObjectType.Player)
                                    {
                                        if (target.Attacked(this, j <= 1 ? pvpdamage : (int)(pvpdamage * 0.6), DefenceType.MAC, false) > 0)
                                            LevelMagic(magic);
                                    }
                                    else
                                    {
                                        if (target.Attacked(this, j <= 1 ? damageFinal : (int)(damageFinal * 0.6), DefenceType.MAC, false) > 0)
                                            LevelMagic(magic);
                                    }
                                }
                                break;
                        }
                    }
                }
            }
            if (train)
                LevelMagic(magic);
        }
        private void ProtectionField(UserMagic magic)
        {
            int ProtectionFieldRate = magic.Level == 0 ? Settings.ProFieldRateLv0 : magic.Level == 1 ? Settings.ProFieldRateLv1 : magic.Level == 2 ? Settings.ProFieldRateLv2 : Settings.ProFieldRateLv3;
            int duration = magic.Level == 0 ? Settings.ProFieldTimeLv0 : magic.Level == 1 ? Settings.ProFieldTimeLv1 : magic.Level == 2 ? Settings.ProFieldTimeLv2 : Settings.ProFieldTimeLv3;
            int addValue = (int)(Stats[Stat.MaxAC] * ProtectionFieldRate / 100);

            AddBuff(BuffType.ProtectionField, this, Settings.Second * duration, new Stats { [Stat.MaxAC] = addValue, [Stat.MinAC] = addValue });
            OperateTime = 0;
            LevelMagic(magic);
        }
        private void Rage(UserMagic magic)
        {
            int RageRate = magic.Level == 0 ? Settings.RageRateLv0 : magic.Level == 1 ? Settings.RageRateLv1 : magic.Level == 2 ? Settings.RageRateLv2 : Settings.RageRateLv3;
            int duration = magic.Level == 0 ? Settings.RageTimeLv0 : magic.Level == 1 ? Settings.RageTimeLv1 : magic.Level == 2 ? Settings.RageTimeLv2 : Settings.RageTimeLv3;
            int addValue = (int)(Stats[Stat.MaxDC] * RageRate / 100);

            AddBuff(BuffType.Rage, this, Settings.Second * duration, new Stats { [Stat.MaxDC] = addValue, [Stat.MinDC] = addValue });
            OperateTime = 0;
            LevelMagic(magic);
        }

        private void ShoulderDash(UserMagic magic)
        {
            if (InTrapRock) return;
            if (!CanWalk) return;
            ActionTime = Envir.Time + MoveDelay;

            int dist = Envir.Random.Next(2) + magic.Level + 2;
            int travel = 0;
            bool wall = true;
            Point location = CurrentLocation;
            MapObject target = null;
            for (int i = 0; i < dist; i++)
            {
                location = Functions.PointMove(location, Direction, 1);

                if (!CurrentMap.ValidPoint(location)) break;

                Cell cell = CurrentMap.GetCell(location);

                bool blocking = false;

                if (InSafeZone) blocking = true;

                SafeZoneInfo szi = CurrentMap.GetSafeZone(location);

                if (szi != null)
                {
                    blocking = true;
                }

                if (cell.Objects != null)
                {
                    for (int c = cell.Objects.Count - 1; c >= 0; c--)
                    {
                        MapObject ob = cell.Objects[c];
                        if (!ob.Blocking) continue;
                        wall = false;
                        if (ob.Race != ObjectType.Monster && ob.Race != ObjectType.Player)
                        {
                            blocking = true;
                            break;
                        }

                        if (target == null && ob.Race == ObjectType.Player)
                            target = ob;

                        if (Envir.Random.Next(20) >= 6 + magic.Level * 3 + Level - ob.Level || !ob.IsAttackTarget(this) || ob.Level >= Level || ob.Pushed(this, Direction, 1) == 0)
                        {
                            if (target == ob)
                                target = null;
                            blocking = true;
                            break;
                        }

                        if (cell.Objects == null) break;

                    }
                }

                if (blocking)
                {
                    if (magic.Level != 3) break;

                    Point location2 = Functions.PointMove(location, Direction, 1);

                    if (!CurrentMap.ValidPoint(location2)) break;

                    szi = CurrentMap.GetSafeZone(location2);

                    if (szi != null)
                    {
                        break;
                    }

                    cell = CurrentMap.GetCell(location2);

                    blocking = false;


                    if (cell.Objects != null)
                    {
                        for (int c = cell.Objects.Count - 1; c >= 0; c--)
                        {
                            MapObject ob = cell.Objects[c];
                            if (!ob.Blocking) continue;
                            if (ob.Race != ObjectType.Monster && ob.Race != ObjectType.Player)
                            {
                                blocking = true;
                                break;
                            }

                            if (!ob.IsAttackTarget(this) || ob.Level >= Level || ob.Pushed(this, Direction, 1) == 0)
                            {
                                blocking = true;
                                break;
                            }

                            if (cell.Objects == null) break;
                        }
                    }

                    if (blocking) break;

                    cell = CurrentMap.GetCell(location);

                    if (cell.Objects != null)
                    {
                        for (int c = cell.Objects.Count - 1; c >= 0; c--)
                        {
                            MapObject ob = cell.Objects[c];
                            if (!ob.Blocking) continue;
                            if (ob.Race != ObjectType.Monster && ob.Race != ObjectType.Player)
                            {
                                blocking = true;
                                break;
                            }

                            if (Envir.Random.Next(20) >= 6 + magic.Level * 3 + Level - ob.Level || !ob.IsAttackTarget(this) || ob.Level >= Level || ob.Pushed(this, Direction, 1) == 0)
                            {
                                blocking = true;
                                break;
                            }

                            if (cell.Objects == null) break;
                        }
                    }

                    if (blocking) break;
                }

                travel++;
                CurrentMap.GetCell(CurrentLocation).Remove(this);
                RemoveObjects(Direction, 1);

                CurrentLocation = location;

                Enqueue(new S.UserDash { Direction = Direction, Location = location });
                Broadcast(new S.ObjectDash { ObjectID = ObjectID, Direction = Direction, Location = location });

                CurrentMap.GetCell(CurrentLocation).Add(this);
                AddObjects(Direction, 1);
            }

            if (travel > 0 && !wall)
            {
                if (target != null) target.Attacked(this, magic.GetDamage(0), DefenceType.None, false);
                LevelMagic(magic);
            }

            if (travel > 0)
            {
                SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

                if (szi != null)
                {
                    BindLocation = szi.Location;
                    BindMapIndex = CurrentMapIndex;
                    InSafeZone = true;
                }
                else
                    InSafeZone = false;

                ActionTime = Envir.Time + (travel * MoveDelay / 2);

                Cell cell = CurrentMap.GetCell(CurrentLocation);
                for (int i = 0; i < cell.Objects.Count; i++)
                {
                    if (cell.Objects[i].Race != ObjectType.Spell) continue;
                    SpellObject ob = (SpellObject)cell.Objects[i];

                    if (ob.Spell != Spell.FireWall || !IsAttackTarget(ob.Caster)) continue;

                    Attacked((PlayerObject)ob.Caster, ob.Value, DefenceType.MAC, false);
                    break;
                }
            }

            if (travel == 0 || wall && dist != travel)
            {
                if (travel > 0)
                {
                    Enqueue(new S.UserDash { Direction = Direction, Location = Front });
                    Broadcast(new S.ObjectDash { ObjectID = ObjectID, Direction = Direction, Location = Front });
                }
                else
                    Broadcast(new S.ObjectDash { ObjectID = ObjectID, Direction = Direction, Location = Front });

                Enqueue(new S.UserDashFail { Direction = Direction, Location = CurrentLocation });
                Broadcast(new S.ObjectDashFail { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });
                ReceiveChat("Not enough pushing Power.", ChatType.System);
            }


            magic.CastTime = Envir.Time;
            _stepCounter = 0;
            //ActionTime = Envir.Time + GetDelayTime(MoveDelay);

            Enqueue(new S.MagicCast { Spell = magic.Spell });

            CellTime = Envir.Time + 500;
        }
        private void SlashingBurst(UserMagic magic, out bool cast)
        {
            cast = true;

            // damage
            int damageBase = GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]);
            int damageFinal = magic.GetDamage(damageBase);
            int pvpDamage = magic.PvPGetDamage(damageBase);

            // objects = this, magic, damage, currentlocation, direction, attackRange
            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damageFinal, pvpDamage, CurrentLocation, Direction, 1);
            CurrentMap.ActionList.Add(action);

            // telpo location
            Point location = Functions.PointMove(CurrentLocation, Direction, 2);

            if (!CurrentMap.ValidPoint(location)) return;

            Cell cInfo = CurrentMap.GetCell(location);

            bool blocked = false;
            if (cInfo.Objects != null)
            {
                for (int c = 0; c < cInfo.Objects.Count; c++)
                {
                    MapObject ob = cInfo.Objects[c];
                    if (!ob.Blocking) continue;
                    blocked = true;
                    if ((cInfo.Objects == null) || blocked) break;
                }
            }

            // blocked telpo cancel
            if (blocked) return;

            Teleport(CurrentMap, location, false);
        }
        private void FurySpell(UserMagic magic, out bool cast)
        {
            cast = true;

            ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic));
        }
        private void ImmortalSkin(UserMagic magic, out bool cast)
        {
            cast = true;

            ActionList.Add(new DelayedAction(DelayedType.Magic, Envir.Time + 500, magic));         

        }
        private void CounterAttackCast(UserMagic magic, MapObject target)
        {
            if (target == null || magic == null) return;

            if (CounterAttack == false) return;

            int damageBase = GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]);
            if (Envir.Random.Next(0, 100) <= Stats[Stat.Accuracy])
                damageBase += damageBase;//crit should do something like double dmg, not double max dc dmg!
            int damageFinal = magic.GetDamage(damageBase);


            MirDirection dir = Functions.ReverseDirection(target.Direction);
            Direction = dir;

            if (Functions.InRange(CurrentLocation, target.CurrentLocation, 1) == false) return;
            if (Envir.Random.Next(10) > magic.Level + 6) return;
            Enqueue(new S.ObjectMagic { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation, Spell = Spell.CounterAttack, TargetID = target.ObjectID, Target = target.CurrentLocation, Cast = true, Level = GetMagic(Spell.CounterAttack).Level, SelfBroadcast = true });
            DelayedAction action = new DelayedAction(DelayedType.Damage, AttackTime, target, damageFinal, DefenceType.AC, true);
            ActionList.Add(action);
            LevelMagic(magic);
            CounterAttack = false;
        }
        #endregion

        #region Assassin Skills

        private void HeavenlySword(UserMagic magic)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, CurrentLocation, Direction);
            CurrentMap.ActionList.Add(action);
        }
        private void SwiftFeet(UserMagic magic, out bool cast)
        {
            cast = true;

            ActiveSwiftFeet = true;

            AddBuff(BuffType.SwiftFeet, this, (Settings.Second * 25) + (magic.Level * 5000), new Stats(), true);

            LevelMagic(magic);
        }
        private void MoonLight(UserMagic magic)
        {
            var time = GetAttackPower(Stats[Stat.MinAC], Stats[Stat.MaxAC]);

            AddBuff(BuffType.MoonLight, this, (time + (magic.Level + 1) * 5) * 500, new Stats());

            LevelMagic(magic);
        }
        private void Trap(UserMagic magic, MapObject target, out bool cast)
        {
            cast = false;

            if (target == null || !target.IsAttackTarget(this) || !(target is MonsterObject)) return;
            if (target.Level >= Level + 2) return;

            LevelMagic(magic);
            uint duration = 60000;
            int value = (int)duration;

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, value, target);
            CurrentMap.ActionList.Add(action);
            cast = true;
        }
        private bool PoisonSword(UserMagic magic)
        {
            UserItem item = GetPoison(1);
            if (item == null) return false;

            Point hitPoint;
            Cell cell;
            MirDirection dir = Functions.PreviousDir(Direction);
            int power = magic.GetDamage(GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]));

            for (int i = 0; i < 5; i++)
            {
                hitPoint = Functions.PointMove(CurrentLocation, dir, 1);
                dir = Functions.NextDir(dir);

                if (!CurrentMap.ValidPoint(hitPoint)) continue;
                cell = CurrentMap.GetCell(hitPoint);

                if (cell.Objects == null) continue;

                for (int o = 0; o < cell.Objects.Count; o++)
                {
                    MapObject target = cell.Objects[o];
                    if (target.Race != ObjectType.Player && target.Race != ObjectType.Monster) continue;
                    if (target == null || !target.IsAttackTarget(this) || target.Node == null) continue;

                    target.ApplyPoison(new Poison
                    {
                        Duration = 3 + power / 10 + magic.Level * 3,
                        Owner = this,
                        PType = PoisonType.Green,
                        TickSpeed = 1000,
                        Value = power / 10 + magic.Level + 1 + Envir.Random.Next(Stats[Stat.PoisonAttack])
                    }, this);

                    target.OperateTime = 0;
                    break;
                }
            }

            LevelMagic(magic);
            ConsumeItem(item, 1);
            return true;
        }
        private void DarkBody(MapObject target, UserMagic magic)
        {
            if (target == null) return;

            MonsterObject monster;
            for (int i = 0; i < Pets.Count; i++)
            {
                monster = Pets[i];
                if ((monster.Info.Name != Settings.AssassinCloneName) || monster.Dead) continue;
                if (monster.Node == null) continue;
                monster.Die();
                return;
            }

            MonsterInfo info = Envir.GetMonsterInfo(Settings.AssassinCloneName);
            if (info == null) return;

            monster = MonsterObject.GetMonster(info);
            monster.Master = this;
            monster.Direction = Direction;
            monster.ActionTime = Envir.Time + 500;
            monster.RefreshNameColour(false);
            monster.Target = target;
            Pets.Add(monster);

            monster.Spawn(CurrentMap, CurrentLocation);

            if (!HasBuff(BuffType.DarkBody, out _))
            {
                LevelMagic(magic);
            }

            var duration = (GetAttackPower(Stats[Stat.MinAC], Stats[Stat.MaxAC]) + (magic.Level + 1) * 5) * 500;

            AddBuff(BuffType.DarkBody, this, duration, new Stats());
        }
        private void CrescentSlash(UserMagic magic)
        {
            int damageBase = GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC]);
            if (Envir.Random.Next(0, 100) <= Stats[Stat.Accuracy])
                damageBase += damageBase;//crit should do something like double dmg, not double max dc dmg!
            int damageFinal = magic.GetDamage(damageBase);

            MirDirection backDir = Functions.ReverseDirection(Direction);
            MirDirection preBackDir = Functions.PreviousDir(backDir);
            MirDirection nextBackDir = Functions.NextDir(backDir);

            for (int i = 0; i < 8; i++)
            {
                MirDirection dir = (MirDirection)i;
                Point hitPoint = Functions.PointMove(CurrentLocation, dir, 1);

                if (dir != backDir && dir != preBackDir && dir != nextBackDir)
                {

                    if (!CurrentMap.ValidPoint(hitPoint)) continue;

                    Cell cell = CurrentMap.GetCell(hitPoint);

                    if (cell.Objects == null) continue;


                    for (int j = 0; j < cell.Objects.Count; j++)
                    {
                        MapObject target = cell.Objects[j];
                        switch (target.Race)
                        {
                            case ObjectType.Monster:
                            case ObjectType.Player:
                                //Only targets
                                if (target.IsAttackTarget(this))
                                {
                                    DelayedAction action = new DelayedAction(DelayedType.Damage, Envir.Time + AttackSpeed, target, damageFinal, DefenceType.AC, true);
                                    ActionList.Add(action);
                                }
                                break;
                        }
                    }
                    LevelMagic(magic);
                }
            }
        }

        private void FlashDash(UserMagic magic)
        {
            bool success = false;
            ActionTime = Envir.Time;

            int travel = 0;
            bool blocked = false;
            int jumpDistance = (magic.Level <= 1) ? 0 : 1;//3 max
            Point location = CurrentLocation;
            for (int i = 0; i < jumpDistance; i++)
            {
                location = Functions.PointMove(location, Direction, 1);
                if (!CurrentMap.ValidPoint(location)) break;

                Cell cInfo = CurrentMap.GetCell(location);
                if (cInfo.Objects != null)
                {
                    for (int c = 0; c < cInfo.Objects.Count; c++)
                    {
                        MapObject ob = cInfo.Objects[c];
                        if (!ob.Blocking) continue;
                        blocked = true;
                        if ((cInfo.Objects == null) || blocked) break;
                    }
                }
                if (blocked) break;
                travel++;
            }

            jumpDistance = travel;

            if (jumpDistance > 0)
            {
                location = Functions.PointMove(CurrentLocation, Direction, jumpDistance);
                CurrentMap.GetCell(CurrentLocation).Remove(this);
                RemoveObjects(Direction, 1);
                CurrentLocation = location;
                CurrentMap.GetCell(CurrentLocation).Add(this);
                AddObjects(Direction, 1);
                Enqueue(new S.UserDashAttack { Direction = Direction, Location = location });
                Broadcast(new S.ObjectDashAttack { ObjectID = ObjectID, Direction = Direction, Location = location, Distance = jumpDistance });
            }
            else
            {
                Broadcast(new S.ObjectAttack { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation });
            }

            if (travel == 0) location = CurrentLocation;

            int attackDelay = (AttackSpeed - 120) <= 300 ? 300 : (AttackSpeed - 120);
            AttackTime = Envir.Time + attackDelay;
            SpellTime = Envir.Time + 300;

            location = Functions.PointMove(location, Direction, 1);
            if (CurrentMap.ValidPoint(location))
            {
                Cell cInfo = CurrentMap.GetCell(location);
                if (cInfo.Objects != null)
                {
                    for (int c = 0; c < cInfo.Objects.Count; c++)
                    {
                        MapObject ob = cInfo.Objects[c];
                        switch (ob.Race)
                        {
                            case ObjectType.Monster:
                            case ObjectType.Player:
                                //Only targets
                                if (ob.IsAttackTarget(this))
                                {
                                    DelayedAction action = new DelayedAction(DelayedType.Damage, AttackTime, ob,magic.GetDamage(GetAttackPower(Stats[Stat.MinDC], Stats[Stat.MaxDC])), DefenceType.AC, true);
                                    ActionList.Add(action);
                                    success = true;
                                    if ((((ob.Race != ObjectType.Player) || Settings.PvpCanResistPoison) && (Envir.Random.Next(Settings.PoisonAttackWeight) >= ob.Stats[Stat.PoisonResist])) && (Envir.Random.Next(15) <= magic.Level + 1))
                                    {
                                        DelayedAction pa = new DelayedAction(DelayedType.Poison, AttackTime, ob, PoisonType.Stun, SpellEffect.TwinDrakeBlade, magic.Level + 1, 1000);
                                        ActionList.Add(pa);
                                    }
                                }
                                break;
                        }
                    }
                }
            }
            if (success) //technicaly this makes flashdash lvl when it casts rather then when it hits (it wont lvl if it's not hitting!)
                LevelMagic(magic);

            magic.CastTime = Envir.Time;
            Enqueue(new S.MagicCast { Spell = magic.Spell });
        }
        #endregion

        #region Archer Skills
        private int ApplyArcherState(int damage)
        {
            UserMagic magic = GetMagic(Spell.MentalState);

            if (magic != null)
            {
                LevelMagic(magic);
            }

            int dmgpenalty = 100;
            switch (Info.MentalState)
            {
                case 1: //trickshot
                    dmgpenalty = 55 + (Info.MentalStateLvl * 5);
                    break;
                case 2: //group attack
                    dmgpenalty = 80;
                    break;
            }
            return (damage * dmgpenalty) / 100;
        }

        private bool StraightShot(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return false;
            if ((Info.MentalState != 1) && !CanFly(target.CurrentLocation)) return false;

            int distance = Functions.MaxDistance(CurrentLocation, target.CurrentLocation);
            int damage = magic.GetDamage(GetRangeAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC], distance));
            damage = ApplyArcherState(damage);

            int delay = distance * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, target.CurrentLocation);

            ActionList.Add(action);

            return true;
        }
        private bool DoubleShot(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return false;
            if ((Info.MentalState != 1) && !CanFly(target.CurrentLocation)) return false;

            int distance = Functions.MaxDistance(CurrentLocation, target.CurrentLocation);
            int damage = magic.GetDamage(GetRangeAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC], distance));
            damage = ApplyArcherState(damage);

            int delay = distance * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, target.CurrentLocation);

            ActionList.Add(action);

            action = new DelayedAction(DelayedType.Magic, Envir.Time + delay + 50, magic, damage, target, target.CurrentLocation);

            ActionList.Add(action);

            return true;
        }
        private void BackStep(UserMagic magic)
        {
            ActionTime = Envir.Time;
            if (!CanWalk) return;

            int travel = 0;
            bool blocked = false;
            int jumpDistance = (magic.Level == 0) ? 1 : magic.Level;//3 max
            MirDirection jumpDir = Functions.ReverseDirection(Direction);
            Point location = CurrentLocation;
            for (int i = 0; i < jumpDistance; i++)
            {
                location = Functions.PointMove(location, jumpDir, 1);
                if (!CurrentMap.ValidPoint(location)) break;

                Cell cInfo = CurrentMap.GetCell(location);
                if (cInfo.Objects != null)
                    for (int c = 0; c < cInfo.Objects.Count; c++)
                    {
                        MapObject ob = cInfo.Objects[c];
                        if (!ob.Blocking) continue;
                        blocked = true;
                        if ((cInfo.Objects == null) || blocked) break;
                    }
                if (blocked) break;
                travel++;
            }

            jumpDistance = travel;
            if (jumpDistance > 0)
            {
                for (int i = 0; i < jumpDistance; i++)
                {
                    location = Functions.PointMove(CurrentLocation, jumpDir, 1);
                    CurrentMap.GetCell(CurrentLocation).Remove(this);
                    RemoveObjects(jumpDir, 1);
                    CurrentLocation = location;
                    CurrentMap.GetCell(CurrentLocation).Add(this);
                    AddObjects(jumpDir, 1);
                }
                Enqueue(new S.UserBackStep { Direction = Direction, Location = location });
                Broadcast(new S.ObjectBackStep { ObjectID = ObjectID, Direction = Direction, Location = location, Distance = jumpDistance });
                LevelMagic(magic);
            }
            else
            {
                Broadcast(new S.ObjectBackStep { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation, Distance = jumpDistance });
                ReceiveChat("Not enough jumping power.", ChatType.System);
            }

            magic.CastTime = Envir.Time;
            Enqueue(new S.MagicCast { Spell = magic.Spell });

            CellTime = Envir.Time + 500;
        }
        private bool DelayedExplosion(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation)) return false;

            int power = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, power, target, target.CurrentLocation);
            ActionList.Add(action);
            return true;
        }
        private void ExplosiveTrap(UserMagic magic, Point location)
        {
            int freeTrapSpot = -1;

            var trapIDs = CurrentMap.GetSpellObjects(Spell.ExplosiveTrap, this).Select(x => x.ExplosiveTrapID).Distinct();

            var max = magic.Level + 1;

            if (trapIDs.Count() >= max) return;

            for (int i = 0; i < max; i++)
            {
                if (!trapIDs.Contains(i))
                {
                    freeTrapSpot = i;
                    break;
                }
            }

            if (freeTrapSpot == -1) return;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));
            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, location, freeTrapSpot);
            CurrentMap.ActionList.Add(action);
        }

        public void DoKnockback(MapObject target, UserMagic magic)//ElementalShot - knockback
        {
            Cell cell = CurrentMap.GetCell(target.CurrentLocation);
            if (!cell.Valid || cell.Objects == null) return;

            if (target.CurrentLocation.Y < 0 || target.CurrentLocation.Y >= CurrentMap.Height || target.CurrentLocation.X < 0 || target.CurrentLocation.X >= CurrentMap.Height) return;

            if (target.Race != ObjectType.Monster && target.Race != ObjectType.Player) return;
            if (!target.IsAttackTarget(this) || target.Level >= Level) return;

            if (Envir.Random.Next(20) >= 6 + magic.Level * 3 + ElementsLevel + Level - target.Level) return;
            int distance = 1 + Math.Max(0, magic.Level - 1) + Envir.Random.Next(2);
            MirDirection dir = Functions.DirectionFromPoint(CurrentLocation, target.CurrentLocation);

            target.Pushed(this, dir, distance);
        }
        public void BindingShot(UserMagic magic, MapObject target, out bool cast)
        {
            cast = false;

            if (target == null || !target.IsAttackTarget(this) || !(target is MonsterObject)) return;
            if ((Info.MentalState != 1) && !CanFly(target.CurrentLocation)) return;
            if (target.Level > Level + 2) return;
            if (((MonsterObject)target).ShockTime >= Envir.Time) return;//Already shocked


            uint duration = (uint)((magic.Level * 5 + 10) * 1000);
            int value = (int)duration;
            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, value, target, target.CurrentLocation);
            ActionList.Add(action);

            cast = true;
        }
        public void SpecialArrowShot(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return;
            if ((Info.MentalState != 1) && !CanFly(target.CurrentLocation)) return;

            int distance = Functions.MaxDistance(CurrentLocation, target.CurrentLocation);
            int damage = magic.GetDamage(GetRangeAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC], distance));
            damage = ApplyArcherState(damage);

            int delay = distance * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, target.CurrentLocation);
            ActionList.Add(action);
        }
        public void NapalmShot(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this)) return;
            if ((Info.MentalState != 1) && !CanFly(target.CurrentLocation)) return;

            int distance = Functions.MaxDistance(CurrentLocation, target.CurrentLocation);
            int damage = magic.GetDamage(GetRangeAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC], distance));
            damage = ApplyArcherState(damage);

            int delay = distance * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, this, magic, damage, target.CurrentLocation);
            CurrentMap.ActionList.Add(action);
        }
        public void ArcherSummon(UserMagic magic, MapObject target, Point location)
        {
            if (target != null && target.IsAttackTarget(this))
                location = target.CurrentLocation;
            if (!CanFly(location)) return;

            uint duration = (uint)((magic.Level * 5 + 10) * 1000);
            int value = (int)duration;
            int delay = Functions.MaxDistance(CurrentLocation, location) * 50 + 500; //50 MS per Step

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, value, location, target);
            ActionList.Add(action);
        }

        public void OneWithNature(MapObject target, UserMagic magic)
        {
            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, damage, CurrentLocation);
            CurrentMap.ActionList.Add(action);
        }
        #endregion

        #region Custom
        private void Portal(UserMagic magic, Point location, out bool cast)
        {
            cast = false;

            if (!CurrentMap.ValidPoint(location)) return;

            var portalCount = Envir.Spells.Count(x => x.Spell == Spell.Portal && x.Caster == this);

            if (portalCount == 2) return;

            if (!CanFly(location)) return;

            int duration = 30 + (magic.Level * 30);
            int value = duration;
            int passthroughCount = (magic.Level * 2) - 1;

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, value, location, passthroughCount);
            CurrentMap.ActionList.Add(action);
            cast = true;
        }

        private bool FireBounce(MapObject target, UserMagic magic, MapObject source, int bounce = -1)
        {
            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation) || bounce == 0) return false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            int delay = Functions.MaxDistance(source.CurrentLocation, target.CurrentLocation) * 50; //50 MS per Step

            if (bounce == -1)
            {
                bounce = magic.Level + 2;
                delay += 500;
            }
            else
            {
                CurrentMap.Broadcast(new S.ObjectProjectile { Spell = magic.Info.Spell, Source = source.ObjectID, Destination = target.ObjectID }, source.CurrentLocation);
            }

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, target.CurrentLocation, bounce);
            ActionList.Add(action);

            return true;
        }

        private bool MeteorShower(MapObject target, UserMagic magic)
        {
            if (target == null || !target.IsAttackTarget(this) || !CanFly(target.CurrentLocation)) return false;

            int damage = magic.GetDamage(GetAttackPower(Stats[Stat.MinMC], Stats[Stat.MaxMC]));

            int delay = Functions.MaxDistance(CurrentLocation, target.CurrentLocation) * 50 + 500; //50 MS per Step

            var targetIDs = new List<uint>();

            if (target.Race == ObjectType.Monster)
            {
                List<MapObject> targets = ((MonsterObject)target).FindAllNearby(4, target.CurrentLocation);

                int secondaryTargetCount = targets.Count > 3 ? 3 : targets.Count;

                for (int i = 0; i < secondaryTargetCount; i++)
                {
                    if (targets[i] == target || !targets[i].IsAttackTarget(this)) continue;

                    DelayedAction action2 = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage / 2, targets[i], targets[i].CurrentLocation);
                    ActionList.Add(action2);

                    targetIDs.Add(targets[i].ObjectID);
                }
            }

            Broadcast(new S.ObjectMagic { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation, Spell = magic.Info.Spell, TargetID = target.ObjectID, Target = target.CurrentLocation, Cast = true, Level = magic.Level, SecondaryTargetIDs = targetIDs });
            Enqueue(new S.Magic { Spell = Spell.MeteorShower, TargetID = target.ObjectID, Target = target.CurrentLocation, Cast = true, Level = magic.Level, SecondaryTargetIDs = targetIDs });

            DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + delay, magic, damage, target, target.CurrentLocation);
            ActionList.Add(action);

            return true;
        }

        #endregion

        private void CheckSneakRadius()
        {
            if (!Sneaking) return;

            for (int y = CurrentLocation.Y - 3; y <= CurrentLocation.Y + 3; y++)
            {
                if (y < 0) continue;
                if (y >= CurrentMap.Height) break;

                for (int x = CurrentLocation.X - 3; x <= CurrentLocation.X + 3; x++)
                {
                    if (x < 0) continue;
                    if (x >= CurrentMap.Width) break;

                    Cell cell = CurrentMap.GetCell(x, y);
                    if (!cell.Valid || cell.Objects == null) continue;

                    for (int i = 0; cell.Objects != null && i < cell.Objects.Count; i++)
                    {
                        MapObject ob = cell.Objects[i];
                        if ((ob.Race != ObjectType.Player) || ob == this) continue;

                        SneakingActive = false;
                        return;
                    }
                }
            }

            SneakingActive = true;
        }

        private void CompleteMagic(IList<object> data)
        {
            UserMagic magic = (UserMagic)data[0];
            int value, PvPValue;
            MapObject target;
            Point targetLocation;
            Point location;
            MonsterObject monster;

            switch (magic.Spell)
            {
                #region PheonixExplosion
                case Spell.PheonixExplosion:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    PvPValue = (int)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;
                    if (target.Race == ObjectType.Player &&
                        target.Attacked(this, PvPValue, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    else if (target.Race != ObjectType.Player &&
                        target.Attacked(this, value, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    break;

                #endregion
                #region AlmightyPush

                case Spell.AlmightyPush:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    PvPValue = (int)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;
                    if (target.Race == ObjectType.Player &&
                        target.Attacked(this, PvPValue, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    else if (target.Race != ObjectType.Player &&
                        target.Attacked(this, value, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    break;

                #endregion
                #region FireExplode
                case Spell.FireExplode:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    PvPValue = (int)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;
                    if (target.Race == ObjectType.Player &&
                        target.Attacked(this, PvPValue, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    else if (target.Race != ObjectType.Player &&
                        target.Attacked(this, value, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    break;

                #endregion

                #region YinYangBurst

                case Spell.YinYangBurst:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    PvPValue = (int)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;
                    if (target.Race == ObjectType.Player &&
                        target.Attacked(this, PvPValue, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    else if (target.Race != ObjectType.Player &&
                        target.Attacked(this, value, DefenceType.MAC, false) > 0) LevelMagic(magic);

                    if (value == 0) return;
                    LevelMagic(magic);
                    if (YYBAmount == 0) YYBTime = Envir.Time + 1000;
                    //YYBAmount += (ushort)((value * (magic.Level + 1) * 0.25F));
                    switch (magic.Level)
                    {
                        case 0:
                            YYBAmount += (ushort)((value * 0.30F));
                            break;
                        case 1:
                            YYBAmount += (ushort)((value * 0.40F));
                            break;
                        case 2:
                            YYBAmount += (ushort)((value * 0.50F));
                            break;
                        case 3:
                            YYBAmount += (ushort)((value * 0.60F));
                            break;
                    }
                    break;

                #endregion

                #region FireBall, GreatFireBall, ThunderBolt, SoulFireBall, FlameDisruptor

                case Spell.FireBall:
                case Spell.GreatFireBall:
                case Spell.ThunderBolt:
                case Spell.SoulFireBall:
                case Spell.FlameDisruptor:
                case Spell.StraightShot:
                case Spell.DoubleShot:
                case Spell.MeteorShower:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    targetLocation = (Point)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || !Functions.InRange(target.CurrentLocation, targetLocation, 2)) return;
                    if (target.Attacked(this, value, DefenceType.MAC, false) > 0) LevelMagic(magic);
                    break;

                #endregion

                #region FireBounce

                case Spell.FireBounce:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    targetLocation = (Point)data[3];
                    int bounce = (int)data[4];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || !Functions.InRange(target.CurrentLocation, targetLocation, 2)) return;
                    if (target.Attacked(this, value, DefenceType.MAC, false) > 0) LevelMagic(magic);

                    if (target.Race == ObjectType.Monster)
                    {
                        var targets = ((MonsterObject)target).FindAllNearby(3, target.CurrentLocation).Where(x => x != target && x.IsAttackTarget(this)).ToList();

                        if (targets.Count > 0)
                        {
                            var nextTarget = targets[Envir.Random.Next(targets.Count)];

                            this.FireBounce(nextTarget, magic, target, --bounce);
                        }
                    }

                    break;

                #endregion

                #region FrostCrunch
                case Spell.FrostCrunch:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    targetLocation = (Point)data[3];
                    PvPValue = (int)data[4];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || !Functions.InRange(target.CurrentLocation, targetLocation, 2)) return;
                    if (target.Race == ObjectType.Player && target.Attacked(this, PvPValue, DefenceType.MAC, false) > 0)
                    {
                        if (Level + (target.Race == ObjectType.Player ? 2 : 10) >= target.Level && Envir.Random.Next(target.Race == ObjectType.Player ? 100 : 20) <= magic.Level)
                        {
                            target.ApplyPoison(new Poison
                            {
                                Owner = this,
                                Duration = target.Race == ObjectType.Player ? 4 : 5 + Envir.Random.Next(5),
                                PType = PoisonType.Slow,
                                TickSpeed = 1000,
                            }, this);
                            target.OperateTime = 0;
                        }

                        if (Level + (target.Race == ObjectType.Player ? 2 : 10) >= target.Level && Envir.Random.Next(target.Race == ObjectType.Player ? 100 : 40) <= magic.Level)
                        {
                            target.ApplyPoison(new Poison
                            {
                                Owner = this,
                                Duration = target.Race == ObjectType.Player ? 2 : 5 + Envir.Random.Next(Stats[Stat.Freezing]),
                                PType = PoisonType.Frozen,
                                TickSpeed = 1000,
                            }, this);
                            target.OperateTime = 0;
                        }

                        LevelMagic(magic);
                    }
                    else if (target.Race == ObjectType.Player && target.Attacked(this, value, DefenceType.MAC, false) > 0)
                    {
                        if (Level + (target.Race == ObjectType.Player ? 2 : 10) >= target.Level && Envir.Random.Next(target.Race == ObjectType.Player ? 100 : 20) <= magic.Level)
                        {
                            target.ApplyPoison(new Poison
                            {
                                Owner = this,
                                Duration = target.Race == ObjectType.Player ? 4 : 5 + Envir.Random.Next(5),
                                PType = PoisonType.Slow,
                                TickSpeed = 1000,
                            }, this);
                            target.OperateTime = 0;
                        }

                        if (Level + (target.Race == ObjectType.Player ? 2 : 10) >= target.Level && Envir.Random.Next(target.Race == ObjectType.Player ? 100 : 40) <= magic.Level)
                        {
                            target.ApplyPoison(new Poison
                            {
                                Owner = this,
                                Duration = target.Race == ObjectType.Player ? 2 : 5 + Envir.Random.Next(Stats[Stat.Freezing]),
                                PType = PoisonType.Frozen,
                                TickSpeed = 1000,
                            }, this);
                            target.OperateTime = 0;
                        }

                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region Vampirism

                case Spell.Vampirism:
                    value = (int)data[1];
                    target = (MapObject)data[2];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;
                    value = target.Attacked(this, value, DefenceType.MAC, false);
                    if (value == 0) return;
                    LevelMagic(magic);
                    if (VampAmount == 0) VampTime = Envir.Time + 1000;
                    VampAmount += (ushort)(value * (magic.Level + 1) * 0.25F);
                    break;

                #endregion

                #region Healing

                case Spell.Healing:
                    value = (int)data[1];
                    target = (MapObject)data[2];

                    if (target == null || !target.IsFriendlyTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;
                    if (target.Health >= target.MaxHealth) return;
                    target.HealAmount = (ushort)Math.Min(ushort.MaxValue, target.HealAmount + value);
                    target.OperateTime = 0;
                    LevelMagic(magic);
                    break;

                #endregion

                #region ElectricShock

                case Spell.ElectricShock:
                    monster = (MonsterObject)data[1];
                    if (monster == null || !monster.IsAttackTarget(this) || monster.CurrentMap != CurrentMap || monster.Node == null) return;
                    ElectricShock(monster, magic);
                    break;

                #endregion

                #region Poisoning

                case Spell.Poisoning:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    UserItem item = (UserItem)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;

                    switch (item.Info.Shape)
                    {
                        case 1:
                            target.ApplyPoison(new Poison
                            {
                                Duration = (value * 2) + ((magic.Level + 1) * 7),
                                Owner = this,
                                PType = PoisonType.Green,
                                TickSpeed = 2000,
                                Value = value / 15 + magic.Level + 1 + Envir.Random.Next(Stats[Stat.PoisonAttack])
                            }, this);
                            break;
                        case 2:
                            target.ApplyPoison(new Poison
                            {
                                Duration = (value * 2) + (magic.Level + 1) * 7,
                                Owner = this,
                                PType = PoisonType.Red,
                                TickSpeed = 2000,
                            }, this);
                            break;
                    }
                    target.OperateTime = 0;

                    LevelMagic(magic);
                    break;

                #endregion

                #region StormEscape
                case Spell.StormEscape:
                    location = (Point) data[1];
                    if (CurrentMap.Info.NoTeleport)
                    {
                        ReceiveChat(("You cannot teleport on this map"), ChatType.System);
                        return;
                    }
                    if (!CurrentMap.ValidPoint(location) || Envir.Random.Next(4) >= magic.Level + 1 || !Teleport(CurrentMap, location, false)) return;
                    CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.StormEscape }, CurrentLocation);

                    AddBuff(BuffType.TemporalFlux, this, Settings.Second * 30, new Stats { [Stat.TeleportManaPenaltyPercent] = 30 });
                    LevelMagic(magic);
                    break;
                #endregion

                #region Teleport
                case Spell.Teleport:
                    Map temp = Envir.GetMap(BindMapIndex);
                    int mapSizeX = temp.Width / (magic.Level + 1);
                    int mapSizeY = temp.Height / (magic.Level + 1);

                    if (CurrentMap.Info.NoTeleport)
                    {
                        ReceiveChat(("You cannot teleport on this map"), ChatType.System);
                        return;
                    }

                    for (int i = 0; i < 200; i++)
                    {
                        location = new Point(BindLocation.X + Envir.Random.Next(-mapSizeX, mapSizeX),
                                             BindLocation.Y + Envir.Random.Next(-mapSizeY, mapSizeY));

                        if (Teleport(temp, location)) break;
                    }

                    AddBuff(BuffType.TemporalFlux, this, Settings.Second * 30, new Stats { [Stat.TeleportManaPenaltyPercent] = 30 });
                    LevelMagic(magic);

                    break;
                #endregion

                #region Blink

                case Spell.Blink:
                    {
                        location = (Point)data[1];
                        if (CurrentMap.Info.NoTeleport)
                        {
                            ReceiveChat(("You cannot teleport on this map"), ChatType.System);
                            return;
                        }
                        if (Functions.InRange(CurrentLocation, location, magic.Info.Range) == false) return;
                        if (!CurrentMap.ValidPoint(location) || Envir.Random.Next(4) >= magic.Level + 1 || !Teleport(CurrentMap, location, false)) return;
                        CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.Teleport }, CurrentLocation);
                        LevelMagic(magic); 
                        
                        AddBuff(BuffType.TemporalFlux, this, Settings.Second * 30, new Stats { [Stat.TeleportManaPenaltyPercent] = 30 });
                    }
                    break;

                #endregion

                #region Hiding

                case Spell.Hiding:
                    {
                        value = (int)data[1];

                        AddBuff(BuffType.Hiding, this, Settings.Second * value, new Stats());

                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region Haste

                case Spell.Haste:
                    {
                        AddBuff(BuffType.Haste, this, (Settings.Second * 30) + (magic.Level + 1), new Stats { [Stat.AttackSpeed] = (magic.Level + 1) * 2 });
                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region Fury

                case Spell.Fury:
                    {
                        AddBuff(BuffType.Fury, this, (Settings.Second * 60) + (magic.Level * 10000), new Stats { [Stat.AttackSpeed] = 4 });
                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region ImmortalSkin

                case Spell.ImmortalSkin:
                    {
                        var stats = new Stats
                        {
                            [Stat.MaxDC] = (int)Math.Round(Stats[Stat.MaxDC] * (0.05 + (0.01 * magic.Level))) * -1,
                            [Stat.MaxAC] = (int)Math.Round(Stats[Stat.MaxAC] * (0.10 + (0.07 * magic.Level)))
                        };

                        AddBuff(BuffType.ImmortalSkin, this, (Settings.Second * 60) + (magic.Level * 1000), stats);
                        LevelMagic(magic);
                    }
                    break;
                #endregion

                #region LightBody

                case Spell.LightBody:
                    {
                        AddBuff(BuffType.LightBody, this, (magic.Level + 1) * (Settings.Second * 30), new Stats { [Stat.Agility] = (magic.Level + 1) * 2 });
                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region MagicShield

                case Spell.MagicShield:
                    {
                        if (HasBuff(BuffType.MagicShield, out _)) return;

                        LevelMagic(magic);
                        AddBuff(BuffType.MagicShield, this, Settings.Second * (int)data[1], new Stats { [Stat.DamageReductionPercent] = (magic.Level + 2) * 10 });
                    }
                    break;

                #endregion

                #region TurnUndead

                case Spell.TurnUndead:
                    {
                        monster = (MonsterObject)data[1];
                        if (monster == null || !monster.IsAttackTarget(this) || monster.CurrentMap != CurrentMap || monster.Node == null) return;
                        monster.LastHitter = this;
                        monster.LastHitTime = Envir.Time + 5000;
                        monster.EXPOwner = this;
                        monster.EXPOwnerTime = Envir.Time + 5000;
                        monster.Die();
                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region Purification

                case Spell.Purification:
                    target = (MapObject)data[1];

                    if (target == null || !target.IsFriendlyTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;
                    if (Envir.Random.Next(4) > magic.Level) return;

                    for (int i = 0; i < target.Buffs.Count; i++)
                    {
                        var buff = target.Buffs[i];

                        if (!buff.Properties.HasFlag(BuffProperty.Debuff)) continue;

                        target.RemoveBuff(buff.Type);
                    }

                    if (target.PoisonList.Any(x => x.PType == PoisonType.DelayedExplosion))
                    {
                        target.ExplosionInflictedTime = 0;
                        target.ExplosionInflictedStage = 0;

                        if (target.ObjectID == ObjectID)
                        {
                            Enqueue(new S.RemoveDelayedExplosion { ObjectID = target.ObjectID });
                        }

                        target.Broadcast(new S.RemoveDelayedExplosion { ObjectID = target.ObjectID });
                    }

                    target.PoisonList.Clear();
                    target.OperateTime = 0;

                    LevelMagic(magic);
                    break;

                #endregion

                #region Revelation

                case Spell.Revelation:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    if (target == null || target.CurrentMap != CurrentMap || target.Node == null) return;
                    if (target.Race != ObjectType.Player && target.Race != ObjectType.Monster) return;
                    if (Envir.Random.Next(4) > magic.Level || Envir.Time < target.RevTime) return;

                    target.RevTime = Envir.Time + value * 1000;
                    target.OperateTime = 0;
                    target.BroadcastHealthChange();

                    LevelMagic(magic);
                    break;

                #endregion

                #region Reincarnation

                case Spell.Reincarnation:

                    if (ReincarnationReady)
                    {
                        ReincarnationTarget.Enqueue(new S.RequestReincarnation { });
                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region Entrapment

                case Spell.Entrapment:
                    value = (int)data[1];
                    target = (MapObject)data[2];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || target.Race != ObjectType.Monster ||
                        Functions.MaxDistance(CurrentLocation, target.CurrentLocation) > 7 || target.Level >= Level + 5 + Envir.Random.Next(8)) return;

                    MirDirection pulldirection = (MirDirection)((byte)(Direction - 4) % 8);
                    int pulldistance = 0;
                    if ((byte)pulldirection % 2 > 0)
                        pulldistance = Math.Max(0, Math.Min(Math.Abs(CurrentLocation.X - target.CurrentLocation.X), Math.Abs(CurrentLocation.Y - target.CurrentLocation.Y)));
                    else
                        pulldistance = pulldirection == MirDirection.Up || pulldirection == MirDirection.Down ? Math.Abs(CurrentLocation.Y - target.CurrentLocation.Y) - 2 : Math.Abs(CurrentLocation.X - target.CurrentLocation.X) - 2;

                    int levelgap = target.Race == ObjectType.Player ? Level - target.Level + 4 : Level - target.Level + 9;
                    if (Envir.Random.Next(30) >= ((magic.Level + 1) * 3) + levelgap) return;

                    int duration = target.Race == ObjectType.Player ? (int)Math.Round((magic.Level + 1) * 1.6) : (int)Math.Round((magic.Level + 1) * 0.8);
                    if (duration > 0) target.ApplyPoison(new Poison { PType = PoisonType.Paralysis, Duration = duration, TickSpeed = 1000 }, this);
                    CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = target.ObjectID, Effect = SpellEffect.Entrapment }, target.CurrentLocation);
                    if (target.Pushed(this, pulldirection, pulldistance) > 0) LevelMagic(magic);
                    break;

                #endregion

                #region Hallucination

                case Spell.Hallucination:
                    value = (int)data[1];
                    target = (MapObject)data[2];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null ||
                        Functions.MaxDistance(CurrentLocation, target.CurrentLocation) > 7 || Envir.Random.Next(Level + 20 + magic.Level * 5) <= target.Level + 10) return;
                    item = GetAmulet(1);
                    if (item == null) return;

                    ((MonsterObject)target).HallucinationTime = Envir.Time + (Envir.Random.Next(20) + 10) * 1000;
                    target.Target = null;

                    ConsumeItem(item, 1);

                    LevelMagic(magic);
                    break;

                #endregion

                #region PetEnhancer

                case Spell.PetEnhancer:
                    {
                        value = (int)data[1];
                        target = (MonsterObject)data[2];

                        int dcInc = 2 + target.Level * 2;
                        int acInc = 4 + target.Level;

                        var stats = new Stats
                        {
                            [Stat.MinDC] = dcInc,
                            [Stat.MaxDC] = dcInc,
                            [Stat.MinAC] = acInc,
                            [Stat.MaxAC] = acInc
                        };

                        target.AddBuff(BuffType.PetEnhancer, this, (Settings.Second * value), stats);
                        LevelMagic(magic);
                    }
                    break;

                #endregion

                #region ElementalBarrier, ElementalShot

                case Spell.ElementalBarrier:
                    {
                        if (HasBuff(BuffType.ElementalBarrier, out _)) return;

                        if (!HasElemental)
                        {
                            ObtainElement(true);
                            LevelMagic(magic);
                            return;
                        }

                        int barrierPower = GetElementalOrbPower(true);//defensive orbpower
                                                                      //destroy orbs
                        ElementsLevel = 0;
                        ObtainElement(false);
                        LevelMagic(magic);

                        AddBuff(BuffType.ElementalBarrier, this, Settings.Second * ((int)data[1] + barrierPower), new Stats { [Stat.DamageReductionPercent] = (magic.Level + 1) * 10 });
                        CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.ElementalBarrierUp }, CurrentLocation);
                    }
                    break;

                case Spell.ElementalShot:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    targetLocation = (Point)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || !Functions.InRange(target.CurrentLocation, targetLocation, 2))
                    {
                        //destroy orbs
                        ElementsLevel = 0;
                        ObtainElement(false);//update and send to client
                        return;
                    }
                    if (target.Attacked(this, value, DefenceType.MAC, false) > 0)
                        LevelMagic(magic);
                    DoKnockback(target, magic);//ElementalShot - Knockback

                    //destroy orbs
                    ElementsLevel = 0;
                    ObtainElement(false);//update and send to client
                    break;

                #endregion

                #region DelayedExplosion

                case Spell.DelayedExplosion:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    targetLocation = (Point)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || !Functions.InRange(target.CurrentLocation, targetLocation, 2)) return;
                    if (target.Attacked(this, value, DefenceType.MAC, false) > 0) LevelMagic(magic);

                    target.ApplyPoison(new Poison
                    {
                        Duration = (value * 2) + (magic.Level + 1) * 7,
                        Owner = this,
                        PType = PoisonType.DelayedExplosion,
                        TickSpeed = 2000,
                        Value = value
                    }, this);

                    target.OperateTime = 0;
                    LevelMagic(magic);
                    break;

                #endregion

                #region BindingShot

                case Spell.BindingShot:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    targetLocation = (Point)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || !Functions.InRange(target.CurrentLocation, targetLocation, 2)) return;
                    if (((MonsterObject)target).ShockTime >= Envir.Time) return;//Already shocked

                    Point place = target.CurrentLocation;
                    MonsterObject centerTarget = null;

                    for (int y = place.Y - 1; y <= place.Y + 1; y++)
                    {
                        if (y < 0) continue;
                        if (y >= CurrentMap.Height) break;

                        for (int x = place.X - 1; x <= place.X + 1; x++)
                        {
                            if (x < 0) continue;
                            if (x >= CurrentMap.Width) break;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject targetob = cell.Objects[i];

                                if (y == place.Y && x == place.X && targetob.Race == ObjectType.Monster)
                                {
                                    centerTarget = (MonsterObject)targetob;
                                }

                                switch (targetob.Race)
                                {
                                    case ObjectType.Monster:
                                        if (targetob == null || !targetob.IsAttackTarget(this) || targetob.Node == null || targetob.Level > this.Level + 2) continue;

                                        MonsterObject mobTarget = (MonsterObject)targetob;

                                        if (centerTarget == null) centerTarget = mobTarget;

                                        mobTarget.ShockTime = Envir.Time + value;
                                        mobTarget.Target = null;
                                        break;
                                }
                            }
                        }
                    }

                    if (centerTarget == null) return;

                    //only the centertarget holds the effect
                    centerTarget.BindingShotCenter = true;
                    centerTarget.Broadcast(new S.SetBindingShot { ObjectID = centerTarget.ObjectID, Enabled = true, Value = value });

                    LevelMagic(magic);
                    break;

                #endregion

                #region VampireShot, PoisonShot, CrippleShot
                case Spell.VampireShot:
                case Spell.PoisonShot:
                case Spell.CrippleShot:
                    value = (int)data[1];
                    target = (MapObject)data[2];
                    targetLocation = (Point)data[3];

                    if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null || !Functions.InRange(target.CurrentLocation, targetLocation, 2)) return;
                    if (target.Attacked(this, value, DefenceType.MAC, false) == 0) return;

                    int buffTime = 5 + (5 * magic.Level);

                    bool hasVampBuff = HasBuff(BuffType.VampireShot, out _);
                    bool hasPoisonBuff = HasBuff(BuffType.PoisonShot, out _);

                    bool doVamp = false, doPoison = false;
                    if (magic.Spell == Spell.VampireShot)
                    {
                        doVamp = true;
                        if (!hasVampBuff && !hasPoisonBuff && (Envir.Random.Next(20) >= 8))//40% chance
                        {
                            AddBuff(BuffType.VampireShot, this, Settings.Second * buffTime, new Stats());
                            BroadcastInfo();
                        }
                    }
                    if (magic.Spell == Spell.PoisonShot)
                    {
                        doPoison = true;
                        if (!hasPoisonBuff && !hasVampBuff && (Envir.Random.Next(20) >= 8))//40% chance
                        {
                            AddBuff(BuffType.PoisonShot, this, Settings.Second * buffTime, new Stats());
                            BroadcastInfo();
                        }
                    }
                    if (magic.Spell == Spell.CrippleShot)
                    {
                        if (hasVampBuff || hasPoisonBuff)
                        {
                            place = target.CurrentLocation;
                            for (int y = place.Y - 1; y <= place.Y + 1; y++)
                            {
                                if (y < 0) continue;
                                if (y >= CurrentMap.Height) break;
                                for (int x = place.X - 1; x <= place.X + 1; x++)
                                {
                                    if (x < 0) continue;
                                    if (x >= CurrentMap.Width) break;
                                    Cell cell = CurrentMap.GetCell(x, y);
                                    if (!cell.Valid || cell.Objects == null) continue;
                                    for (int i = 0; i < cell.Objects.Count; i++)
                                    {
                                        MapObject targetob = cell.Objects[i];
                                        if (targetob.Race != ObjectType.Monster && targetob.Race != ObjectType.Player) continue;
                                        if (targetob == null || !targetob.IsAttackTarget(this) || targetob.Node == null) continue;
                                        if (targetob.Dead) continue;

                                        if (hasVampBuff)//Vampire Effect
                                        {
                                            //cancel out buff
                                            AddBuff(BuffType.VampireShot, this, 0, new Stats());

                                            target.Attacked(this, value, DefenceType.MAC, false);
                                            if (VampAmount == 0) VampTime = Envir.Time + Settings.Second;
                                            VampAmount += (ushort)(value * (magic.Level + 1) * 0.25F);
                                        }
                                        if (hasPoisonBuff)//Poison Effect
                                        {
                                            //cancel out buff
                                            AddBuff(BuffType.PoisonShot, this, 0, new Stats());

                                            targetob.ApplyPoison(new Poison
                                            {
                                                Duration = (value * 2) + (magic.Level + 1) * 7,
                                                Owner = this,
                                                PType = PoisonType.Green,
                                                TickSpeed = 2000,
                                                Value = value / 25 + magic.Level + 1 + Envir.Random.Next(Stats[Stat.PoisonAttack])
                                            }, this);
                                            targetob.OperateTime = 0;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        if (doVamp)//Vampire Effect
                        {
                            if (VampAmount == 0) VampTime = Envir.Time + 1000;
                            VampAmount += (ushort)(value * (magic.Level + 1) * 0.25F);
                        }
                        if (doPoison)//Poison Effect
                        {
                            target.ApplyPoison(new Poison
                            {
                                Duration = (value * 2) + (magic.Level + 1) * 7,
                                Owner = this,
                                PType = PoisonType.Green,
                                TickSpeed = 2000,
                                Value = value / 25 + magic.Level + 1 + Envir.Random.Next(Stats[Stat.PoisonAttack])
                            }, this);
                            target.OperateTime = 0;
                        }
                    }

                    LevelMagic(magic);
                    break;
                #endregion

                #region ArcherSummons
                case Spell.SummonVampire:
                case Spell.SummonToad:
                case Spell.SummonSnakes:
                    value = (int)data[1];
                    location = (Point)data[2];
                    target = (MapObject)data[3];

                    int SummonType = 0;
                    switch (magic.Spell)
                    {
                        case Spell.SummonVampire:
                            SummonType = 1;
                            break;
                        case Spell.SummonToad:
                            SummonType = 2;
                            break;
                        case Spell.SummonSnakes:
                            SummonType = 3;
                            break;
                    }
                    if (SummonType == 0) return;

                    for (int i = 0; i < Pets.Count; i++)
                    {
                        monster = Pets[i];
                        if ((monster.Info.Name != (SummonType == 1 ? Settings.VampireName : (SummonType == 2 ? Settings.ToadName : Settings.SnakeTotemName))) || monster.Dead) continue;
                        if (monster.Node == null) continue;
                        monster.ActionList.Add(new DelayedAction(DelayedType.Recall, Envir.Time + 500, target));
                        monster.Target = target;
                        return;
                    }

                    if (Pets.Where(x => x.Race == ObjectType.Monster).Count() > 1) return;

                    //left it in for future summon amulets
                    //UserItem item = GetAmulet(5);
                    //if (item == null) return;

                    MonsterInfo info = Envir.GetMonsterInfo((SummonType == 1 ? Settings.VampireName : (SummonType == 2 ? Settings.ToadName : Settings.SnakeTotemName)));
                    if (info == null) return;

                    LevelMagic(magic);
                    //ConsumeItem(item, 5);

                    monster = MonsterObject.GetMonster(info);
                    monster.PetLevel = magic.Level;
                    monster.Master = this;
                    monster.MaxPetLevel = (byte)(1 + magic.Level * 2);
                    monster.Direction = Direction;
                    monster.ActionTime = Envir.Time + 1000;
                    monster.Target = target;

                    if (SummonType == 1)
                        ((Monsters.VampireSpider)monster).AliveTime = Envir.Time + ((magic.Level * 1500) + 15000);
                    if (SummonType == 2)
                        ((Monsters.SpittingToad)monster).AliveTime = Envir.Time + ((magic.Level * 2000) + 25000);
                    if (SummonType == 3)
                        ((Monsters.SnakeTotem)monster).AliveTime = Envir.Time + ((magic.Level * 1500) + 20000);

                    //Pets.Add(monster);

                    DelayedAction action = new DelayedAction(DelayedType.Magic, Envir.Time + 500, this, magic, monster, location);
                    CurrentMap.ActionList.Add(action);
                    break;
                #endregion

            }
        }

        private void CompleteMine(IList<object> data)
        {
            MapObject target = (MapObject)data[0];
            if (target == null) return;
            target.Broadcast(new S.MapEffect { Effect = SpellEffect.Mine, Location = target.CurrentLocation, Value = (byte)Direction });
            //target.Broadcast(new S.ObjectEffect { ObjectID = target.ObjectID, Effect = SpellEffect.Mine });
            if ((byte)target.Direction < 6)
                target.Direction++;
            target.Broadcast(target.GetInfo());
        }
        private void CompleteAttack(IList<object> data)
        {
            MapObject target = (MapObject)data[0];
            int damage = (int)data[1];
            DefenceType defence = (DefenceType)data[2];
            bool damageWeapon = (bool)data[3];
            UserMagic userMagic = null;
            bool finalHit = false;
            if (data.Count >= 5)
                userMagic = (UserMagic)data[4];
            if (data.Count >= 6)
                finalHit = (bool)data[5];
            if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;

            if (FatalSword)
                defence = DefenceType.Agility;

            if (target.Attacked(this, damage, defence, damageWeapon) <= 0) return;
            if (FatalSword)
            {
                S.ObjectEffect p = new S.ObjectEffect { ObjectID = target.ObjectID, Effect = SpellEffect.FatalSword };
                CurrentMap.Broadcast(p, target.CurrentLocation);
                FatalSword = false;
                var magic = GetMagic(Spell.FatalSword);
                if (magic != null) LevelMagic(magic);
            }
            if (userMagic != null && finalHit)
            {
                if (userMagic.Spell == Spell.TwinDrakeBlade)
                {
                    if ((((target.Race != ObjectType.Player) || Settings.PvpCanResistPoison) &&
                        (Envir.Random.Next(Settings.PoisonAttackWeight) >= target.Stats[Stat.PoisonResist])) &&
                        (target.Level < Level + 10 && Envir.Random.Next(target.Race == ObjectType.Player ? 40 : 20) <= userMagic.Level + 1))
                    {
                        target.ApplyPoison(new Poison { PType = PoisonType.Stun, Duration = target.Race == ObjectType.Player ? 2 : 2 + userMagic.Level, TickSpeed = 1000 }, this);
                        target.Broadcast(new S.ObjectEffect { ObjectID = target.ObjectID, Effect = SpellEffect.TwinDrakeBlade });
                    }
                }
            }

            //Level Fencing / SpiritSword
            foreach (UserMagic magic in Info.Magics)
            {
                switch (magic.Spell)
                {
                    case Spell.Fencing:
                    case Spell.SpiritSword:
                        LevelMagic(magic);
                        break;
                }
            }
        }
        private void CompleteDamageIndicator(IList<object> data)
        {
            MapObject target = (MapObject)data[0];
            DamageType type = (DamageType)data[1];

            if (target == null || !target.IsAttackTarget(this) || target.CurrentMap != CurrentMap || target.Node == null) return;

            target.BroadcastDamageIndicator(type);
        }
        private void CompleteQuest(IList<object> data)
        {
            QuestProgressInfo quest = (QuestProgressInfo)data[0];
            QuestAction questAction = (QuestAction)data[1];
            bool ignoreIfComplete = (bool)data[2];

            if (quest == null) return;

            switch (questAction)
            {
                case QuestAction.TimeExpired:
                    {
                        if (ignoreIfComplete && quest.Completed)
                        {
                            return;
                        }

                        AbandonQuest(quest.Info.Index);
                    }
                    break;
            }
        }



        private void CompleteNPC(IList<object> data)
        {
            uint npcid = (uint)data[0];
            int scriptid = (int)data[1];
            string page = (string)data[2];

            if (data.Count == 5)
            {
                Map map = (Map)data[3];
                Point coords = (Point)data[4];

                Teleport(map, coords);
            }

            NPCDelayed = true;

            if (page.Length > 0)
            {
                var script = NPCScript.Get(scriptid);
                script.Call(this, npcid, page.ToUpper());
            }
        }
        private void CompletePoison(IList<object> data)
        {
            MapObject target = (MapObject)data[0];
            PoisonType pt = (PoisonType)data[1];
            SpellEffect sp = (SpellEffect)data[2];
            int duration = (int)data[3];
            int tickSpeed = (int)data[4];

            if (target == null) return;

            target.ApplyPoison(new Poison { PType = pt, Duration = duration, TickSpeed = tickSpeed }, this);
            target.Broadcast(new S.ObjectEffect { ObjectID = target.ObjectID, Effect = sp });
        }

        private UserItem GetAmulet(int count, int shape = 0)
        {
            for (int i = 0; i < Info.Equipment.Length; i++)
            {
                UserItem item = Info.Equipment[i];
                if (item != null && item.Info.Type == ItemType.Amulet && item.Info.Shape == shape && item.Count >= count)
                    return item;
            }

            return null;
        }
        private UserItem GetPoison(int count, byte shape = 0)
        {
            for (int i = 0; i < Info.Equipment.Length; i++)
            {
                UserItem item = Info.Equipment[i];
                if (item != null && item.Info.Type == ItemType.TaoPoison && item.Count >= count)
                {
                    if (shape == 0)
                    {
                        if (item.Info.Shape == 1 || item.Info.Shape == 2)
                            return item;
                    }
                    else
                    {
                        if (item.Info.Shape == shape)
                            return item;
                    }
                }
            }

            return null;
        }
        private UserItem GetBait(int count)
        {
            UserItem item = Info.Equipment[(int)EquipmentSlot.Weapon];
            if (item == null || item.Info.Type != ItemType.Weapon || !item.Info.IsFishingRod) return null;

            UserItem bait = item.Slots[(int)FishingSlot.Bait];

            if (bait == null || bait.Count < count) return null;

            return bait;
        }

        private UserItem GetFishingItem(FishingSlot type)
        {
            UserItem item = Info.Equipment[(int)EquipmentSlot.Weapon];
            if (item == null || item.Info.Type != ItemType.Weapon || !item.Info.IsFishingRod) return null;

            UserItem fishingItem = item.Slots[(int)type];

            if (fishingItem == null) return null;

            return fishingItem;
        }
        private void DeleteFishingItem(FishingSlot type)
        {
            UserItem item = Info.Equipment[(int)EquipmentSlot.Weapon];
            if (item == null || item.Info.Type != ItemType.Weapon || !item.Info.IsFishingRod) return;

            UserItem slotItem = Info.Equipment[(int)EquipmentSlot.Weapon].Slots[(int)type];

            Enqueue(new S.DeleteItem { UniqueID = slotItem.UniqueID, Count = 1 });
            Info.Equipment[(int)EquipmentSlot.Weapon].Slots[(int)type] = null;

            Report.ItemChanged(slotItem, 1, 1);
        }
        private void DamagedFishingItem(FishingSlot type, int lossDura)
        {
            UserItem item = GetFishingItem(type);

            if (item != null)
            {
                if (item.CurrentDura <= 0)
                {

                    DeleteFishingItem(type);
                }
                else
                {
                    DamageItem(item, lossDura, true);
                }
            }
        }

        public UserMagic GetMagic(Spell spell)
        {
            for (int i = 0; i < Info.Magics.Count; i++)
            {
                UserMagic magic = Info.Magics[i];
                if (magic.Spell != spell) continue;
                return magic;
            }

            return null;
        }

        public void LevelMagic(UserMagic magic)
        {
            byte exp = (byte)(Envir.Random.Next(3) + 1);

            if ((Settings.MentorSkillBoost) && (Info.Mentor != 0) && (Info.isMentor))
            {
                if (HasBuff(BuffType.Mentee, out _))
                {
                    CharacterInfo Mentor = Envir.GetCharacterInfo(Info.Mentor);
                    PlayerObject player = Envir.GetPlayer(Mentor.Name);
                    if (player.CurrentMap == CurrentMap && Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) && !player.Dead)
                    {
                        if (Stats[Stat.SkillGainMultiplier] == 1)
                        {
                            exp *= 2;
                        }
                    }
                }
            }

            exp *= (byte)Math.Min(byte.MaxValue, Stats[Stat.SkillGainMultiplier]);
            
            if (Level == ushort.MaxValue) exp = byte.MaxValue;

            int oldLevel = magic.Level;

            switch (magic.Level)
            {
                case 0:
                    if (Level < magic.Info.Level1)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need1)
                    {
                        magic.Level++;
                        magic.Experience = (ushort)(magic.Experience - magic.Info.Need1);
                        RefreshStats();
                    }
                    break;
                case 1:
                    if (Level < magic.Info.Level2)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need2)
                    {
                        magic.Level++;
                        magic.Experience = (ushort)(magic.Experience - magic.Info.Need2);
                        RefreshStats();
                    }
                    break;
                case 2:
                    if (Level < magic.Info.Level3)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need3)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                case 3:
                    if (Level < magic.Info.Level4)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need4)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                case 4:
                    if (Level < magic.Info.Level5)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need5)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                case 5:
                    if (Level < magic.Info.Level6)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need6)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                case 6:
                    if (Level < magic.Info.Level7)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need7)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                case 7:
                    if (Level < magic.Info.Level8)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need8)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                case 8:
                    if (Level < magic.Info.Level9)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need9)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                case 9:
                    if (Level < magic.Info.Level10)
                        return;

                    magic.Experience += exp;
                    if (magic.Experience >= magic.Info.Need10)
                    {
                        magic.Level++;
                        magic.Experience = 0;
                        RefreshStats();
                    }
                    break;
                default:
                    return;
            }

            if (oldLevel != magic.Level)
            {
                long delay = magic.GetDelay();
                Enqueue(new S.MagicDelay { Spell = magic.Spell, Delay = delay });
            }

            Enqueue(new S.MagicLeveled { Spell = magic.Spell, Level = magic.Level, Experience = magic.Experience });

        }

        public bool CheckMovement(Point location)
        {
            if (Envir.Time < MovementTime) return false;

            //Script triggered coords
            for (int s = 0; s < CurrentMap.Info.ActiveCoords.Count; s++)
            {
                Point activeCoord = CurrentMap.Info.ActiveCoords[s];

                if (activeCoord != location) continue;

                CallDefaultNPC(DefaultNPCType.MapCoord, CurrentMap.Info.FileName, activeCoord.X, activeCoord.Y);
            }

            //Map movements
            for (int i = 0; i < CurrentMap.Info.Movements.Count; i++)
            {
                MovementInfo info = CurrentMap.Info.Movements[i];

                if (info.Source != location) continue;

                if (info.NeedHole)
                {
                    Cell cell = CurrentMap.GetCell(location);

                    if (cell.Objects == null ||
                cell.Objects.Where(ob => ob.Race == ObjectType.Spell).All(ob => ((SpellObject)ob).Spell != Spell.DigOutZombie && ((SpellObject)ob).Spell != Spell.DigOutArmadillo))
                        continue;
                }

                if (info.ConquestIndex > 0)
                {
                    if (MyGuild == null || MyGuild.Conquest == null) continue;
                    if (MyGuild.Conquest.Info.Index != info.ConquestIndex) continue;
                }

                if (info.NeedMove) //use with ENTERMAP npc command
                {
                    NPCData["NPCMoveMap"] = Envir.GetMap(info.MapIndex);
                    NPCData["NPCMoveCoord"] = info.Destination;
                    continue;
                }

                Map temp = Envir.GetMap(info.MapIndex);

                if (temp == null || !temp.ValidPoint(info.Destination)) continue;

                CurrentMap.RemoveObject(this);
                Broadcast(new S.ObjectRemove { ObjectID = ObjectID });

                CompleteMapMovement(temp, info.Destination, CurrentMap, CurrentLocation);
                return true;
            }

            return false;
        }
        private void CompleteMapMovement(params object[] data)
        {
            if (this == null) return;
            Map temp = (Map)data[0];
            Point destination = (Point)data[1];
            Map checkmap = (Map)data[2];
            Point checklocation = (Point)data[3];

            if (CurrentMap != checkmap || CurrentLocation != checklocation) return;

            bool mapChanged = temp != CurrentMap;

            CurrentMap = temp;
            CurrentLocation = destination;

            CurrentMap.AddObject(this);

            MovementTime = Envir.Time + MovementDelay;

            Enqueue(new S.MapChanged
            {
                FileName = CurrentMap.Info.FileName,
                Title = CurrentMap.Info.Title,
                MiniMap = CurrentMap.Info.MiniMap,
                BigMap = CurrentMap.Info.BigMap,
                Lights = CurrentMap.Info.Light,
                Location = CurrentLocation,
                Direction = Direction,
                MapDarkLight = CurrentMap.Info.MapDarkLight,
                Music = CurrentMap.Info.Music
            });

            if (RidingMount) RefreshMount();

            GetObjects();

            SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

            if (szi != null)
            {
                BindLocation = szi.Location;
                BindMapIndex = CurrentMapIndex;
                InSafeZone = true;
            }
            else
                InSafeZone = false;

            if (mapChanged)
            {
                CurrentRT = 0;
                CallDefaultNPC(DefaultNPCType.MapEnter, CurrentMap.Info.FileName);
                if (CurrentMap.Info.NoGroup &&
                    GroupMembers.Count > 0 &&
                    AllowGroup)
                {
                    SwitchGroup(false);
                    AllowGroup = true;
                }
            }

            if (Info.Married != 0)
            {
                CharacterInfo Lover = Envir.GetCharacterInfo(Info.Married);
                PlayerObject player = Envir.GetPlayer(Lover.Name);

                if (player != null) player.GetRelationship(false);
            }

            CheckConquest(true);
        }

        public override bool Teleport(Map temp, Point location, bool effects = true, byte effectnumber = 0)
        {
            Map oldMap = CurrentMap;
            Point oldLocation = CurrentLocation;

            bool mapChanged = temp != oldMap;

            if (!base.Teleport(temp, location, effects)) return false;

            Enqueue(new S.MapChanged
            {
                FileName = CurrentMap.Info.FileName,
                Title = CurrentMap.Info.Title,
                MiniMap = CurrentMap.Info.MiniMap,
                BigMap = CurrentMap.Info.BigMap,
                Lights = CurrentMap.Info.Light,
                Location = CurrentLocation,
                Direction = Direction,
                MapDarkLight = CurrentMap.Info.MapDarkLight,
                Music = CurrentMap.Info.Music
            });

            if (effects) Enqueue(new S.ObjectTeleportIn { ObjectID = ObjectID, Type = effectnumber });

            //Cancel actions
            if (TradePartner != null)
                TradeCancel();

            if (ItemRentalPartner != null)
                CancelItemRental();

            if (RidingMount) RefreshMount();
            if (ActiveBlizzard) ActiveBlizzard = false;

            GetObjectsPassive();

            SafeZoneInfo szi = CurrentMap.GetSafeZone(CurrentLocation);

            if (szi != null)
            {
                BindLocation = szi.Location;
                BindMapIndex = CurrentMapIndex;
                InSafeZone = true;
            }
            else
                InSafeZone = false;

            CheckConquest();

            Fishing = false;
            Enqueue(GetFishInfo());

            if (mapChanged)
            {
                CurrentRT = 0;
                CallDefaultNPC(DefaultNPCType.MapEnter, CurrentMap.Info.FileName);
                if (CurrentMap.Info.NoGroup &&
                    GroupMembers != null &&
                    GroupMembers.Count > 0 &&
                    AllowGroup)
                {
                    SwitchGroup(false);
                    AllowGroup = true;
                }

                if (Info.Married != 0)
                {
                    CharacterInfo Lover = Envir.GetCharacterInfo(Info.Married);
                    PlayerObject player = Envir.GetPlayer(Lover.Name);

                    if (player != null) player.GetRelationship(false);
                }
            }

            if (CheckStacked())
            {
                StackingTime = Envir.Time + 1000;
                Stacking = true;
            }

            Report.MapChange(oldMap.Info, CurrentMap.Info);

            return true;
        }
        public bool TeleportEscape(int attempts)
        {
            Map temp = Envir.GetMap(BindMapIndex);

            for (int i = 0; i < attempts; i++)
            {
                Point location = new Point(BindLocation.X + Envir.Random.Next(-100, 100),
                                           BindLocation.Y + Envir.Random.Next(-100, 100));

                if (Teleport(temp, location)) return true;
            }

            return false;
        }

        private Packet GetMountInfo()
        {
            return new S.MountUpdate
            {
                ObjectID = ObjectID,
                RidingMount = RidingMount,
                MountType = MountType
            };
        }
        private Packet GetUpdateInfo()
        {
            return new S.PlayerUpdate
            {
                ObjectID = ObjectID,
                Weapon = Looks_Weapon,
				WeaponEffect = Looks_WeaponEffect,
				Armour = Looks_Armour,
                Light = Light,
                WingEffect = Looks_Wings
            };
        }

        public override Packet GetInfo()
        {
            //should never use this but i leave it in for safety
            if (Observer) return null;

            string gName = "";
            string conquest = "";
            if (MyGuild != null)
            {
                gName = MyGuild.Name;
                if (MyGuild.Conquest != null)
                {
                    conquest = "[" + MyGuild.Conquest.Info.Name + "]";
                    gName = gName + conquest;
                }
                    
            }

            return new S.ObjectPlayer
            {
                ObjectID = ObjectID,
                Name = CurrentMap.Info.NoNames ? "?????" : Name,
                NameColour = NameColour,
                GuildName = CurrentMap.Info.NoNames ? "?????" : gName,
                GuildRankName = CurrentMap.Info.NoNames ? "?????" : MyGuildRank != null ? MyGuildRank.Name : "",
                Class = Class,
                Gender = Gender,
                Level = Level,
                Location = CurrentLocation,
                Direction = Direction,
                Hair = Hair,
                Weapon = Looks_Weapon,
				WeaponEffect = Looks_WeaponEffect,
				Armour = Looks_Armour,
                Light = Light,
                Poison = CurrentPoison,
                Dead = Dead,
                Hidden = Hidden,
                Effect = HasBuff(BuffType.MagicShield, out _) ? SpellEffect.MagicShieldUp : HasBuff(BuffType.ElementalBarrier, out _) ? SpellEffect.ElementalBarrierUp : SpellEffect.None,
                WingEffect = Looks_Wings,
                MountType = MountType,
                RidingMount = RidingMount,
                Fishing = Fishing,

                TransformType = TransformType,

                ElementOrbEffect = (uint)GetElementalOrbCount(),
                ElementOrbLvl = (uint)ElementsLevel,
                ElementOrbMax = (uint)Settings.OrbsExpList[Settings.OrbsExpList.Count - 1],

                Buffs = Buffs.Where(d => d.Info.Visible).Select(e => e.Type).ToList(),

                LevelEffects = LevelEffects
            };
        }
        public Packet GetInfoEx(PlayerObject player)
        {
            var p = (S.ObjectPlayer)GetInfo();

            if (p != null)
            {
                p.NameColour = GetNameColour(player);
            }

            return p;
        }

        public override bool IsAttackTarget(PlayerObject attacker)
        {
            if (attacker == null || attacker.Node == null) return false;
            if (Dead || InSafeZone || attacker.InSafeZone || attacker == this || GMGameMaster) return false;
            if (CurrentMap.Info.NoFight) return false;

            switch (attacker.AMode)
            {
                case AttackMode.All:
                    return true;
                case AttackMode.Group:
                    return GroupMembers == null || !GroupMembers.Contains(attacker);
                case AttackMode.Guild:
                    return MyGuild == null || MyGuild != attacker.MyGuild;
                case AttackMode.EnemyGuild:
                    return MyGuild != null && MyGuild.IsEnemy(attacker.MyGuild);
                case AttackMode.Peace:
                    return false;
                case AttackMode.RedBrown:
                    return PKPoints >= 200 || Envir.Time < BrownTime;
            }

            return true;
        }
        public override bool IsAttackTarget(MonsterObject attacker)
        {
            if (attacker == null || attacker.Node == null) return false;
            if (Dead || attacker.Master == this || GMGameMaster) return false;
            if (attacker.Info.AI == 6 || attacker.Info.AI == 58 || attacker.Info.AI == 113) return PKPoints >= 200;
            if (attacker.Master == null) return true;
            if (InSafeZone || attacker.InSafeZone || attacker.Master.InSafeZone) return false;

            if (LastHitter != attacker.Master && attacker.Master.LastHitter != this)
            {
                bool target = false;

                for (int i = 0; i < attacker.Master.Pets.Count; i++)
                {
                    if (attacker.Master.Pets[i].Target != this) continue;

                    target = true;
                    break;
                }

                if (!target)
                    return false;
            }

            switch (attacker.Master.AMode)
            {
                case AttackMode.All:
                    return true;
                case AttackMode.Group:
                    return GroupMembers == null || !GroupMembers.Contains(attacker.Master);
                case AttackMode.Guild:
                    return true;
                case AttackMode.EnemyGuild:
                    return false;
                case AttackMode.Peace:
                    return false;
                case AttackMode.RedBrown:
                    return PKPoints >= 200 || Envir.Time < BrownTime;
            }

            return true;
        }

        public override bool IsFriendlyTarget(PlayerObject ally)
        {
            if (ally == this) return true;

            switch (ally.AMode)
            {
                case AttackMode.Group:
                    return GroupMembers != null && GroupMembers.Contains(ally);
                case AttackMode.RedBrown:
                    return PKPoints < 200 & Envir.Time > BrownTime;
                case AttackMode.Guild:
                    return MyGuild != null && MyGuild == ally.MyGuild;
                case AttackMode.EnemyGuild:
                    return true;
            }
            return true;
        }
        public override bool IsFriendlyTarget(MonsterObject ally)
        {
            if (ally.Race != ObjectType.Monster) return false;
            if (ally.Master == null) return false;

            switch (ally.Master.Race)
            {
                case ObjectType.Player:
                    if (!ally.Master.IsFriendlyTarget(this)) return false;
                    break;
                case ObjectType.Monster:
                    return false;
            }

            return true;
        }
        public override int Attacked(PlayerObject attacker, int damage, DefenceType type = DefenceType.ACAgility, bool damageWeapon = true)
        {
            var armour = GetArmour(type, attacker, out bool hit);

            if (!hit)
            {
                return 0;
            }

            armour = (int)Math.Max(int.MinValue, (Math.Min(int.MaxValue, (decimal)(armour * ArmourRate))));
            damage = (int)Math.Max(int.MinValue, (Math.Min(int.MaxValue, (decimal)(damage * DamageRate))));

            if (damageWeapon)
                attacker.DamageWeapon();

            //damage += attacker.Stats[Stat.PVPDamage];
            damage += damage * attacker.Stats[Stat.PVPDamage] / 100;

            if (Envir.Random.Next(100) < Stats[Stat.Reflect])
            {
                if (attacker.IsAttackTarget(this))
                {
                    attacker.Attacked(this, damage, type, false);
                    CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.Reflect }, CurrentLocation);
                }
                return 0;
            }

            //MagicShield, ElementalBarrier
            if (Stats[Stat.DamageReductionPercent] > 0)
            {
                damage -= (damage * Stats[Stat.DamageReductionPercent]) / 100;
            }

            if (armour >= damage)
            {
                BroadcastDamageIndicator(DamageType.Miss);
                return 0;
            }

            if (Hidden)
            {
                RemoveBuff(BuffType.MoonLight);
                RemoveBuff(BuffType.DarkBody);
            }

            //EnergyShield
            if (Stats[Stat.EnergyShieldPercent] > 0)
            {
                if (Envir.Random.Next(100) < Stats[Stat.EnergyShieldPercent])
                {
                    if (HP + (Stats[Stat.EnergyShieldHPGain]) >= Stats[Stat.HP])
                        SetHP(Stats[Stat.HP]);
                    else
                        ChangeHP(Stats[Stat.EnergyShieldHPGain]);
                }
            }

            if (Envir.Random.Next(100) < (attacker.Stats[Stat.CriticalRate] * Settings.CriticalRateWeight))
            {
                CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.Critical }, CurrentLocation);
                damage = Math.Min(int.MaxValue, damage + (int)Math.Floor(damage * (((double)attacker.Stats[Stat.CriticalDamage] / (double)Settings.CriticalDamageWeight) * 1)));
                BroadcastDamageIndicator(DamageType.Critical);
            }

            if (HasBuff(BuffType.MagicShield, out Buff magicShield))
            {
                var duration = (int)Math.Min(int.MaxValue, magicShield.ExpireTime - Envir.Time - ((damage - armour) * 60));
                AddBuff(BuffType.MagicShield, this, duration, null);
            }

            if (HasBuff(BuffType.ElementalBarrier, out Buff elementalBarrier))
            {
                var duration = (int)Math.Min(int.MaxValue, elementalBarrier.ExpireTime - Envir.Time - ((damage - armour) * 60));
                AddBuff(BuffType.ElementalBarrier, this, duration, null);
            }

            if (attacker.Stats[Stat.HPDrainRatePercent] > 0)
            {
                attacker.HpDrain += Math.Max(0, ((float)(damage - armour) / 100) * attacker.Stats[Stat.HPDrainRatePercent]);
                if (attacker.HpDrain > 2)
                {
                    int HpGain = (int)Math.Floor(attacker.HpDrain);
                    attacker.ChangeHP(HpGain);
                    attacker.HpDrain -= HpGain;
                }
            }

            for (int i = PoisonList.Count - 1; i >= 0; i--)
            {
                if (PoisonList[i].PType != PoisonType.LRParalysis) continue;

                PoisonList.RemoveAt(i);
                OperateTime = 0;
            }

            LastHitter = attacker;
            LastHitTime = Envir.Time + 10000;
            //RegenTime = Envir.Time + RegenDelay;
            RegenStandTime = Envir.Time + Settings.RegenStandDelay;
            LogTime = Envir.Time + Globals.LogDelay;

            if (Envir.Time > BrownTime && PKPoints < 200 && !AtWar(attacker))
                attacker.BrownTime = Envir.Time + Settings.Minute;

            ushort LevelOffset = (byte)(Level > attacker.Level ? 0 : Math.Min(10, attacker.Level - Level));

            ApplyNegativeEffects(attacker, type, LevelOffset);

            attacker.GatherElement();

            DamageDura();
            ActiveBlizzard = false;
            ActiveReincarnation = false;

            CounterAttackCast(GetMagic(Spell.CounterAttack), LastHitter);

            Enqueue(new S.Struck { AttackerID = attacker.ObjectID });
            Broadcast(new S.ObjectStruck { ObjectID = ObjectID, AttackerID = attacker.ObjectID, Direction = Direction, Location = CurrentLocation });

            BroadcastDamageIndicator(DamageType.Hit, armour - damage);

            ChangeHP(armour - damage);
            return damage - armour;
        }
        public override int Attacked(MonsterObject attacker, int damage, DefenceType type = DefenceType.ACAgility)
        {
            var armour = GetArmour(type, attacker, out bool hit);

            if (!hit)
            {
                return 0;
            }

            if (Envir.Random.Next(100) < Stats[Stat.Reflect])
            {
                if (attacker.IsAttackTarget(this))
                {
                    attacker.Attacked(this, damage, type, false);
                    CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.Reflect }, CurrentLocation);
                }
                return 0;
            }

            armour = (int)Math.Max(int.MinValue, (Math.Min(int.MaxValue, (decimal)(armour * ArmourRate))));
            damage = (int)Math.Max(int.MinValue, (Math.Min(int.MaxValue, (decimal)(damage * DamageRate))));

            //MagicShield, ElementalBarrier
            if (Stats[Stat.DamageReductionPercent] != 0)
            {
                damage -= (damage * Stats[Stat.DamageReductionPercent]) / 100;
            }

            if (armour >= damage)
            {
                BroadcastDamageIndicator(DamageType.Miss);
                return 0;
            }

            if (Hidden)
            {
                RemoveBuff(BuffType.MoonLight);
                RemoveBuff(BuffType.DarkBody);
            }

            if (Stats[Stat.EnergyShieldPercent] > 0)
            {
                if (Envir.Random.Next(100) < Stats[Stat.EnergyShieldPercent])
                {
                    if (HP + (Stats[Stat.EnergyShieldHPGain]) >= Stats[Stat.HP])
                        SetHP(Stats[Stat.HP]);
                    else
                        ChangeHP(Stats[Stat.EnergyShieldHPGain]);
                }
            }

            if (HasBuff(BuffType.MagicShield, out Buff magicShield))
            {
                var duration = (int)Math.Min(int.MaxValue, magicShield.ExpireTime - Envir.Time - ((damage - armour) * 60));
                AddBuff(BuffType.MagicShield, this, duration, null);
            }

            if (HasBuff(BuffType.ElementalBarrier, out Buff elementalBarrier))
            {
                var duration = (int)Math.Min(int.MaxValue, elementalBarrier.ExpireTime - Envir.Time - ((damage - armour) * 60));
                AddBuff(BuffType.ElementalBarrier, this, duration, null);
            }

            for (int i = PoisonList.Count - 1; i >= 0; i--)
            {
                if (PoisonList[i].PType != PoisonType.LRParalysis) continue;

                PoisonList.RemoveAt(i);
                OperateTime = 0;
            }

            LastHitter = attacker.Master ?? attacker;
            LastHitTime = Envir.Time + 10000;
            //RegenTime = Envir.Time + RegenDelay;
            RegenStandTime = Envir.Time + Settings.RegenStandDelay;
            LogTime = Envir.Time + Globals.LogDelay;

            DamageDura();
            ActiveBlizzard = false;
            ActiveReincarnation = false;

            CounterAttackCast(GetMagic(Spell.CounterAttack), LastHitter);

            if (StruckTime < Envir.Time)
            {
                Enqueue(new S.Struck { AttackerID = attacker.ObjectID });
                Broadcast(new S.ObjectStruck { ObjectID = ObjectID, AttackerID = attacker.ObjectID, Direction = Direction, Location = CurrentLocation });
                StruckTime = Envir.Time + 500;
            }

            BroadcastDamageIndicator(DamageType.Hit, armour - damage);

            ChangeHP(armour - damage);
            return damage - armour;
        }
        public override int Struck(int damage, DefenceType type = DefenceType.ACAgility)
        {
            int armour = 0;

            if (Hidden)
            {
                RemoveBuff(BuffType.MoonLight);
                RemoveBuff(BuffType.DarkBody);
            }

            switch (type)
            {
                case DefenceType.ACAgility:
                    armour = GetAttackPower(Stats[Stat.MinAC], Stats[Stat.MaxAC]);
                    break;
                case DefenceType.AC:
                    armour = GetAttackPower(Stats[Stat.MinAC], Stats[Stat.MaxAC]);
                    break;
                case DefenceType.MACAgility:
                    armour = GetAttackPower(Stats[Stat.MinMAC], Stats[Stat.MaxMAC]);
                    break;
                case DefenceType.MAC:
                    armour = GetAttackPower(Stats[Stat.MinMAC], Stats[Stat.MaxMAC]);
                    break;
                case DefenceType.Agility:
                    break;
            }

            armour = (int)Math.Max(int.MinValue, (Math.Min(int.MaxValue, (decimal)(armour * ArmourRate))));
            damage = (int)Math.Max(int.MinValue, (Math.Min(int.MaxValue, (decimal)(damage * DamageRate))));

            //MagicShield, ElementalBarrier
            if (Stats[Stat.DamageReductionPercent] != 0)
            {
                damage -= (damage * Stats[Stat.DamageReductionPercent]) / 100;
            }

            if (armour >= damage) return 0;

            if (HasBuff(BuffType.MagicShield, out Buff magicShield))
            {
                var duration = (int)Math.Min(int.MaxValue, magicShield.ExpireTime - Envir.Time - ((damage - armour) * 60));
                AddBuff(BuffType.MagicShield, this, duration, null);
            }

            if (HasBuff(BuffType.ElementalBarrier, out Buff elementalBarrier))
            {
                var duration = (int)Math.Min(int.MaxValue, elementalBarrier.ExpireTime - Envir.Time - ((damage - armour) * 60));
                AddBuff(BuffType.ElementalBarrier, this, duration, null);
            }

            //RegenTime = Envir.Time + RegenDelay;
            LogTime = Envir.Time + Globals.LogDelay;

            DamageDura();
            ActiveBlizzard = false;
            ActiveReincarnation = false;
            Enqueue(new S.Struck { AttackerID = 0 });
            Broadcast(new S.ObjectStruck { ObjectID = ObjectID, AttackerID = 0, Direction = Direction, Location = CurrentLocation });

            ChangeHP(armour - damage);
            return damage - armour;
        }

        public override void ApplyPoison(Poison p, MapObject Caster = null, bool NoResist = false, bool ignoreDefence = true)
        {
            if (Caster != null && !NoResist)
            {
                if (((Caster.Race != ObjectType.Player) || Settings.PvpCanResistPoison) && (Envir.Random.Next(Settings.PoisonResistWeight) < Stats[Stat.PoisonResist]))
                {
                    return;
                }
            }

            if (!ignoreDefence && (p.PType == PoisonType.Green))
            {
                int armour = GetAttackPower(Stats[Stat.MinMAC], Stats[Stat.MaxMAC]);

                if (p.Value < armour)
                    p.PType = PoisonType.None;
                else
                    p.Value -= armour;
            }

            if (p.Owner != null && p.Owner.Race == ObjectType.Player && Envir.Time > BrownTime && PKPoints < 200)
                p.Owner.BrownTime = Envir.Time + Settings.Minute;

            if ((p.PType == PoisonType.Green) || (p.PType == PoisonType.Red)) p.Duration = Math.Max(0, p.Duration - Stats[Stat.PoisonRecovery]);
            if (p.Duration == 0) return;
            if (p.PType == PoisonType.None) return;

            for (int i = 0; i < PoisonList.Count; i++)
            {
                if (PoisonList[i].PType != p.PType) continue;
                if ((PoisonList[i].PType == PoisonType.Green) && (PoisonList[i].Value > p.Value)) return;//cant cast weak poison to cancel out strong poison
                if ((PoisonList[i].PType != PoisonType.Green) && ((PoisonList[i].Duration - PoisonList[i].Time) > p.Duration)) return;//cant cast 1 second poison to make a 1minute poison go away!
                if ((PoisonList[i].PType == PoisonType.Frozen) || (PoisonList[i].PType == PoisonType.Slow) || (PoisonList[i].PType == PoisonType.Paralysis) || (PoisonList[i].PType == PoisonType.LRParalysis)) return;//prevents mobs from being perma frozen/slowed
                if (p.PType == PoisonType.DelayedExplosion) return;

                ReceiveChat(GameLanguage.BeenPoisoned, ChatType.System2);
                PoisonList[i] = p;
                return;
            }

            if (p.PType == PoisonType.DelayedExplosion)
            {
                ExplosionInflictedTime = Envir.Time + 4000;
                Enqueue(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion });
                Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.DelayedExplosion });
                ReceiveChat("You are a walking explosive.", ChatType.System);
            }
            else
                ReceiveChat(GameLanguage.BeenPoisoned, ChatType.System2);

            PoisonList.Add(p);
        }

        public override Buff AddBuff(BuffType type, MapObject owner, int duration, Stats stats, bool refreshStats = true, params int[] values)
        {
            Buff b = base.AddBuff(type, owner, duration, stats, refreshStats, values);

            switch (b.Type)
            {
                case BuffType.MagicShield:
                    CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.MagicShieldUp }, CurrentLocation);
                    break;
                case BuffType.ElementalBarrier:
                    CurrentMap.Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = SpellEffect.ElementalBarrierUp }, CurrentLocation);
                    break;
            }

            var packet = new S.AddBuff { Buff = b.ToClientBuff() };

            if (!b.Paused)
            {
                packet.Buff.ExpireTime -= Envir.Time;
            }

            Enqueue(packet);

            if (b.Info.Visible)
            {
                Broadcast(packet);
            }

            if (refreshStats)
            {
                RefreshStats();
            }

            return b;
        }

        public override void PauseBuff(Buff b)
        {
            if (b.Paused) return;

            base.PauseBuff(b);

            Enqueue(new S.PauseBuff { Type = b.Type, ObjectID = ObjectID, Paused = true });
        }

        public override void UnpauseBuff(Buff b)
        {
            if (!b.Paused) return;

            base.UnpauseBuff(b);

            Enqueue(new S.PauseBuff { Type = b.Type, ObjectID = ObjectID, Paused = false });
        }

        public void EquipSlotItem(MirGridType grid, ulong id, int to, MirGridType gridTo, ulong idTo)
        {
            S.EquipSlotItem p = new S.EquipSlotItem { Grid = grid, UniqueID = id, To = to, GridTo = gridTo, Success = false };

            UserItem Item = null;

            switch (gridTo)
            {
                case MirGridType.Mount:
                    Item = Info.Equipment[(int)EquipmentSlot.Mount];
                    break;
                case MirGridType.Fishing:
                    Item = Info.Equipment[(int)EquipmentSlot.Weapon];
                    break;
                case MirGridType.Socket:
                    UserItem temp2;
                    for (int i = 0; i < Info.Equipment.Length; i++)
                    {
                        temp2 = Info.Equipment[i];
                        if (temp2 == null || temp2.UniqueID != idTo) continue;
                        Item = temp2;
                        break;
                    }
                    for (int i = 0; i < Info.Inventory.Length; i++)
                    {
                        temp2 = Info.Inventory[i];
                        if (temp2 == null || temp2.UniqueID != idTo) continue;
                        Item = temp2;
                        break;
                    }
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            if (Item == null || Item.Slots == null)
            {
                Enqueue(p);
                return;
            }

            if (gridTo == MirGridType.Fishing && !Item.Info.IsFishingRod)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Item.Slots.Length)
            {
                Enqueue(p);
                return;
            }

            if (Item.Slots[to] != null)
            {
                Enqueue(p);
                return;
            }

            UserItem[] array;
            switch (grid)
            {
                case MirGridType.Inventory:
                    array = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    
                    if (Info.Equipment[to] != null &&
                        Info.Equipment[to].Info.Bind.HasFlag(BindMode.DontStore))
                    {
                        Enqueue(p);
                        return;
                    }
                    array = Account.Storage;
                    break;
                default:
                    Enqueue(p);
                    return;
            }


            int index = -1;
            UserItem temp = null;

            for (int i = 0; i < array.Length; i++)
            {
                temp = array[i];
                if (temp == null || temp.UniqueID != id) continue;
                index = i;
                break;
            }

            if (temp == null || index == -1)
            {
                Enqueue(p);
                return;
            }

            if ((Item.Info.IsFishingRod || Item.Info.Type == ItemType.Mount) && temp.Info.Type == ItemType.Socket)
            {
                Enqueue(p);
                return;
            }

            if ((temp.SoulBoundId != -1) && (temp.SoulBoundId != Info.Index))
            {
                Enqueue(p);
                return;
            }

            if (CanUseItem(temp))
            {
                if (temp.Info.NeedIdentify && !temp.Identified)
                {
                    temp.Identified = true;
                    Enqueue(new S.RefreshItem { Item = temp });
                }

                switch(temp.Info.Shape)
                {
                    case 1:
                        if (Item.Info.Type != ItemType.Weapon)
                        {
                            Enqueue(p);
                            return;
                        }
                        break;
                    case 2:
                        if (Item.Info.Type != ItemType.Armour)
                        {
                            Enqueue(p);
                            return;
                        }
                        break;
                    case 3:
                        if (Item.Info.Type != ItemType.Ring && Item.Info.Type != ItemType.Bracelet && Item.Info.Type != ItemType.Necklace)
                        {
                            Enqueue(p);
                            return;
                        }
                        break;
                }

                //if ((temp.Info.BindOnEquip) && (temp.SoulBoundId == -1))
                //{
                //    temp.SoulBoundId = Info.Index;
                //    Enqueue(new S.RefreshItem { Item = temp });
                //}
                //if (UnlockCurse && Info.Equipment[to].Cursed)
                //    UnlockCurse = false;

                Item.Slots[to] = temp;
                array[index] = null;

                p.Success = true;
                Enqueue(p);
                RefreshStats();

                Report.ItemMoved(temp, grid, gridTo, index, to);

                return;
            }

            Enqueue(p);
        }
        public void RemoveItem(MirGridType grid, ulong id, int to)
        {
            S.RemoveItem p = new S.RemoveItem { Grid = grid, UniqueID = id, To = to, Success = false };
            UserItem[] array;
            switch (grid)
            {
                case MirGridType.Inventory:
                    array = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    array = Account.Storage;
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            if (to < 0 || to >= array.Length) return;

            UserItem temp = null;
            int index = -1;

            for (int i = 0; i < Info.Equipment.Length; i++)
            {
                temp = Info.Equipment[i];
                if (temp == null || temp.UniqueID != id) continue;
                index = i;
                break;
            }

            if (temp == null || index == -1)
            {
                Enqueue(p);
                return;
            }

            if (temp.Cursed && !UnlockCurse)
            {
                Enqueue(p);
                return;
            }

            if (temp.WeddingRing != -1)
            {
                Enqueue(p);
                return;
            }

            if (temp.Info.Bind.HasFlag(BindMode.DontStore) && grid == MirGridType.Storage)
            {
                Enqueue(p);
                return;
            }

            if (!CanRemoveItem(grid, temp)) return;

            if (temp.Cursed)
                UnlockCurse = false;

            if (array[to] == null)
            {
                Info.Equipment[index] = null;

                array[to] = temp;
                p.Success = true;
                Enqueue(p);
                RefreshStats();
                Broadcast(GetUpdateInfo());

                Report.ItemMoved(temp, MirGridType.Equipment, grid, index, to);

                return;
            }

            Enqueue(p);
        }
        public void RemoveSlotItem(MirGridType grid, ulong id, int to, MirGridType gridTo, ulong idFrom)
        {
            S.RemoveSlotItem p = new S.RemoveSlotItem { Grid = grid, UniqueID = id, To = to, GridTo = gridTo, Success = false };
            UserItem[] array;
            switch (gridTo)
            {
                case MirGridType.Inventory:
                    array = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    array = Account.Storage;
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            if (to < 0 || to >= array.Length) return;

            UserItem temp = null;
            UserItem slotTemp = null;
            int index = -1;

            switch (grid)
            {
                case MirGridType.Mount:
                    temp = Info.Equipment[(int)EquipmentSlot.Mount];
                    break;
                case MirGridType.Fishing:
                    temp = Info.Equipment[(int)EquipmentSlot.Weapon];
                    break;
                case MirGridType.Socket:
                    UserItem temp2;
                    for (int i = 0; i < Info.Equipment.Length; i++)
                    {
                        temp2 = Info.Equipment[i];
                        if (temp2 == null || temp2.UniqueID != idFrom) continue;
                        temp = temp2;
                        break;
                    }
                    for (int i = 0; i < Info.Inventory.Length; i++)
                    {
                        temp2 = Info.Inventory[i];
                        if (temp2 == null || temp2.UniqueID != idFrom) continue;
                        temp = temp2;
                        break;
                    }
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            if (temp == null || temp.Slots == null)
            {
                Enqueue(p);
                return;
            }

            if (grid == MirGridType.Fishing && !temp.Info.IsFishingRod)
            {
                Enqueue(p);
                return;
            }

            for (int i = 0; i < temp.Slots.Length; i++)
            {
                slotTemp = temp.Slots[i];
                if (slotTemp == null || slotTemp.UniqueID != id) continue;
                index = i;
                break;
            }

            if (slotTemp == null || index == -1)
            {
                Enqueue(p);
                return;
            }

            if (slotTemp.Cursed && !UnlockCurse)
            {
                Enqueue(p);
                return;
            }

            if (slotTemp.WeddingRing != -1)
            {
                Enqueue(p);
                return;
            }

            if (!CanRemoveItem(gridTo, slotTemp)) return;

            temp.Slots[index] = null;

            if (slotTemp.Cursed)
                UnlockCurse = false;

            if (array[to] == null)
            {
                array[to] = slotTemp;
                p.Success = true;
                Enqueue(p);
                RefreshStats();
                Broadcast(GetUpdateInfo());

                Report.ItemMoved(temp, grid, gridTo, index, to);

                return;
            }

            Enqueue(p);
        }
        public void MoveItem(MirGridType grid, int from, int to)
        {
            S.MoveItem p = new S.MoveItem { Grid = grid, From = from, To = to, Success = false };
            UserItem[] array;
            switch (grid)
            {
                case MirGridType.Inventory:
                    array = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    array = Account.Storage;
                    break;
                case MirGridType.Trade:
                    array = Info.Trade;
                    TradeItem();
                    break;
                case MirGridType.Refine:
                    array = Info.Refine;
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            if (from >= 0 && to >= 0 && from < array.Length && to < array.Length)
            {
                if (array[from] == null)
                {
                    Report.ItemError(grid, grid, from, to);
                    ReceiveChat("Item Move Error - Please report the item you tried to move and the time", ChatType.System);
                    Enqueue(p);
                    return;
                }

                UserItem i = array[to];
                array[to] = array[from];

                Report.ItemMoved(array[to], grid, grid, from, to);

                array[from] = i;

                Report.ItemMoved(array[from], grid, grid, to, from);
                
                p.Success = true;
                Enqueue(p);
                return;
            }

            Enqueue(p);
        }
        public void StoreItem(int from, int to)
        {
            S.StoreItem p = new S.StoreItem { From = from, To = to, Success = false };

            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
            {
                Enqueue(p);
                return;
            }
            NPCObject ob = null;
            for (int i = 0; i < CurrentMap.NPCs.Count; i++)
            {
                if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                ob = CurrentMap.NPCs[i];             
                break;
            }

            if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
            {
                Enqueue(p);
                return;
            }


            if (from < 0 || from >= Info.Inventory.Length)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Account.Storage.Length)
            {
                Enqueue(p);
                return;
            }

            UserItem temp = Info.Inventory[from];

            if (temp == null)
            {
                Enqueue(p);
                return;
            }

            if (temp.Info.Bind.HasFlag(BindMode.DontStore))
            {
                Enqueue(p);
                return;
            }

            if (temp.RentalInformation != null && temp.RentalInformation.BindingFlags.HasFlag(BindMode.DontStore))
            {
                Enqueue(p);
                return;
            }

            if (Account.Storage[to] == null)
            {
                Account.Storage[to] = temp;
                Info.Inventory[from] = null;
                RefreshBagWeight();

                Report.ItemMoved(temp, MirGridType.Inventory, MirGridType.Storage, from, to);

                p.Success = true;
                Enqueue(p);
                return;
            }
            Enqueue(p);
        }
        public void TakeBackItem(int from, int to)
        {
            S.TakeBackItem p = new S.TakeBackItem { From = from, To = to, Success = false };

            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
            {
                Enqueue(p);
                return;
            }
            NPCObject ob = null;
            for (int i = 0; i < CurrentMap.NPCs.Count; i++)
            {
                if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                ob = CurrentMap.NPCs[i];
                break;
            }

            if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
            {
                Enqueue(p);
                return;
            }


            if (from < 0 || from >= Account.Storage.Length)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Info.Inventory.Length)
            {
                Enqueue(p);
                return;
            }

            UserItem temp = Account.Storage[from];

            if (temp == null)
            {
                Enqueue(p);
                return;
            }

            if (temp.Weight + CurrentBagWeight > Stats[Stat.BagWeight])
            {
                ReceiveChat("Too heavy to get back.", ChatType.System);
                Enqueue(p);
                return;
            }

            if (Info.Inventory[to] == null)
            {
                Info.Inventory[to] = temp;
                Account.Storage[from] = null;

                Report.ItemMoved(temp, MirGridType.Storage, MirGridType.Inventory, from, to);

                p.Success = true;
                RefreshBagWeight();
                Enqueue(p);

                return;
            }
            Enqueue(p);
        }
        public void EquipItem(MirGridType grid, ulong id, int to)
        {
            S.EquipItem p = new S.EquipItem { Grid = grid, UniqueID = id, To = to, Success = false };

            if (Fishing)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Info.Equipment.Length)
            {
                Enqueue(p);
                return;
            }

            UserItem[] array;
            switch (grid)
            {
                case MirGridType.Inventory:
                    array = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    array = Account.Storage;
                    break;
                default:
                    Enqueue(p);
                    return;
            }


            int index = -1;
            UserItem temp = null;

            for (int i = 0; i < array.Length; i++)
            {
                temp = array[i];
                if (temp == null || temp.UniqueID != id) continue;
                index = i;
                break;
            }

            if (temp == null || index == -1)
            {
                Enqueue(p);
                return;
            }
            if ((Info.Equipment[to] != null) && (Info.Equipment[to].Cursed) && (!UnlockCurse))
            {
                Enqueue(p);
                return;
            }

            if ((temp.SoulBoundId != -1) && (temp.SoulBoundId != Info.Index))
            {
                Enqueue(p);
                return;
            }

            if (Info.Equipment[to] != null)
                if (Info.Equipment[to].WeddingRing != -1)
                {
                    Enqueue(p);
                    return;
                }
            if (Info.Equipment[to] != null &&
                Info.Equipment[to].Info.Bind.HasFlag(BindMode.DontStore))
            {
                Enqueue(p);
                return;
            }

            if (CanEquipItem(temp, to))
            {
                if (temp.Info.NeedIdentify && !temp.Identified)
                {
                    temp.Identified = true;
                    Enqueue(new S.RefreshItem { Item = temp });
                }
                if ((temp.Info.Bind.HasFlag(BindMode.BindOnEquip)) && (temp.SoulBoundId == -1))
                {
                    temp.SoulBoundId = Info.Index;
                    Enqueue(new S.RefreshItem { Item = temp });
                }

                if ((Info.Equipment[to] != null) && (Info.Equipment[to].Cursed) && (UnlockCurse))
                    UnlockCurse = false;

                array[index] = Info.Equipment[to];

                Report.ItemMoved(temp, MirGridType.Equipment, grid, to, index, "RemoveItem");

                Info.Equipment[to] = temp;

                Report.ItemMoved(temp, grid, MirGridType.Equipment, index, to);

                p.Success = true;
                Enqueue(p);
                RefreshStats();

                //Broadcast(GetUpdateInfo());
                return;
            }
            Enqueue(p);
        }
        public void BreakTimeRecall()
        {
            foreach (DelayedAction ac in ActionList.Where(u => u.Type == DelayedType.NPC))
            {
                ac.FlaggedToRemove = true;
            }
            ExpireTimer("RecallTimer");
        }
        public void UseItem(ulong id)
        {
            S.UseItem p = new S.UseItem { UniqueID = id, Success = false };

            UserItem item = null;
            int index = -1;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                item = Info.Inventory[i];
                if (item == null || item.UniqueID != id) continue;
                index = i;
                break;
            }

            if (item == null || index == -1 || !CanUseItem(item))
            {
                Enqueue(p);
                return;
            }

            if (Dead && !(item.Info.Type == ItemType.Scroll && item.Info.Shape == 6))
            {
                Enqueue(p);
                return;
            }

            switch (item.Info.Type)
            {
                case ItemType.Potion:
                    switch (item.Info.Shape)
                    {
                        case 0: //NormalPotion
                            PotHealthAmount = (ushort)Math.Min(ushort.MaxValue, PotHealthAmount + item.Info.Stats[Stat.HP]);
                            PotManaAmount = (ushort)Math.Min(ushort.MaxValue, PotManaAmount + item.Info.Stats[Stat.MP]);
                            break;
                        case 1: //SunPotion
                            ChangeHP(item.Info.Stats[Stat.HP]);
                            ChangeMP(item.Info.Stats[Stat.MP]);
                            break;
                        case 2: //MysteryWater
                            if (UnlockCurse)
                            {
                                ReceiveChat("You can already unequip a cursed item.", ChatType.Hint);
                                Enqueue(p);
                                return;
                            }
                            ReceiveChat("You can now unequip a cursed item.", ChatType.Hint);
                            UnlockCurse = true;
                            break;
                        case 3: //Buff
                            {
                                int time = item.Info.Durability;

                                if (item.GetTotal(Stat.MaxDC) > 0)
                                    AddBuff(BuffType.Impact, this, time * Settings.Minute, new Stats { [Stat.MaxDC] = item.GetTotal(Stat.MaxDC) });

                                if (item.GetTotal(Stat.MaxMC) > 0)
                                    AddBuff(BuffType.Magic, this, time * Settings.Minute, new Stats { [Stat.MaxMC] = item.GetTotal(Stat.MaxMC) });

                                if (item.GetTotal(Stat.MaxSC) > 0)
                                    AddBuff(BuffType.Taoist, this, time * Settings.Minute, new Stats { [Stat.MaxSC] = item.GetTotal(Stat.MaxSC) });

                                if (item.GetTotal(Stat.AttackSpeed) > 0)
                                    AddBuff(BuffType.Storm, this, time * Settings.Minute, new Stats { [Stat.AttackSpeed] = item.GetTotal(Stat.AttackSpeed) });

                                if (item.GetTotal(Stat.HP) > 0)
                                    AddBuff(BuffType.HealthAid, this, time * Settings.Minute, new Stats { [Stat.HP] = item.GetTotal(Stat.HP) });

                                if (item.GetTotal(Stat.MP) > 0)
                                    AddBuff(BuffType.ManaAid, this, time * Settings.Minute, new Stats { [Stat.MP] = item.GetTotal(Stat.MP) });

                                if (item.GetTotal(Stat.MaxAC) > 0)
                                    AddBuff(BuffType.Defence, this, time * Settings.Minute, new Stats { [Stat.MaxAC] = item.GetTotal(Stat.MaxAC) });

                                if (item.GetTotal(Stat.MaxMAC) > 0)
                                    AddBuff(BuffType.MagicDefence, this, time * Settings.Minute, new Stats { [Stat.MaxMAC] = item.GetTotal(Stat.MaxMAC) });

                                if (item.GetTotal(Stat.BagWeight) > 0)
                                    AddBuff(BuffType.BagWeight, this, time * Settings.Minute, new Stats { [Stat.BagWeight] = item.GetTotal(Stat.BagWeight) });
                            }
                            break;
                        case 4: //ExpRatePercent
                            {
                                int time = item.Info.Durability;
                                AddBuff(BuffType.ExpRatePercent, this, Settings.Minute * time, new Stats { [Stat.ExpRatePercent] = item.GetTotal(Stat.Luck) });
                            }
                            break;
                        case 5: //Drop
                            {
                                int time = item.Info.Durability;
                                AddBuff(BuffType.Drop, this, Settings.Minute * time, new Stats { [Stat.ItemDropRatePercent] = item.GetTotal(Stat.Luck) });
                            }
                            break;
                        case 6: //ExpRate
                            {
                                int time = item.Info.Durability;
                                AddBuff(BuffType.ExpRate, this, Settings.Minute * time, new Stats { [Stat.ExpRate] = item.GetTotal(Stat.Luck) });
                            }
                            break;
                        case 7: //Infinite Growth
                            {
                                var stats = new Stats
                                {
                                    [Stat.MinAC] = item.GetTotal(Stat.MinAC),
                                    [Stat.MaxAC] = item.GetTotal(Stat.MaxAC),
                                    [Stat.MinMAC] = item.GetTotal(Stat.MinMAC),
                                    [Stat.MaxMAC] = item.GetTotal(Stat.MaxMAC),
                                };

                                int time = item.Info.Durability;
                                AddBuff(BuffType.InfiniteBuff, this, Settings.Minute * time, stats);
                            }
                            break;
                        case 40: //HPRegen
                            {
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPDrugSmall, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 41:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPDrugMedium, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 42:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPDrugLarge, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 43:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPDrugXL, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 44:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPSMegaDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 45:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPMMegaDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 46:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPLMegaDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 47:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPXLMegaDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 48:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPSUltraDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 49:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPMUltraDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 50:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPLUltraDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 51:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPXLUltraDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 52:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPXXLUltraDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 53:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPSSupremeDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 54:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPMSupremeDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 55:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPLSupremeDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 56:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXXLSupremeDrug);   //57
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPXLSupremeDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 57:
                            {
                                RemoveBuff(BuffType.HPDrugSmall);  //40
                                RemoveBuff(BuffType.HPDrugMedium);  //41
                                RemoveBuff(BuffType.HPDrugLarge);   //42
                                RemoveBuff(BuffType.HPDrugXL);      //43
                                RemoveBuff(BuffType.HPSMegaDrug);  //44
                                RemoveBuff(BuffType.HPMMegaDrug);   //45
                                RemoveBuff(BuffType.HPLMegaDrug);    //46
                                RemoveBuff(BuffType.HPXLMegaDrug);    //47
                                RemoveBuff(BuffType.HPSUltraDrug);   //48
                                RemoveBuff(BuffType.HPMUltraDrug);   //49
                                RemoveBuff(BuffType.HPLUltraDrug);   //50
                                RemoveBuff(BuffType.HPXLUltraDrug);   //51
                                RemoveBuff(BuffType.HPXXLUltraDrug);   //52
                                RemoveBuff(BuffType.HPSSupremeDrug);   //53
                                RemoveBuff(BuffType.HPMSupremeDrug);   //54
                                RemoveBuff(BuffType.HPLSupremeDrug);   //55
                                RemoveBuff(BuffType.HPXLSupremeDrug);   //56
                                int time = item.Info.Durability;
                                AddBuff(BuffType.HPXXLSupremeDrug, this, Settings.Second * time, new Stats { [Stat.HealthRecovery] = item.GetTotal(Stat.HealthRecovery) });
                            }
                            break;
                        case 70: //MPRegen
                            {
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPDrugSmall, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 71:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPDrugMedium, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 72:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPDrugLarge, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 73:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPDrugXL, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 74:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPSMegaDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 75:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPMMegaDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 76:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPLMegaDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 77:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPXLMegaDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 78:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPSUltraDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 79:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPMUltraDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 80:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPLUltraDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 81:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPXLUltraDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 82:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPXXLUltraDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 83:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPSSupremeDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 84:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPMSupremeDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 85:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPLSupremeDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 86:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXXLSupremeDrug);   //87
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPXLSupremeDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                        case 87:
                            {
                                RemoveBuff(BuffType.MPDrugSmall);  //70
                                RemoveBuff(BuffType.MPDrugMedium);  //71
                                RemoveBuff(BuffType.MPDrugLarge);   //72
                                RemoveBuff(BuffType.MPDrugXL);      //73
                                RemoveBuff(BuffType.MPSMegaDrug);  //74
                                RemoveBuff(BuffType.MPMMegaDrug);   //75
                                RemoveBuff(BuffType.MPLMegaDrug);    //76
                                RemoveBuff(BuffType.MPXLMegaDrug);    //77
                                RemoveBuff(BuffType.MPSUltraDrug);   //78
                                RemoveBuff(BuffType.MPMUltraDrug);   //79
                                RemoveBuff(BuffType.MPLUltraDrug);   //80
                                RemoveBuff(BuffType.MPXLUltraDrug);   //81
                                RemoveBuff(BuffType.MPXXLUltraDrug);   //82
                                RemoveBuff(BuffType.MPSSupremeDrug);   //83
                                RemoveBuff(BuffType.MPMSupremeDrug);   //84
                                RemoveBuff(BuffType.MPLSupremeDrug);   //85
                                RemoveBuff(BuffType.MPXLSupremeDrug);   //86
                                int time = item.Info.Durability;
                                AddBuff(BuffType.MPXXLSupremeDrug, this, Settings.Second * time, new Stats { [Stat.SpellRecovery] = item.GetTotal(Stat.SpellRecovery) });
                            }
                            break;
                    }
                    break;
                case ItemType.Scroll:
                    UserItem temp;
                    switch (item.Info.Shape)
                    {
                        case 0: //DE
                            if (!TeleportEscape(20))
                            {
                                Enqueue(p);
                                return;
                            }
                            break;
                        case 1: //TT
                            if (!Teleport(Envir.GetMap(BindMapIndex), BindLocation))
                            {
                                Enqueue(p);
                                return;
                            }
                            else
                            {
                                BreakTimeRecall();
                            }
                            break;
                        case 2: //RT
                            if (CurrentMap.Info.RandomTeleport)
                            {
                                if (CurrentRT >= CurrentMap.Info.RandomTeleportCount)
                                {
                                    ReceiveChat(("Max random teleports reached on this map."), ChatType.System);
                                    Enqueue(p);
                                    return;
                                }

                                CurrentRT++;
                            }
                            if (!TeleportRandom(200, item.Info.Durability))
                            {
                                Enqueue(p);
                                return;
                            }
                            break;
                        case 3: //BenedictionOil
                            if (!TryLuckWeapon())
                            {
                                Enqueue(p);
                                return;
                            }
                            break;
                        case 4: //RepairOil
                            temp = Info.Equipment[(int)EquipmentSlot.Weapon];
                            if (temp == null || temp.MaxDura == temp.CurrentDura)
                            {
                                Enqueue(p);
                                return;
                            }
                            if (temp.Info.Bind.HasFlag(BindMode.DontRepair))
                            {
                                Enqueue(p);
                                return;
                            }
                            temp.MaxDura = (ushort)Math.Max(0, temp.MaxDura - Math.Min(5000, temp.MaxDura - temp.CurrentDura) / 30);

                            temp.CurrentDura = (ushort)Math.Min(temp.MaxDura, temp.CurrentDura + 5000);
                            temp.DuraChanged = false;

                            ReceiveChat("Your weapon has been partially repaired", ChatType.Hint);
                            Enqueue(new S.ItemRepaired { UniqueID = temp.UniqueID, MaxDura = temp.MaxDura, CurrentDura = temp.CurrentDura });
                            break;
                        case 5: //WarGodOil
                            temp = Info.Equipment[(int)EquipmentSlot.Weapon];
                            if (temp == null || temp.MaxDura == temp.CurrentDura)
                            {
                                Enqueue(p);
                                return;
                            }
                            if (temp.Info.Bind.HasFlag(BindMode.DontRepair) || (temp.Info.Bind.HasFlag(BindMode.NoSRepair)))
                            {
                                Enqueue(p);
                                return;
                            }
                            temp.CurrentDura = temp.MaxDura;
                            temp.DuraChanged = false;

                            ReceiveChat("Your weapon has been completely repaired", ChatType.Hint);
                            Enqueue(new S.ItemRepaired { UniqueID = temp.UniqueID, MaxDura = temp.MaxDura, CurrentDura = temp.CurrentDura });
                            break;
                        case 6: //ResurrectionScroll
                            if (CurrentMap.Info.NoReincarnation)
                            {
                                ReceiveChat(string.Format("Cannot use on this map"), ChatType.System);
                                Enqueue(p);
                                return;
                            }
                            if (Dead)
                            {
                                MP = Stats[Stat.MP];
                                Revive(MaxHealth, true);
                            }
                            break;
                        case 7: //CreditScroll
                            if (item.Info.Price > 0)
                            {
                                GainCredit(item.Info.Price);
                                ReceiveChat(String.Format("{0} Credits have been added to your Account", item.Info.Price), ChatType.Hint);
                            }
                            break;
                        case 8: //MapShoutScroll
                            HasMapShout = true;
                            ReceiveChat("You have been given one free shout across your current map", ChatType.Hint);
                            break;
                        case 9://ServerShoutScroll
                            HasServerShout = true;
                            ReceiveChat("You have been given one free shout across the server", ChatType.Hint);
                            break;
                        case 10://GuildSkillScroll
                            MyGuild.NewBuff(item.Info.Effect, false);
                            break;
                        case 11://HomeTeleport
                            if (MyGuild != null && MyGuild.Conquest != null && !MyGuild.Conquest.WarIsOn && MyGuild.Conquest.PalaceMap != null && !TeleportRandom(200, 0, MyGuild.Conquest.PalaceMap))
                            {
                                Enqueue(p);
                                return;
                            }
                            break;
                        case 12://LotteryTicket                                                                                    
                            if (Envir.Random.Next(item.Info.Effect * 32) == 1) // 1st prize : 1,000,000
                            {
                                ReceiveChat("You won 1st Prize! Received 1,000,000 gold", ChatType.Hint);
                                GainGold(1000000);
                            }
                            else if (Envir.Random.Next(item.Info.Effect * 16) == 1)  // 2nd prize : 200,000
                            {
                                ReceiveChat("You won 2nd Prize! Received 200,000 gold", ChatType.Hint);
                                GainGold(200000);
                            }
                            else if (Envir.Random.Next(item.Info.Effect * 8) == 1)  // 3rd prize : 100,000
                            {
                                ReceiveChat("You won 3rd Prize! Received 100,000 gold", ChatType.Hint);
                                GainGold(100000);
                            }
                            else if (Envir.Random.Next(item.Info.Effect * 4) == 1) // 4th prize : 10,000
                            {
                                ReceiveChat("You won 4th Prize! Received 10,000 gold", ChatType.Hint);
                                GainGold(10000);
                            }
                            else if (Envir.Random.Next(item.Info.Effect * 2) == 1)  // 5th prize : 1,000
                            {
                                ReceiveChat("You won 5th Prize! Received 1,000 gold", ChatType.Hint);
                                GainGold(1000);
                            }
                            else if (Envir.Random.Next(item.Info.Effect) == 1)  // 6th prize 500
                            {
                                ReceiveChat("You won 6th Prize! Received 500 gold", ChatType.Hint);
                                GainGold(500);
                            }
                            else
                            {
                                ReceiveChat("You haven't won anything.", ChatType.Hint);
                            }
                            break;
                        case 13: //HuntPointsScroll
                            if (item.Info.Price > 0)
                            {
                                GainHuntPoints(item.Info.Price);
                                ReceiveChat(String.Format("{0} HuntPoints have been added to your Account", item.Info.Price), ChatType.Hint);
                            }
                            break;
                        case 26: //GT INVITE
                            var GTmap = Envir.GTMapList.FirstOrDefault(x => x.Owner == item.GTInvite);
                            if (GTmap == null)
                            {
                                Enqueue(p);
                                return;
                            }

                            var map = Envir.GetMap(GTmap.index);
                            if (map == null)
                            {
                                Enqueue(p);
                                return;
                            }

                            if (map.Info.SafeZones == null || map.Info.SafeZones.Count == 0)
                            {
                                Enqueue(p);
                                return;
                            }

                            if (!Teleport(map, map.Info.SafeZones[0].Location))
                            {
                                Enqueue(p);
                                return;
                            }

                            break;
                    }
                    break;
                case ItemType.Book:
                    UserMagic magic = new UserMagic((Spell)item.Info.Shape);

                    if (magic.Info == null)
                    {
                        Enqueue(p);
                        return;
                    }

                    Info.Magics.Add(magic);
                    Enqueue(magic.GetInfo());
                    RefreshStats();
                    break;
                case ItemType.Script:
                    CallDefaultNPC(DefaultNPCType.UseItem, item.Info.Shape);
                    break;
                case ItemType.Food:
                    temp = Info.Equipment[(int)EquipmentSlot.Mount];
                    if (temp == null || temp.MaxDura == temp.CurrentDura)
                    {
                        Enqueue(p);
                        return;
                    }

                    switch (item.Info.Shape)
                    {
                        case 0:
                            temp.MaxDura = (ushort)Math.Max(0, temp.MaxDura - Math.Min(1000, temp.MaxDura - (temp.CurrentDura / 30)));
                            break;
                        case 1:
                            break;
                    }

                    temp.CurrentDura = (ushort)Math.Min(temp.MaxDura, temp.CurrentDura + item.CurrentDura);
                    temp.DuraChanged = false;

                    ReceiveChat("Your mount has been fed.", ChatType.Hint);
                    Enqueue(new S.ItemRepaired { UniqueID = temp.UniqueID, MaxDura = temp.MaxDura, CurrentDura = temp.CurrentDura });

                    RefreshStats();
                    break;
                case ItemType.Pets:
                    if (item.Info.Shape >= 20)
                    {
                        switch (item.Info.Shape)
                        {
                            case 20://Mirror
                                {
                                    Enqueue(new S.IntelligentCreatureEnableRename());
                                }
                                break;
                            case 21://BlackStone
                                {
                                    if (item.Count > 1) item.Count--;
                                    else Info.Inventory[index] = null;
                                    RefreshBagWeight();
                                    p.Success = true;
                                    Enqueue(p);
                                    BlackstoneRewardItem();
                                }
                                return;
                            case 22://Nuts
                                {
                                    if (CreatureSummoned)
                                        for (int i = 0; i < Pets.Count; i++)
                                        {
                                            if (Pets[i].Info.AI != 64) continue;
                                            if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;
                                            ((IntelligentCreatureObject)Pets[i]).MaintainfoodTime = item.Info.Effect * Settings.Hour / 1000;
                                            break;
                                        }
                                }
                                break;
                            case 23://FairyMoss, FreshwaterClam, Mackerel, Cherry
                                {
                                    if (CreatureSummoned)
                                        for (int i = 0; i < Pets.Count; i++)
                                        {
                                            if (Pets[i].Info.AI != 64) continue;
                                            if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;
                                            if (((IntelligentCreatureObject)Pets[i]).Fullness < 10000)
                                                ((IntelligentCreatureObject)Pets[i]).IncreaseFullness(item.Info.Effect * 100);
                                            break;
                                        }
                                }
                                break;
                            case 24://WonderPill
                                {
                                    if (CreatureSummoned)
                                        for (int i = 0; i < Pets.Count; i++)
                                        {
                                            if (Pets[i].Info.AI != 64) continue;
                                            if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;
                                            if (((IntelligentCreatureObject)Pets[i]).Fullness == 0)
                                                ((IntelligentCreatureObject)Pets[i]).IncreaseFullness(100);
                                            break;
                                        }
                                }
                                break;
                            case 25://Strongbox
                                {
                                    byte boxtype = item.Info.Effect;
                                    if (item.Count > 1) item.Count--;
                                    else Info.Inventory[index] = null;
                                    RefreshBagWeight();
                                    p.Success = true;
                                    Enqueue(p);
                                    StrongboxRewardItem(boxtype);
                                }
                                break;
                            case 26://Wonderdrug
                                {
                                    if (HasBuff(BuffType.WonderDrug, out _))
                                    {
                                        ReceiveChat("WonderDrug already active.", ChatType.System);
                                        Enqueue(p);
                                        return;
                                    }

                                    var time = item.Info.Durability;

                                    AddBuff(BuffType.WonderDrug, this, time * Settings.Minute, new Stats(item.AddedStats));
                                }
                                break;
                            case 27://FortuneCookies
                                break;
                            case 28://Knapsack
                                {
                                    var time = item.Info.Durability;

                                    AddBuff(BuffType.Knapsack, this, time * Settings.Minute, new Stats { [Stat.BagWeight] = item.GetTotal(Stat.Luck) });
                                }
                                break;
                        }
                    }
                    else
                    {
                        int slotIndex = Info.IntelligentCreatures.Count;
                        UserIntelligentCreature petInfo = new UserIntelligentCreature((IntelligentCreatureType)item.Info.Shape, slotIndex, item.Info.Effect);
                        if (Info.CheckHasIntelligentCreature((IntelligentCreatureType)item.Info.Shape))
                        {
                            ReceiveChat("You already have this creature.", ChatType.Hint);
                            petInfo = null;
                        }

                        if (petInfo == null || slotIndex >= 10)
                        {
                            Enqueue(p);
                            return;
                        }

                        ReceiveChat("Obtained a new creature {" + petInfo.CustomName + "}.", ChatType.Hint);

                        Info.IntelligentCreatures.Add(petInfo);
                        Enqueue(petInfo.GetInfo());
                    }
                    break;
                case ItemType.Transform: //Transforms
                    {
                        AddBuff(BuffType.Transform, this, (Settings.Second * item.Info.Durability), new Stats(), true, item.Info.Shape);
                    }
                    break;
                case ItemType.Deco:

                    DecoObject decoOb = new DecoObject
                    {
                        Image = item.Info.Shape,
                        CurrentMap = CurrentMap,
                        CurrentLocation = CurrentLocation,
                    };

                    CurrentMap.AddObject(decoOb);
                    decoOb.Spawned();

                    Enqueue(decoOb.GetInfo());

                    break;
                default:
                    return;
            }

            if (item.Count > 1) item.Count--;
            else Info.Inventory[index] = null;
            RefreshBagWeight();

            Report.ItemChanged(item, 1, 1);

            p.Success = true;
            Enqueue(p);
        }
        public void SplitItem(MirGridType grid, ulong id, ushort count)
        {
            S.SplitItem1 p = new S.SplitItem1 { Grid = grid, UniqueID = id, Count = count, Success = false };
            UserItem[] array;
            switch (grid)
            {
                case MirGridType.Inventory:
                    array = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    array = Account.Storage;
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            UserItem temp = null;


            for (int i = 0; i < array.Length; i++)
            {
                if (array[i] == null || array[i].UniqueID != id) continue;
                temp = array[i];
                break;
            }

            if (temp == null || count >= temp.Count || FreeSpace(array) == 0 || count < 1)
            {
                Enqueue(p);
                return;
            }

            temp.Count -= count;

            var originalItem = temp;

            temp = Envir.CreateFreshItem(temp.Info);
            temp.Count = count;

            Report.ItemSplit(originalItem, temp, grid);

            p.Success = true;
            Enqueue(p);
            Enqueue(new S.SplitItem { Item = temp, Grid = grid });

            if (grid == MirGridType.Inventory && (temp.Info.Type == ItemType.Potion || temp.Info.Type == ItemType.Scroll || temp.Info.Type == ItemType.Amulet || temp.Info.Type == ItemType.TaoPoison || (temp.Info.Type == ItemType.Script && temp.Info.Effect == 1)))
            {
                if (temp.Info.Type == ItemType.Potion || temp.Info.Type == ItemType.Scroll || (temp.Info.Type == ItemType.Script && temp.Info.Effect == 1))
                {
                    for (int i = 0; i < 4; i++)
                    {
                        if (array[i] != null) continue;
                        array[i] = temp;
                        RefreshBagWeight();
                        return;
                    }
                }
                else if (temp.Info.Type == ItemType.Amulet || temp.Info.Type == ItemType.TaoPoison)
                {
                    for (int i = 4; i < 6; i++)
                    {
                        if (array[i] != null) continue;
                        array[i] = temp;
                        RefreshBagWeight();
                        return;
                    }
                }
            }

            for (int i = 6; i < array.Length; i++)
            {
                if (array[i] != null) continue;
                array[i] = temp;
                RefreshBagWeight();
                return;
            }

            for (int i = 0; i < 6; i++)
            {
                if (array[i] != null) continue;
                array[i] = temp;
                RefreshBagWeight();
                return;
            }
        }

        public void MergeItem(MirGridType gridFrom, MirGridType gridTo, ulong fromID, ulong toID)
        {
            S.MergeItem p = new S.MergeItem { GridFrom = gridFrom, GridTo = gridTo, IDFrom = fromID, IDTo = toID, Success = false };

            UserItem[] arrayFrom;

            switch (gridFrom)
            {
                case MirGridType.Inventory:
                    arrayFrom = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    arrayFrom = Account.Storage;
                    break;
                case MirGridType.Equipment:
                    arrayFrom = Info.Equipment;
                    break;
                case MirGridType.Fishing:
                    if (Info.Equipment[(int)EquipmentSlot.Weapon] == null || !Info.Equipment[(int)EquipmentSlot.Weapon].Info.IsFishingRod)
                    {
                        Enqueue(p);
                        return;
                    }
                    arrayFrom = Info.Equipment[(int)EquipmentSlot.Weapon].Slots;
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            UserItem[] arrayTo;
            switch (gridTo)
            {
                case MirGridType.Inventory:
                    arrayTo = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.StorageKey, StringComparison.CurrentCultureIgnoreCase))
                    {
                        Enqueue(p);
                        return;
                    }
                    NPCObject ob = null;
                    for (int i = 0; i < CurrentMap.NPCs.Count; i++)
                    {
                        if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                        ob = CurrentMap.NPCs[i];
                        break;
                    }

                    if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
                    {
                        Enqueue(p);
                        return;
                    }
                    arrayTo = Account.Storage;
                    break;
                case MirGridType.Equipment:
                    arrayTo = Info.Equipment;
                    break;
                case MirGridType.Fishing:
                    if (Info.Equipment[(int)EquipmentSlot.Weapon] == null || !Info.Equipment[(int)EquipmentSlot.Weapon].Info.IsFishingRod)
                    {
                        Enqueue(p);
                        return;
                    }
                    arrayTo = Info.Equipment[(int)EquipmentSlot.Weapon].Slots;
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            UserItem tempFrom = null;
            int index = -1;

            for (int i = 0; i < arrayFrom.Length; i++)
            {
                if (arrayFrom[i] == null || arrayFrom[i].UniqueID != fromID) continue;
                index = i;
                tempFrom = arrayFrom[i];
                break;
            }

            if (tempFrom == null || tempFrom.Info.StackSize == 1 || index == -1)
            {
                Enqueue(p);
                return;
            }


            UserItem tempTo = null;
            int toIndex = -1;

            for (int i = 0; i < arrayTo.Length; i++)
            {
                if (arrayTo[i] == null || arrayTo[i].UniqueID != toID) continue;
                toIndex = i;
                tempTo = arrayTo[i];
                break;
            }

            if (tempTo == null || tempTo.Info != tempFrom.Info || tempTo.Count == tempTo.Info.StackSize)
            {
                Enqueue(p);
                return;
            }

            if (tempTo.Info.Type != ItemType.Amulet && tempTo.Info.Type != ItemType.TaoPoison && (gridFrom == MirGridType.Equipment || gridTo == MirGridType.Equipment))
            {
                Enqueue(p);
                return;
            }

            if(tempTo.Info.Type != ItemType.Bait && (gridFrom == MirGridType.Fishing || gridTo == MirGridType.Fishing))
            {
                Enqueue(p);
                return;
            }

            if (tempFrom.Count <= tempTo.Info.StackSize - tempTo.Count)
            {
                tempTo.Count += tempFrom.Count;
                arrayFrom[index] = null;
            }
            else
            {
                tempFrom.Count -= (ushort)(tempTo.Info.StackSize - tempTo.Count);
                tempTo.Count = tempTo.Info.StackSize;
            }

            Report.ItemMerged(tempFrom, tempTo, index, toIndex, gridFrom, gridTo);

            TradeUnlock();

            p.Success = true;
            Enqueue(p);
            RefreshStats();
        }
        public void CombineItem(ulong fromID, ulong toID)
        {
            S.CombineItem p = new S.CombineItem { IDFrom = fromID, IDTo = toID, Success = false };

            UserItem[] array = Info.Inventory;
            UserItem tempFrom = null;
            UserItem tempTo = null;
            int indexFrom = -1;
            int indexTo = -1;

            if (Dead)
            {
                Enqueue(p);
                return;
            }

            for (int i = 0; i < array.Length; i++)
            {
                if (array[i] == null || array[i].UniqueID != fromID) continue;
                indexFrom = i;
                tempFrom = array[i];
                break;
            }

            if (tempFrom == null || indexFrom == -1)
            {
                Enqueue(p);
                return;
            }

            for (int i = 0; i < array.Length; i++)
            {
                if (array[i] == null || array[i].UniqueID != toID) continue;
                indexTo = i;
                tempTo = array[i];
                break;
            }

            if (tempTo == null || indexTo == -1)
            {
                Enqueue(p);
                return;
            }

            if ((byte)tempTo.Info.Type < 1 || (byte)tempTo.Info.Type > 11)
            {
                Enqueue(p);
                return;
            }

            bool canRepair = false, canUpgrade = false, canSlotUpgrade = false;

            if (tempFrom.Info.Type != ItemType.Gem)
            {
                Enqueue(p);
                return;
            }

            switch (tempFrom.Info.Shape)
            {
                case 1: //BoneHammer
                case 2: //SewingSupplies
                case 5: //SpecialHammer
                case 6: //SpecialSewingSupplies

                    if (tempTo.Info.Bind.HasFlag(BindMode.DontRepair))
                    {
                        Enqueue(p);
                        return;
                    }

                    switch (tempTo.Info.Type)
                    {
                        case ItemType.Weapon:
                        case ItemType.Necklace:
                        case ItemType.Ring:
                        case ItemType.Bracelet:
                            if (tempFrom.Info.Shape == 1 || tempFrom.Info.Shape == 5)
                                canRepair = true;
                            break;
                        case ItemType.Armour:
                        case ItemType.Helmet:
                        case ItemType.Boots:
                        case ItemType.Belt:
                            if (tempFrom.Info.Shape == 2 || tempFrom.Info.Shape == 6)
                                canRepair = true;
                            break;
                        default:
                            canRepair = false;
                            break;
                    }

                    if (canRepair != true)
                    {
                        Enqueue(p);
                        return;
                    }

                    if (tempTo.CurrentDura == tempTo.MaxDura)
                    {
                        ReceiveChat("Item does not need to be repaired.", ChatType.Hint);
                        Enqueue(p);
                        return;
                    }
                    break;
                case 7: //slots
                    if (tempTo.Info.Bind.HasFlag(BindMode.DontUpgrade) || tempTo.Info.Unique != SpecialItemMode.None)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (tempTo.RentalInformation != null && tempTo.RentalInformation.BindingFlags.HasFlag(BindMode.DontUpgrade))
                    {
                        Enqueue(p);
                        return;
                    }
                    if (!ValidGemForItem(tempFrom, (byte)tempTo.Info.Type))
                    {
                        ReceiveChat("Invalid combination.", ChatType.Socket);
                        Enqueue(p);
                        return;
                    }
                    if (tempTo.Info.RandomStats == null)
                    {
                        ReceiveChat("Item already has max sockets.", ChatType.Socket);
                        Enqueue(p);
                        return;
                    }
                    //if ((tempTo.GemCount >= tempFrom.Info.MaxStats) || (GetCurrentStatCount(tempFrom, tempTo) >= tempFrom.Info.MaxGemStat))
                    if (tempTo.Info.RandomStats.SlotMaxStat <= tempTo.Slots.Length)
                    {
                        ReceiveChat("Item already has max sockets.", ChatType.Socket);
                        Enqueue(p);
                        return;
                    }

                    canSlotUpgrade = true;
                    break;
<<<<<<< HEAD
=======
                case 8: //Seal
                    if (tempTo.Info.Bind.HasFlag(BindMode.DontUpgrade) || tempTo.Info.Unique != SpecialItemMode.None)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (tempTo.SealedInfo != null)
                    {
                        ReceiveChat("Item is already sealed.", ChatType.Hint);
                        Enqueue(p);
                        return;
                    }

                    canSeal = true;
                    break;
>>>>>>> parent of 42a638e (Allow instant reseal of items)
                case 3: //gems
                case 4: //orbs
                    if (tempTo.Info.Bind.HasFlag(BindMode.DontUpgrade) || tempTo.Info.Unique != SpecialItemMode.None)
                    {
                        Enqueue(p);
                        return;
                    }

                    if (tempTo.RentalInformation != null && tempTo.RentalInformation.BindingFlags.HasFlag(BindMode.DontUpgrade))
                    {
                        Enqueue(p);
                        return;
                    }

                    if ((tempTo.GemCount >= tempFrom.Info.MaxStats) || (GetCurrentStatCount(tempFrom, tempTo) >= tempFrom.Info.MaxGemStat))
                    {
                        ReceiveChat("Item has already reached maximum added stats", ChatType.Orb);
                        Enqueue(p);
                        return;
                    }

                    int successchance = tempFrom.Info.BaseRateDrop;

                    // Gem is only affected by the stat applied.
                    // Drop rate per gem won't work if gems add more than 1 stat, i.e. DC + 2 per gem.
                    if (Settings.GemStatIndependent)
                    {
                        Stat GemType = GetGemType(tempFrom);

                        switch (GemType)
                        {
                            case Stat.MinAC:
                                successchance *= (int)tempTo.AddedStats[Stat.MinAC];
                                break;

                            case Stat.MaxAC:
                                successchance *= (int)tempTo.AddedStats[Stat.MaxAC];
                                break;

                            case Stat.MinMAC:
                                successchance *= (int)tempTo.AddedStats[Stat.MinMAC];
                                break;

                            case Stat.MaxMAC:
                                successchance *= (int)tempTo.AddedStats[Stat.MaxMAC];
                                break;

                            case Stat.MinDC:
                                successchance *= (int)tempTo.AddedStats[Stat.MinDC];
                                break;

                            case Stat.MaxDC:
                                successchance *= (int)tempTo.AddedStats[Stat.MaxDC];
                                break;

                            case Stat.MinMC:
                                successchance *= (int)tempTo.AddedStats[Stat.MinMC];
                                break;

                            case Stat.MaxMC:
                                successchance *= (int)tempTo.AddedStats[Stat.MaxMC];
                                break;

                            case Stat.MinSC:
                                successchance *= (int)tempTo.AddedStats[Stat.MinSC];
                                break;

                            case Stat.MaxSC:
                                successchance *= (int)tempTo.AddedStats[Stat.MaxSC];
                                break;

                            case Stat.AttackSpeed:
                                successchance *= (int)tempTo.AddedStats[Stat.AttackSpeed];
                                break;

                            case Stat.Accuracy:
                                successchance *= (int)tempTo.AddedStats[Stat.Accuracy];
                                break;

                            case Stat.Agility:
                                successchance *= (int)tempTo.AddedStats[Stat.Agility];
                                break;

                            case Stat.Freezing:
                                successchance *= (int)tempTo.AddedStats[Stat.Freezing];
                                break;

                            case Stat.PoisonAttack:
                                successchance *= (int)tempTo.AddedStats[Stat.PoisonAttack];
                                break;

                            case Stat.MagicResist:
                                successchance *= (int)tempTo.AddedStats[Stat.MagicResist];
                                break;

                            case Stat.PoisonResist:
                                successchance *= (int)tempTo.AddedStats[Stat.PoisonResist];
                                break;

                            // These attributes may not work as more than 1 stat is
                            // added per gem, i.e + 40 HP.

                            case Stat.HP:
                                successchance *= (int)tempTo.AddedStats[Stat.HP];
                                break;

                            case Stat.MP:
                                successchance *= (int)tempTo.AddedStats[Stat.MP];
                                break;

                            case Stat.HealthRecovery:
                                successchance *= (int)tempTo.AddedStats[Stat.HealthRecovery];
                                break;
                                
                            // I don't know if this conflicts with benes.
                            case Stat.Luck:
                                successchance *= (int)tempTo.AddedStats[Stat.Luck];
                                break;

                            case Stat.Strong:
                                successchance *= (int)tempTo.AddedStats[Stat.Strong];
                                break;

                            case Stat.PoisonRecovery:
                                successchance *= (int)tempTo.AddedStats[Stat.PoisonRecovery];
                                break;


                            /*
                                 Currently not supported.
                                 Missing item definitions.

                                 case StatType.HP_Precent:
                                 case StatType.MP_Precent:
                                 case StatType.MP_Regen:
                                 case StatType.Holy:
                                 case StatType.Durability:


                            */
                            default:
                                successchance *= (int)tempTo.GemCount;
                                break;

                        }
                    }
                    // Gem is affected by the total added stats on the item.
                    else
                    {
                        successchance *= (int)tempTo.GemCount;
                    }

                    //successchance = successchance >= tempFrom.Info.Stats[Stat.CriticalRate] ? 0 : (tempFrom.Info.Stats[Stat.CriticalRate] - successchance) + Stats[Stat.GemRatePercent];
                    successchance = successchance >= tempFrom.Info.BaseRate ? 0 : (tempFrom.Info.BaseRate - successchance) + Stats[Stat.GemRatePercent];

                    //check if combine will succeed
                    bool succeeded = Envir.Random.Next(100) < successchance;
                    canUpgrade = true;

                    byte itemType = (byte)tempTo.Info.Type;

                    if (!ValidGemForItem(tempFrom, itemType))
                    {
                        ReceiveChat("Invalid combination", ChatType.Hint);
                        Enqueue(p);
                        return;
                    }

                    if (tempFrom.GetTotal(Stat.MinAC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MinAC] += tempFrom.GetTotal(Stat.MinAC);
                    }

                    else if(tempFrom.GetTotal(Stat.MaxAC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MaxAC] += tempFrom.GetTotal(Stat.MaxAC);
                    }

                    else if (tempFrom.GetTotal(Stat.MinMAC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MinMAC] += tempFrom.GetTotal(Stat.MinMAC);
                    }

                    else if (tempFrom.GetTotal(Stat.MaxMAC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MaxMAC] += tempFrom.GetTotal(Stat.MaxMAC);
                    }

                    else if (tempFrom.GetTotal(Stat.MinDC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MinDC] += tempFrom.GetTotal(Stat.MinDC);
                    }

                    else if (tempFrom.GetTotal(Stat.MaxDC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MaxDC] += tempFrom.GetTotal(Stat.MaxDC);
                    }

                    else if (tempFrom.GetTotal(Stat.MinMC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MinMC] += tempFrom.GetTotal(Stat.MinMC);
                    }

                    else if (tempFrom.GetTotal(Stat.MaxMC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MaxMC] += tempFrom.GetTotal(Stat.MaxMC);
                    }

                    else if (tempFrom.GetTotal(Stat.MinSC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MinSC] += tempFrom.GetTotal(Stat.MinSC);
                    }
                    else if (tempFrom.GetTotal(Stat.MaxSC) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MaxSC] += tempFrom.GetTotal(Stat.MaxSC);
                    }

                    else if ((tempFrom.Info.Durability) > 0)
                    {
                        if (succeeded) tempTo.MaxDura = (ushort)Math.Min(ushort.MaxValue, tempTo.MaxDura + tempFrom.MaxDura);
                    }

                    else if (tempFrom.GetTotal(Stat.AttackSpeed) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.AttackSpeed] += tempFrom.GetTotal(Stat.AttackSpeed);
                    }

                    else if (tempFrom.GetTotal(Stat.Agility) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.Agility] += tempFrom.GetTotal(Stat.Agility);
                    }

                    else if (tempFrom.GetTotal(Stat.Accuracy) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.Accuracy] += tempFrom.GetTotal(Stat.Accuracy);
                    }

                    else if (tempFrom.GetTotal(Stat.PoisonAttack) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.PoisonAttack] += tempFrom.GetTotal(Stat.PoisonAttack);
                    }

                    else if (tempFrom.GetTotal(Stat.Freezing) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.Freezing] += tempFrom.GetTotal(Stat.Freezing);
                    }

                    else if (tempFrom.GetTotal(Stat.MagicResist) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.MagicResist] += tempFrom.GetTotal(Stat.MagicResist);
                    }

                    else if (tempFrom.GetTotal(Stat.PoisonResist) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.PoisonResist] += tempFrom.GetTotal(Stat.PoisonResist);
                    }
                    else if (tempFrom.GetTotal(Stat.Luck) > 0)
                    {
                        if (succeeded) tempTo.AddedStats[Stat.Luck] += tempFrom.GetTotal(Stat.Luck);
                    }
                    else
                    {
                        ReceiveChat("Cannot combine these items.", ChatType.Hint);
                        Enqueue(p);
                        return;
                    }

                    if (!succeeded)
                    {
                        if ((tempFrom.Info.Shape == 3) && (Envir.Random.Next(15) < 3))
                        {
                            //item destroyed
                            ReceiveChat("Item has been destroyed.", ChatType.Hint);
                            Report.ItemChanged(Info.Inventory[indexTo], 1, 1, "CombineItem (Item Destroyed)");

                            Info.Inventory[indexTo] = null;
                            p.Destroy = true;
                        }
                        else
                        {
                            //upgrade has no effect
                            ReceiveChat("Upgrade has no effect.", ChatType.Orb);
                        }

                        canUpgrade = false;
                    }
                    break;
                default:
                    Enqueue(p);
                    return;
            }



            RefreshBagWeight();

            if (canRepair && Info.Inventory[indexTo] != null)
            {
                switch (tempTo.Info.Shape)
                {
                    case 1:
                    case 2:
                        {
                            tempTo.MaxDura = (ushort)Math.Max(0, Math.Min(tempTo.MaxDura, tempTo.MaxDura - 100 * Envir.Random.Next(10)));
                        }
                        break;
                    default:
                        break;
                }
                tempTo.CurrentDura = tempTo.MaxDura;
                tempTo.DuraChanged = false;

                ReceiveChat("Item has been repaired.", ChatType.Hint);
                Enqueue(new S.ItemRepaired { UniqueID = tempTo.UniqueID, MaxDura = tempTo.MaxDura, CurrentDura = tempTo.CurrentDura });
            }

            if (canUpgrade && Info.Inventory[indexTo] != null)
            {
                tempTo.GemCount++;
                ReceiveChat("Item has been upgraded.", ChatType.Orb);
                Enqueue(new S.ItemUpgraded { Item = tempTo });
            }

            if (canSlotUpgrade && Info.Inventory[indexTo] != null)
            {
                int successchance = tempFrom.Info.BaseRateDrop;
                successchance = successchance >= tempFrom.Info.BaseRate ? 0 : (tempFrom.Info.BaseRate - successchance) + Stats[Stat.GemRatePercent];

                //check if combine will succeed
                bool succeeded = Envir.Random.Next(100) < successchance;

                if (!succeeded)
                {
                    //upgrade has no effect
                    ReceiveChat("Upgrade has no effect.", ChatType.Socket);
                }
                else
                {
                    tempTo.SetSlotSize(tempTo.Slots.Length + 1);
                    ReceiveChat("Item has increased its sockets.", ChatType.Socket);
                    Enqueue(new S.ItemSlotSizeChanged { UniqueID = tempTo.UniqueID, SlotSize = tempTo.Slots.Length });
                }
            }

            if (tempFrom.Count > 1) tempFrom.Count--;
            else Info.Inventory[indexFrom] = null;

            Report.ItemCombined(tempFrom, tempTo, indexFrom, indexTo, MirGridType.Inventory);

            //item merged ok
            TradeUnlock();

            p.Success = true;
            Enqueue(p);
        }
        private bool ValidGemForItem(UserItem Gem, byte itemtype)
        {
            switch (itemtype)
            {
                case 1: //weapon
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Paralize))
                        return true;
                    break;
                case 2: //Armour
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Teleport))
                        return true;
                    break;
                case 4: //Helmet
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.ClearRing))
                        return true;
                    break;
                case 5: //necklace
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Protection))
                        return true;
                    break;
                case 6: //bracelet
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Revival))
                        return true;
                    break;
                case 7: //ring
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Muscle))
                        return true;
                    break;
                case 8: //amulet
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Flame))
                        return true;
                    break;
                case 9://belt
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Healing))
                        return true;
                    break;
                case 10: //boots
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Probe))
                        return true;
                    break;
                case 11: //stone
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.Skill))
                        return true;
                    break;
                case 12:///torch
                    if (Gem.Info.Unique.HasFlag(SpecialItemMode.NoDuraLoss))
                        return true;
                    break;
            }
            return false;
        }
        //Gems granting multiple stat types are not compatiable with this method.
        private Stat GetGemType(UserItem gem)
        {

            if (gem.GetTotal(Stat.MinAC) > 0)
                return Stat.MinAC;

            else if (gem.GetTotal(Stat.MaxAC) > 0)
                return Stat.MaxAC;

            else if (gem.GetTotal(Stat.MinMAC) > 0)
                return Stat.MinMAC;

            else if (gem.GetTotal(Stat.MaxMAC) > 0)
                return Stat.MaxMAC;

            else if(gem.GetTotal(Stat.MinDC) > 0)
                return Stat.MinDC;

            else if(gem.GetTotal(Stat.MaxDC) > 0)
                return Stat.MaxDC;

            else if (gem.GetTotal(Stat.MinMC) > 0)
                return Stat.MinMC;

            else if (gem.GetTotal(Stat.MaxMC) > 0)
                return Stat.MaxMC;

            else if (gem.GetTotal(Stat.MinSC) > 0)
                return Stat.MinSC;

            else if (gem.GetTotal(Stat.MaxSC) > 0)
                return Stat.MaxSC;

            else if (gem.GetTotal(Stat.AttackSpeed) > 0)
                return Stat.AttackSpeed;

            else if (gem.GetTotal(Stat.Agility) > 0)
                return Stat.Agility;

            else if (gem.GetTotal(Stat.Accuracy) > 0)
                return Stat.Accuracy;

            else if (gem.GetTotal(Stat.PoisonAttack) > 0)
                return Stat.PoisonAttack;

            else if (gem.GetTotal(Stat.Freezing) > 0)
                return Stat.Freezing;

            else if (gem.GetTotal(Stat.MagicResist) > 0)
                return Stat.MagicResist;

            else if (gem.GetTotal(Stat.PoisonResist) > 0)
                return Stat.PoisonResist;

            else if (gem.GetTotal(Stat.Luck) > 0)
                return Stat.Luck;

            else if (gem.GetTotal(Stat.PoisonRecovery) > 0)
                return Stat.PoisonRecovery;

            else if (gem.GetTotal(Stat.HP) > 0)
                return Stat.HP;

            else if (gem.GetTotal(Stat.MP) > 0)
                return Stat.MP;

            else if (gem.GetTotal(Stat.HealthRecovery) > 0)
                return Stat.HealthRecovery;

            // These may be incomplete. Item definitions may be missing?

            else if (gem.GetTotal(Stat.HPRatePercent) > 0)
                return Stat.HPRatePercent;

            else if (gem.GetTotal(Stat.MPRatePercent) > 0)
                return Stat.MPRatePercent;

            else if (gem.GetTotal(Stat.SpellRecovery) > 0)
                return Stat.SpellRecovery;

            else if (gem.GetTotal(Stat.Holy) > 0)
                return Stat.Holy;

            else if (gem.GetTotal(Stat.Strong) > 0)
                return Stat.Strong;

            else if (gem.GetTotal(Stat.HPDrainRatePercent) > 0)
                return Stat.HPDrainRatePercent;

            return Stat.Unknown;
        }

        //Gems granting multiple stat types are not compatible with this method.
        private int GetCurrentStatCount(UserItem gem, UserItem item)
        {
            if (gem.GetTotal(Stat.MinAC) > 0)
                return item.AddedStats[Stat.MinAC];

            else if (gem.GetTotal(Stat.MaxAC) > 0)
                return item.AddedStats[Stat.MaxAC];

            else if (gem.GetTotal(Stat.MinMAC) > 0)
                return item.AddedStats[Stat.MinMAC];

            else if (gem.GetTotal(Stat.MaxMAC) > 0)
                return item.AddedStats[Stat.MaxMAC];

            else if(gem.GetTotal(Stat.MinDC) > 0)
                return item.AddedStats[Stat.MinDC];

            else if(gem.GetTotal(Stat.MaxDC) > 0)
                return item.AddedStats[Stat.MaxDC];

            else if (gem.GetTotal(Stat.MinMC) > 0)
                return item.AddedStats[Stat.MinMC];

            else if (gem.GetTotal(Stat.MaxMC) > 0)
                return item.AddedStats[Stat.MaxMC];

            else if (gem.GetTotal(Stat.MinSC) > 0)
                return item.AddedStats[Stat.MinSC];

            else if (gem.GetTotal(Stat.MaxSC) > 0)
                return item.AddedStats[Stat.MaxSC];


            else if ((gem.Info.Durability) > 0)
                return item.Info.Durability > item.MaxDura ? 0 : ((item.MaxDura - item.Info.Durability) / 1000);

            else if (gem.GetTotal(Stat.AttackSpeed) > 0)
                return item.AddedStats[Stat.AttackSpeed];

            else if (gem.GetTotal(Stat.Agility) > 0)
                return item.AddedStats[Stat.Agility];

            else if (gem.GetTotal(Stat.Accuracy) > 0)
                return item.AddedStats[Stat.Accuracy];

            else if (gem.GetTotal(Stat.PoisonAttack) > 0)
                return item.AddedStats[Stat.PoisonAttack];

            else if (gem.GetTotal(Stat.Freezing) > 0)
                return item.AddedStats[Stat.Freezing];

            else if (gem.GetTotal(Stat.MagicResist) > 0)
                return item.AddedStats[Stat.MagicResist];

            else if (gem.GetTotal(Stat.PoisonResist) > 0)
                return item.AddedStats[Stat.PoisonResist];

            else if (gem.GetTotal(Stat.Luck) > 0)
                return item.AddedStats[Stat.Luck];

            else if (gem.GetTotal(Stat.PoisonRecovery) > 0)
                return item.AddedStats[Stat.PoisonRecovery];

            else if (gem.GetTotal(Stat.HP) > 0)
                return item.AddedStats[Stat.HP];

            else if (gem.GetTotal(Stat.MP) > 0)
                return item.AddedStats[Stat.MP];

            else if (gem.GetTotal(Stat.HealthRecovery) > 0)
                return item.AddedStats[Stat.HealthRecovery];

            // Definitions are missing for these.
            /*
            else if ((gem.Info.HPrate) > 0)
                return item.h

            else if ((gem.Info.MPrate) > 0)
                return 

            else if ((gem.Info.SpellRecovery) > 0)
                return 

            else if ((gem.Info.Holy) > 0)
                return 

            else if ((gem.Info.Strong + gem.Strong) > 0)
                return 

            else if (gem.Info.HPrate > 0)
                return
            */
            return 0;
        }
        public void DropItem(ulong id, ushort count)
        {
            S.DropItem p = new S.DropItem { UniqueID = id, Count = count, Success = false };
            if (Dead)
            {
                Enqueue(p);
                return;
            }

            if (CurrentMap.Info.NoThrowItem)
            {
                ReceiveChat(GameLanguage.CanNotDrop, ChatType.System);
                Enqueue(p);
                return;
            }

            UserItem temp = null;
            int index = -1;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                temp = Info.Inventory[i];
                if (temp == null || temp.UniqueID != id) continue;
                index = i;
                break;
            }

            if (temp == null || index == -1 || count > temp.Count || count < 1)
            {
                Enqueue(p);
                return;
            }

            if (temp.Info.Bind.HasFlag(BindMode.DontDrop))
            {
                Enqueue(p);
                return;
            }

            if (temp.RentalInformation != null && temp.RentalInformation.BindingFlags.HasFlag(BindMode.DontDrop))
            {
                Enqueue(p);
                return;
            }

            if (temp.Count == count)
            {
                if (!temp.Info.Bind.HasFlag(BindMode.DestroyOnDrop))
                    if (!DropItem(temp))
                    {
                        Enqueue(p);
                        return;
                    }
                Info.Inventory[index] = null;
            }
            else
            {
                UserItem temp2 = Envir.CreateFreshItem(temp.Info);
                temp2.Count = count;
                if (!temp.Info.Bind.HasFlag(BindMode.DestroyOnDrop))
                    if (!DropItem(temp2))
                    {
                        Enqueue(p);
                        return;
                    }
                temp.Count -= count;
            }
            p.Success = true;
            Enqueue(p);
            RefreshBagWeight();

            Report.ItemChanged(temp, count, 1);
        }
        public void DropGold(uint gold)
        {
            if (Account.Gold < gold) return;

            ItemObject ob = new ItemObject(this, gold);

            if (!ob.Drop(5)) return;
            Account.Gold -= gold;
            Enqueue(new S.LoseGold { Gold = gold });
        }
        public void DropHuntPoints(uint huntpoints)
        {
            if (Account.HuntPoints < huntpoints) return;

            ItemObject ob = new ItemObject(this, huntpoints);

            if (!ob.Drop(5)) return;
            Account.HuntPoints -= huntpoints;
            Enqueue(new S.LoseHuntPoints { HuntPoints = huntpoints });
        }
        public void PickUp()
        {
            if (Dead)
            {
                //Send Fail
                return;
            }

            Cell cell = CurrentMap.GetCell(CurrentLocation);

            bool sendFail = false;

            for (int i = 0; i < cell.Objects.Count; i++)
            {
                MapObject ob = cell.Objects[i];

                if (ob.Race != ObjectType.Item) continue;

                if (ob.Owner != null && ob.Owner != this && !IsGroupMember(ob.Owner)) //Or Group member.
                {
                    sendFail = true;
                    continue;
                }
                ItemObject item = (ItemObject)ob;

                if (item.Item != null)
                {
                    if (!CanGainItem(item.Item)) continue;

                    if (item.Item.Info.ShowGroupPickup && IsGroupMember(this))
                        for (int j = 0; j < GroupMembers.Count; j++)
                            GroupMembers[j].ReceiveChat(Name + " Picked up: {" + item.Item.FriendlyName + "}",
                                ChatType.System);

                    GainItem(item.Item);

                    Report.ItemChanged(item.Item, item.Item.Count, 2);

                    CurrentMap.RemoveObject(ob);
                    ob.Despawn();

                    return;
                }

                if (!CanGainGold(item.Gold)) continue;

                GainGold(item.Gold);
                CurrentMap.RemoveObject(ob);
                ob.Despawn();
                return;
            }

            if (sendFail)
                ReceiveChat("Can not pick up, You do not own this item.", ChatType.System);

        }

        private bool IsGroupMember(MapObject player)
        {
            if (player.Race != ObjectType.Player) return false;
            return GroupMembers != null && GroupMembers.Contains(player);
        }

        public override bool CanGainGold(uint gold)
        {
            return gold + Account.Gold <= uint.MaxValue;
        }
        public override void WinGold(uint gold)
        {
            if (GroupMembers == null)
            {
                GainGold(gold);
                return;
            }

            uint count = 0;

            for (int i = 0; i < GroupMembers.Count; i++)
            {
                PlayerObject player = GroupMembers[i];
                if (player.CurrentMap == CurrentMap && Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) && !player.Dead)
                    count++;
            }

            if (count == 0 || count > gold)
            {
                GainGold(gold);
                return;
            }
            gold = gold / count;

            for (int i = 0; i < GroupMembers.Count; i++)
            {
                PlayerObject player = GroupMembers[i];
                if (player.CurrentMap == CurrentMap && Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) && !player.Dead)
                    player.GainGold(gold);
            }
        }
        public void GainGold(uint gold)
        {
            if (gold == 0) return;

            if (((UInt64)Account.Gold + gold) > uint.MaxValue)
                gold = uint.MaxValue - Account.Gold;

            Account.Gold += gold;

            Enqueue(new S.GainedGold { Gold = gold });
        }
        public void GainCredit(uint credit)
        {
            if (credit == 0) return;

            if (((UInt64)Account.Credit + credit) > uint.MaxValue)
                credit = uint.MaxValue - Account.Credit;

            Account.Credit += credit;

            Enqueue(new S.GainedCredit { Credit = credit });
        }
        public void GainHuntPoints(uint huntpoints)
        {
            if (huntpoints == 0) return;

            if (((UInt64)Account.HuntPoints + huntpoints) > uint.MaxValue)
                huntpoints = uint.MaxValue - Account.HuntPoints;

            Account.HuntPoints += huntpoints;

            Enqueue(new S.GainedHuntPoints { HuntPoints = huntpoints });
        }
        public override bool CanGainHuntPoints(uint huntpoints)
        {
            return huntpoints + Account.HuntPoints <= uint.MaxValue;
        }
        public override void WinHuntPoints(uint huntpoints)
        {
            if (GroupMembers == null)
            {
                GainHuntPoints(huntpoints);
                return;
            }

            uint count = 0;

            for (int i = 0; i < GroupMembers.Count; i++)
            {
                PlayerObject player = GroupMembers[i];
                if (player.CurrentMap == CurrentMap && Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) && !player.Dead)
                    count++;
            }

            if (count == 0 || count > huntpoints)
            {
                GainHuntPoints(huntpoints);
                return;
            }
            huntpoints = huntpoints / count;

            for (int i = 0; i < GroupMembers.Count; i++)
            {
                PlayerObject player = GroupMembers[i];
                if (player.CurrentMap == CurrentMap && Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) && !player.Dead)
                    player.GainHuntPoints(huntpoints);
            }
        }

        public bool CanGainItem(UserItem item, bool useWeight = true)
        {
            if (item.Info.Type == ItemType.Amulet && item.Info.Type == ItemType.TaoPoison)
            {
                if (FreeSpace(Info.Inventory) > 0 && (CurrentBagWeight + item.Weight <= Stats[Stat.BagWeight] || !useWeight)) return true;

                ushort count = item.Count;

                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    UserItem bagItem = Info.Inventory[i];

                    if (bagItem == null || bagItem.Info != item.Info) continue;

                    if (bagItem.Count + count <= bagItem.Info.StackSize) return true;

                    count -= (ushort)(bagItem.Info.StackSize - bagItem.Count);
                }

                return false;
            }

            if (useWeight && CurrentBagWeight + (item.Weight) > Stats[Stat.BagWeight]) return false;

            if (FreeSpace(Info.Inventory) > 0) return true;

            if (item.Info.StackSize > 1)
            {
                ushort count = item.Count;

                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    UserItem bagItem = Info.Inventory[i];

                    if (bagItem.Info != item.Info) continue;

                    if (bagItem.Count + count <= bagItem.Info.StackSize) return true;

                    count -= (ushort)(bagItem.Info.StackSize - bagItem.Count);
                }
            }

            return false;
        }
        public bool CanGainItems(UserItem[] items)
        {
            int itemCount = items.Count(e => e != null);
            int itemWeight = 0;
            ushort stackOffset = 0;

            if (itemCount < 1) return true;

            for (int i = 0; i < items.Length; i++)
            {
                if (items[i] == null) continue;

                itemWeight += items[i].Weight;

                if (items[i].Info.StackSize > 1)
                {
                    ushort count = items[i].Count;

                    for (int u = 0; u < Info.Inventory.Length; u++)
                    {
                        UserItem bagItem = Info.Inventory[u];

                        if (bagItem == null || bagItem.Info != items[i].Info) continue;

                        if (bagItem.Count + count > bagItem.Info.StackSize) stackOffset++;

                        break;
                    }
                }
            }

            if (CurrentBagWeight + (itemWeight) > Stats[Stat.BagWeight]) return false;
            if (FreeSpace(Info.Inventory) < itemCount + stackOffset) return false;

            return true;
        }

        public void GainItem(UserItem item)
        {
            //CheckItemInfo(item.Info);
            CheckItem(item);

            UserItem clonedItem = item.Clone();

            Enqueue(new S.GainedItem { Item = clonedItem }); //Cloned because we are probably going to change the amount.

            AddItem(item);
            RefreshBagWeight();

        }
        public void GainItemMail(UserItem item, int reason)
        {
            Envir.MailCharacter(Info, item: item, reason: reason);
        }

        private bool DropItem(UserItem item, int range = 1, bool DeathDrop = false)
        {
            ItemObject ob = new ItemObject(this, item, DeathDrop);

            if (!ob.Drop(range)) return false;

            if (item.Info.Type == ItemType.Meat)
                item.CurrentDura = (ushort)Math.Max(0, item.CurrentDura - 2000);

            return true;
        }
        private bool CanUseItem(UserItem item)
        {
            if (item == null) return false;

            switch (Gender)
            {
                case MirGender.Male:
                    if (!item.Info.RequiredGender.HasFlag(RequiredGender.Male))
                    {
                        ReceiveChat(GameLanguage.NotFemale, ChatType.System);
                        return false;
                    }
                    break;
                case MirGender.Female:
                    if (!item.Info.RequiredGender.HasFlag(RequiredGender.Female))
                    {
                        ReceiveChat(GameLanguage.NotMale, ChatType.System);
                        return false;
                    }
                    break;
            }

            switch (Class)
            {
                case MirClass.Warrior:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Warrior))
                    {
                        ReceiveChat("Warriors cannot use this item.", ChatType.System);
                        return false;
                    }
                    break;
                case MirClass.Wizard:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Wizard))
                    {
                        ReceiveChat("Wizards cannot use this item.", ChatType.System);
                        return false;
                    }
                    break;
                case MirClass.Taoist:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Taoist))
                    {
                        ReceiveChat("Taoists cannot use this item.", ChatType.System);
                        return false;
                    }
                    break;
                case MirClass.Assassin:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Assassin))
                    {
                        ReceiveChat("Assassins cannot use this item.", ChatType.System);
                        return false;
                    }
                    break;
            }

            switch (item.Info.RequiredType)
            {
                case RequiredType.Reborn:
                    if (Reborn < item.Info.RequiredAmount)
                    {
                        ReceiveChat(GameLanguage.LowReborn, ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.InstanceStage:
                    if (InstanceStage < item.Info.RequiredAmount)
                    {
                        ReceiveChat(GameLanguage.LowInstanceStage, ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.ChallengeStage:
                    if (ChallengeStage < item.Info.RequiredAmount)
                    {
                        ReceiveChat(GameLanguage.LowChallengeStage, ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.Level:
                    if (Level < item.Info.RequiredAmount)
                    {
                        ReceiveChat(GameLanguage.LowLevel, ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MaxAC:
                    if (Stats[Stat.MaxAC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat("You do not have enough AC.", ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MaxMAC:
                    if (Stats[Stat.MaxMAC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat("You do not have enough MAC.", ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MaxDC:
                    if (Stats[Stat.MaxDC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat(GameLanguage.LowDC, ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MaxMC:
                    if (Stats[Stat.MaxMC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat(GameLanguage.LowMC, ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MaxSC:
                    if (Stats[Stat.MaxSC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat(GameLanguage.LowSC, ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MaxLevel:
                    if (Level > item.Info.RequiredAmount)
                    {
                        ReceiveChat("You have exceeded the maximum level.", ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MinAC:
                    if (Stats[Stat.MinAC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat("You do not have enough Base AC.", ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MinMAC:
                    if (Stats[Stat.MinMAC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat("You do not have enough Base MAC.", ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MinDC:
                    if (Stats[Stat.MinDC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat("You do not have enough Base DC.", ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MinMC:
                    if (Stats[Stat.MinMC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat("You do not have enough Base MC.", ChatType.System);
                        return false;
                    }
                    break;
                case RequiredType.MinSC:
                    if (Stats[Stat.MinSC] < item.Info.RequiredAmount)
                    {
                        ReceiveChat("You do not have enough Base SC.", ChatType.System);
                        return false;
                    }
                    break;
            }

            switch (item.Info.Type)
            {
                case ItemType.Scroll:
                    switch (item.Info.Shape)
                    {
                        case 0:
                            if (CurrentMap.Info.NoEscape)
                            {
                                ReceiveChat(GameLanguage.CanNotDungeon, ChatType.System);
                                return false;
                            }
                            break;
                        case 1:
                            if (CurrentMap.Info.NoTownTeleport)
                            {
                                ReceiveChat(GameLanguage.NoTownTeleport, ChatType.System);
                                return false;
                            }
                            break;
                        case 2:
                            if (CurrentMap.Info.NoRandom)
                            {
                                ReceiveChat(GameLanguage.CanNotRandom, ChatType.System);
                                return false;
                            }
                            break;
                        case 6:
                            if (!Dead)
                            {
                                ReceiveChat(GameLanguage.CannotResurrection, ChatType.Hint);
                                return false;
                            }
                            break;
                        case 10:
                            {
                                int skillId = item.Info.Effect;

                                if (MyGuild == null)
                                {
                                    ReceiveChat("You must be in a guild to use this skill", ChatType.Hint);
                                    return false;
                                }
                                if (MyGuildRank != MyGuild.Ranks[0])
                                {
                                    ReceiveChat("You must be the guild leader to use this skill", ChatType.Hint);
                                    return false;
                                }
                                GuildBuffInfo buffInfo = Envir.FindGuildBuffInfo(skillId);

                                if (buffInfo == null) return false;

                                if (MyGuild.BuffList.Any(e => e.Info.Id == skillId))
                                {
                                    ReceiveChat("Your guild already has this skill", ChatType.Hint);
                                    return false;
                                }
                            }
                            break;
                    }
                    break;
                case ItemType.Potion:
                    if (CurrentMap.Info.NoDrug)
                    {
                        ReceiveChat("You cannot use Potions here", ChatType.System);
                        return false;
                    }
                    break;

                case ItemType.Book:
                    if (Info.Magics.Any(t => t.Spell == (Spell)item.Info.Shape))
                    {
                        return false;
                    }
                    break;
                case ItemType.Saddle:
                case ItemType.Ribbon:
                case ItemType.Bells:
                case ItemType.Mask:
                case ItemType.Reins:
                    if (Info.Equipment[(int)EquipmentSlot.Mount] == null)
                    {
                        ReceiveChat("Can only be used with a mount", ChatType.System);
                        return false;
                    }
                    break;
                case ItemType.Hook:
                case ItemType.Float:
                case ItemType.Bait:
                case ItemType.Finder:
                case ItemType.Reel:
                    if (Info.Equipment[(int)EquipmentSlot.Weapon] == null || !Info.Equipment[(int)EquipmentSlot.Weapon].Info.IsFishingRod)
                    {
                        ReceiveChat("Can only be used with a fishing rod", ChatType.System);
                        return false;
                    }
                    break;
                case ItemType.Socket:
                    break;
                case ItemType.Pets:
                    switch (item.Info.Shape)
                    {
                        case 20://mirror rename creature
                            if (Info.IntelligentCreatures.Count == 0) return false;
                            break;
                        case 21://creature stone
                            break;
                        case 22://nuts maintain food levels
                            if (!CreatureSummoned)
                            {
                                ReceiveChat("Can only be used with a creature summoned", ChatType.System);
                                return false;
                            }
                            break;
                        case 23://basic creature food
                            if (!CreatureSummoned)
                            {
                                ReceiveChat("Can only be used with a creature summoned", ChatType.System);
                                return false;
                            }
                            else
                            {
                                for (int i = 0; i < Pets.Count; i++)
                                {
                                    if (Pets[i].Info.AI != 64) continue;
                                    if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;


                                    if (((IntelligentCreatureObject)Pets[i]).Fullness > 9900)
                                    {
                                        ReceiveChat(((IntelligentCreatureObject)Pets[i]).Name + " is not hungry", ChatType.System);
                                        return false;
                                    }
                                    return true;
                                }
                                return false;
                            }
                        case 24://wonderpill vitalize creature
                            if (!CreatureSummoned)
                            {
                                ReceiveChat("Can only be used with a creature summoned", ChatType.System);
                                return false;
                            }
                            else
                            {
                                for (int i = 0; i < Pets.Count; i++)
                                {
                                    if (Pets[i].Info.AI != 64) continue;
                                    if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;


                                    if (((IntelligentCreatureObject)Pets[i]).Fullness > 0)
                                    {
                                        ReceiveChat(((IntelligentCreatureObject)Pets[i]).Name + " does not need to be vitalized", ChatType.System);
                                        return false;
                                    }
                                    return true;
                                }
                                return false;
                            }
                        case 25://Strongbox
                            break;
                        case 26://Wonderdrugs
                            break;
                        case 27://Fortunecookies
                            break;
                    }
                    break;
            }

            if (RidingMount && item.Info.Type != ItemType.Scroll && item.Info.Type != ItemType.Potion)
            {
                return false;
            }

            //if (item.Info.Type == ItemType.Book)
            //    for (int i = 0; i < Info.Magics.Count; i++)
            //        if (Info.Magics[i].Spell == (Spell)item.Info.Shape) return false;

            return true;
        }
        private bool CanEquipItem(UserItem item, int slot)
        {
            switch ((EquipmentSlot)slot)
            {
                case EquipmentSlot.Weapon:
                    if (item.Info.Type != ItemType.Weapon)
                        return false;
                    break;
                case EquipmentSlot.Armour:
                    if (item.Info.Type != ItemType.Armour)
                        return false;
                    break;
                case EquipmentSlot.Helmet:
                    if (item.Info.Type != ItemType.Helmet)
                        return false;
                    break;
                case EquipmentSlot.Torch:
                    if (item.Info.Type != ItemType.Torch)
                        return false;
                    break;
                case EquipmentSlot.Necklace:
                    if (item.Info.Type != ItemType.Necklace)
                        return false;
                    break;
                case EquipmentSlot.BraceletL:
                    if (item.Info.Type != ItemType.Bracelet)
                        return false;
                    break;
                case EquipmentSlot.BraceletR:
                    if (item.Info.Type != ItemType.Bracelet)
                        return false;
                    break;
                case EquipmentSlot.RingL:
                case EquipmentSlot.RingR:
                    if (item.Info.Type != ItemType.Ring)
                        return false;
                    break;
                case EquipmentSlot.Amulet:
                    if (item.Info.Type != ItemType.Amulet)
                        return false;
                    break;
                case EquipmentSlot.TaoPoison:
                    if (item.Info.Type != ItemType.TaoPoison)
                        return false;
                    break;
                case EquipmentSlot.Boots:
                    if (item.Info.Type != ItemType.Boots)
                        return false;
                    break;
                case EquipmentSlot.Belt:
                    if (item.Info.Type != ItemType.Belt)
                        return false;
                    break;
                case EquipmentSlot.Stone:
                    if (item.Info.Type != ItemType.Stone)
                        return false;
                    break;
                case EquipmentSlot.Mount:
                    if (item.Info.Type != ItemType.Mount)
                        return false;
                    break;

                case EquipmentSlot.Trophy:
                    if (item.Info.Type != ItemType.Trophy)
                        return false;
                    break;
                case EquipmentSlot.Trinket:
                    if (item.Info.Type != ItemType.Trinket)
                        return false;
                    break;
                case EquipmentSlot.Medal:
                    if (item.Info.Type != ItemType.Medal)
                        return false;
                    break;
                case EquipmentSlot.Crystal:
                    if (item.Info.Type != ItemType.Crystal)
                        return false;
                    break;
                case EquipmentSlot.ShoulderPads:
                    if (item.Info.Type != ItemType.ShoulderPads)
                        return false;
                    break;
                default:
                    return false;
            }


            switch (Gender)
            {
                case MirGender.Male:
                    if (!item.Info.RequiredGender.HasFlag(RequiredGender.Male))
                        return false;
                    break;
                case MirGender.Female:
                    if (!item.Info.RequiredGender.HasFlag(RequiredGender.Female))
                        return false;
                    break;
            }


            switch (Class)
            {
                case MirClass.Warrior:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Warrior))
                        return false;
                    break;
                case MirClass.Wizard:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Wizard))
                        return false;
                    break;
                case MirClass.Taoist:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Taoist))
                        return false;
                    break;
                case MirClass.Assassin:
                    if (!item.Info.RequiredClass.HasFlag(RequiredClass.Assassin))
                        return false;
                    break;
            }

            switch (item.Info.RequiredType)
            {
                case RequiredType.Reborn:
                    if (Reborn < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.InstanceStage:
                    if (InstanceStage < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.ChallengeStage:
                    if (ChallengeStage < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.Level:
                    if (Level < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MaxAC:
                    if (Stats[Stat.MaxAC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MaxMAC:
                    if (Stats[Stat.MaxMAC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MaxDC:
                    if (Stats[Stat.MaxDC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MaxMC:
                    if (Stats[Stat.MaxMC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MaxSC:
                    if (Stats[Stat.MaxSC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MaxLevel:
                    if (Level > item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MinAC:
                    if (Stats[Stat.MinAC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MinMAC:
                    if (Stats[Stat.MinMAC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MinDC:
                    if (Stats[Stat.MinDC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MinMC:
                    if (Stats[Stat.MinMC] < item.Info.RequiredAmount)
                        return false;
                    break;
                case RequiredType.MinSC:
                    if (Stats[Stat.MinSC] < item.Info.RequiredAmount)
                        return false;
                    break;
            }

            if (item.Info.Type == ItemType.Weapon || item.Info.Type == ItemType.Torch)
            {
                if (item.Weight - (Info.Equipment[slot] != null ? Info.Equipment[slot].Weight : 0) + CurrentHandWeight > Stats[Stat.HandWeight])
                    return false;
            }
            else
                if (item.Weight - (Info.Equipment[slot] != null ? Info.Equipment[slot].Weight : 0) + CurrentWearWeight > Stats[Stat.WearWeight])
                    return false;

            if (RidingMount && item.Info.Type != ItemType.Torch)
            {
                return false;
            }

            return true;
        }
        public bool CanRemoveItem(MirGridType grid, UserItem item)
        {
            //Item  Stuck

            UserItem[] array;
            switch (grid)
            {
                case MirGridType.Inventory:
                    array = Info.Inventory;
                    break;
                case MirGridType.Storage:
                    array = Account.Storage;
                    break;
                default:
                    return false;
            }

            if (RidingMount && item.Info.Type != ItemType.Torch)
            {
                return false;
            }

            return FreeSpace(array) > 0;
        }

        public bool CheckQuestItem(UserItem uItem, ushort count)
        {
            foreach (var item in Info.QuestInventory.Where(item => item != null && item.Info == uItem.Info))
            {
                if (count > item.Count)
                {
                    count -= item.Count;
                    continue;
                }

                if (count > item.Count) continue;
                count = 0;
                break;
            }

            return count <= 0;
        }
        public bool CanGainQuestItem(UserItem item)
        {
            if (FreeSpace(Info.QuestInventory) > 0) return true;

            if (item.Info.StackSize > 1)
            {
                ushort count = item.Count;

                for (int i = 0; i < Info.QuestInventory.Length; i++)
                {
                    UserItem bagItem = Info.QuestInventory[i];

                    if (bagItem.Info != item.Info) continue;

                    if (bagItem.Count + count <= bagItem.Info.StackSize) return true;

                    count -= (ushort)(bagItem.Info.StackSize - bagItem.Count);
                }
            }

            ReceiveChat("You cannot carry anymore quest items.", ChatType.System);

            return false;
        }
        public void GainQuestItem(UserItem item)
        {
            CheckItem(item);

            UserItem clonedItem = item.Clone();

            Enqueue(new S.GainedQuestItem { Item = clonedItem });

            AddQuestItem(item);
        }

        public void TakeQuestItem(ItemInfo uItem, ushort count)
        {
            for (int o = 0; o < Info.QuestInventory.Length; o++)
            {
                UserItem item = Info.QuestInventory[o];
                if (item == null) continue;
                if (item.Info != uItem) continue;

                if (count > item.Count)
                {
                    Enqueue(new S.DeleteQuestItem { UniqueID = item.UniqueID, Count = item.Count });
                    Info.QuestInventory[o] = null;

                    count -= item.Count;
                    continue;
                }

                Enqueue(new S.DeleteQuestItem { UniqueID = item.UniqueID, Count = count });

                if (count == item.Count)
                    Info.QuestInventory[o] = null;
                else
                    item.Count -= count;
                break;
            }
        }

        private void DamageDura()
        {
            if (!SpecialMode.HasFlag(SpecialItemMode.NoDuraLoss))
                for (int i = 0; i < Info.Equipment.Length; i++)
                    if (i != (int)EquipmentSlot.Weapon)
                        DamageItem(Info.Equipment[i], Envir.Random.Next(1) + 1);
        }
        public void DamageWeapon()
        {
            if (!SpecialMode.HasFlag(SpecialItemMode.NoDuraLoss))
                DamageItem(Info.Equipment[(int)EquipmentSlot.Weapon], Envir.Random.Next(4) + 1);
        }
        public void DamageItem(UserItem item, int amount, bool isChanged = false)
        {
            if (item == null || item.CurrentDura == 0 || item.Info.Type == ItemType.Amulet || item.Info.Type == ItemType.TaoPoison) return;
            if ((item.WeddingRing == Info.Married) && (Info.Equipment[(int)EquipmentSlot.RingL].UniqueID == item.UniqueID)) return;
            if (item.GetTotal(Stat.Strong) > 0) amount = Math.Max(1, amount - item.GetTotal(Stat.Strong));
            item.CurrentDura = (ushort)Math.Max(ushort.MinValue, item.CurrentDura - amount);
            item.DuraChanged = true;

            if (item.CurrentDura > 0 && isChanged != true) return;
            Enqueue(new S.DuraChanged { UniqueID = item.UniqueID, CurrentDura = item.CurrentDura });

            item.DuraChanged = false;
            RefreshStats();
        }
        private void ConsumeItem(UserItem item, byte cost)
        {
            item.Count -= cost;
            Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = cost });

            if (item.Count != 0) return;

            for (int i = 0; i < Info.Equipment.Length; i++)
            {
                if (Info.Equipment[i] != null && Info.Equipment[i].Slots.Length > 0)
                {
                    for (int j = 0; j < Info.Equipment[i].Slots.Length; j++)
                    {
                        if (Info.Equipment[i].Slots[j] != item) continue;
                        Info.Equipment[i].Slots[j] = null;
                        return;
                    }
                }

                if (Info.Equipment[i] != item) continue;
                Info.Equipment[i] = null;

                return;
            }

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                if (Info.Inventory[i] != item) continue;
                Info.Inventory[i] = null;
                return;
            }

            //Item not found
        }

        private bool TryLuckWeapon()
        {
            var item = Info.Equipment[(int)EquipmentSlot.Weapon];

            if (item == null || item.AddedStats[Stat.Luck] >= 7)
                return false;

            if (item.Info.Bind.HasFlag(BindMode.DontUpgrade))
                return false;

            if (item.RentalInformation != null && item.RentalInformation.BindingFlags.HasFlag(BindMode.DontUpgrade))
                return false;

            if (item.AddedStats[Stat.Luck] > (Settings.MaxLuck * -1) && Envir.Random.Next(20) == 0)
            {
                Stats[Stat.Luck]--;
                item.AddedStats[Stat.Luck]--;
                Enqueue(new S.RefreshItem { Item = item });
                ReceiveChat(GameLanguage.WeaponCurse, ChatType.System);
            }
            else if (item.AddedStats[Stat.Luck] <= 0 || Envir.Random.Next(10 * item.GetTotal(Stat.Luck)) == 0)
            {
                Stats[Stat.Luck]++;
                item.AddedStats[Stat.Luck]++;
                Enqueue(new S.RefreshItem { Item = item });
                ReceiveChat(GameLanguage.WeaponLuck, ChatType.Hint);
            }
            else
            {
                ReceiveChat(GameLanguage.WeaponNoEffect, ChatType.Hint);
            }

            return true;
        }

        public void RequestChatItem(ulong id)
        {
            //Enqueue(new S.ChatItemStats { ChatItemId = id, Stats = whatever });
        }
        public void Inspect(uint id)
        {
            if (ObjectID == id) return;

            PlayerObject player = CurrentMap.Players.SingleOrDefault(x => x.ObjectID == id || x.Pets.Count(y => y.ObjectID == id && y is Monsters.WizardClone) > 0);

            if (player == null) return;
            Inspect(player.Info.Index);
        }
        public void Inspect(int id)
        {
            if (ObjectID == id) return;
            CharacterInfo player = Envir.GetCharacterInfo(id);
            if (player == null) return;
            CharacterInfo Lover = null;
            string loverName = "";
            if (player.Married != 0) Lover = Envir.GetCharacterInfo(player.Married);

            if (Lover != null)
                loverName = Lover.Name;

            for (int i = 0; i < player.Equipment.Length; i++)
            {
                UserItem u = player.Equipment[i];
                if (u == null) continue;

                CheckItem(u);
            }
            string guildname = "";
            string guildrank = "";
            GuildObject Guild = null;
            GuildRank GuildRank = null;
            if (player.GuildIndex != -1)
            {
                Guild = Envir.GetGuild(player.GuildIndex);
                if (Guild != null)
                {
                    GuildRank = Guild.FindRank(player.Name);
                    if (GuildRank == null)
                        Guild = null;
                    else
                    {
                        guildname = Guild.Name;
                        guildrank = GuildRank.Name;
                    }
                }
            }
            Enqueue(new S.PlayerInspect
            {
                Name = player.Name,
                Equipment = player.Equipment,
                GuildName = guildname,
                GuildRank = guildrank,
                Hair = player.Hair,
                Gender = player.Gender,
                Class = player.Class,
                Level = player.Level,
                LoverName = loverName
            });
        }
        public void RemoveObjects(MirDirection dir, int count)
        {
            switch (dir)
            {
                case MirDirection.Up:
                    //Bottom Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y + Globals.DataRange - a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
                case MirDirection.UpRight:
                    //Bottom Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y + Globals.DataRange - a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }

                    //Left Block
                    for (int a = -Globals.DataRange; a <= Globals.DataRange - count; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X - Globals.DataRange + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
                case MirDirection.Right:
                    //Left Block
                    for (int a = -Globals.DataRange; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X - Globals.DataRange + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
                case MirDirection.DownRight:
                    //Top Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y - Globals.DataRange + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }

                    //Left Block
                    for (int a = -Globals.DataRange + count; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X - Globals.DataRange + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
                case MirDirection.Down:
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y - Globals.DataRange + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
                case MirDirection.DownLeft:
                    //Top Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y - Globals.DataRange + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }

                    //Right Block
                    for (int a = -Globals.DataRange + count; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X + Globals.DataRange - b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
                case MirDirection.Left:
                    for (int a = -Globals.DataRange; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X + Globals.DataRange - b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
                case MirDirection.UpLeft:
                    //Bottom Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y + Globals.DataRange - a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }

                    //Right Block
                    for (int a = -Globals.DataRange; a <= Globals.DataRange - count; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X + Globals.DataRange - b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Remove(this);
                            }
                        }
                    }
                    break;
            }
        }
        public void AddObjects(MirDirection dir, int count)
        {
            switch (dir)
            {
                case MirDirection.Up:
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y - Globals.DataRange + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
                case MirDirection.UpRight:
                    //Top Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y - Globals.DataRange + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }

                    //Right Block
                    for (int a = -Globals.DataRange + count; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X + Globals.DataRange - b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
                case MirDirection.Right:
                    for (int a = -Globals.DataRange; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X + Globals.DataRange - b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
                case MirDirection.DownRight:
                    //Bottom Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y + Globals.DataRange - a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }

                    //Right Block
                    for (int a = -Globals.DataRange; a <= Globals.DataRange - count; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X + Globals.DataRange - b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
                case MirDirection.Down:
                    //Bottom Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y + Globals.DataRange - a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
                case MirDirection.DownLeft:
                    //Bottom Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y + Globals.DataRange - a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }

                    //Left Block
                    for (int a = -Globals.DataRange; a <= Globals.DataRange - count; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X - Globals.DataRange + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
                case MirDirection.Left:
                    //Left Block
                    for (int a = -Globals.DataRange; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X - Globals.DataRange + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
                case MirDirection.UpLeft:
                    //Top Block
                    for (int a = 0; a < count; a++)
                    {
                        int y = CurrentLocation.Y - Globals.DataRange + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = -Globals.DataRange; b <= Globals.DataRange; b++)
                        {
                            int x = CurrentLocation.X + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }

                    //Left Block
                    for (int a = -Globals.DataRange + count; a <= Globals.DataRange; a++)
                    {
                        int y = CurrentLocation.Y + a;
                        if (y < 0 || y >= CurrentMap.Height) continue;

                        for (int b = 0; b < count; b++)
                        {
                            int x = CurrentLocation.X - Globals.DataRange + b;
                            if (x < 0 || x >= CurrentMap.Width) continue;

                            Cell cell = CurrentMap.GetCell(x, y);

                            if (!cell.Valid || cell.Objects == null) continue;

                            for (int i = 0; i < cell.Objects.Count; i++)
                            {
                                MapObject ob = cell.Objects[i];
                                ob.Add(this);
                            }
                        }
                    }
                    break;
            }
        }
        public override void Remove(PlayerObject player)
        {
            if (player == this) return;

            base.Remove(player);
            Enqueue(new S.ObjectRemove { ObjectID = player.ObjectID });
        }
        public override void Add(PlayerObject player)
        {
            if (player == this) return;

            //base.Add(player);
            Enqueue(player.GetInfoEx(this));
            player.Enqueue(GetInfoEx(player));

            player.SendHealth(this);
            SendHealth(player);
        }
        public override void Remove(MonsterObject monster)
        {
            Enqueue(new S.ObjectRemove { ObjectID = monster.ObjectID });
        }
        public override void Add(MonsterObject monster)
        {
            Enqueue(monster.GetInfo());

            monster.SendHealth(this);
        }
        public override void SendHealth(PlayerObject player)
        {
            if (!player.IsMember(this) && Envir.Time > RevTime) return;
            byte time = Math.Min(byte.MaxValue, (byte)Math.Max(5, (RevTime - Envir.Time) / 1000));
            player.Enqueue(new S.ObjectHealth { ObjectID = ObjectID, Percent = PercentHealth, Expire = time });
        }

        public override void ReceiveChat(string text, ChatType type)
        {
            Enqueue(new S.Chat { Message = text, Type = type });
        }

        public void ReceiveOutputMessage(string text, OutputMessageType type)
        {
            Enqueue(new S.SendOutputMessage { Message = text, Type = type });
        }

        private void CleanUp()
        {
            Connection.Player = null;
            Info.Player = null;
            Info.Mount = null;
            Connection = null;
            Account = null;
            Info = null;
        }

        public void Enqueue(Packet p)
        {
            if (Connection == null) return;
            Connection.Enqueue(p);

            //MessageQueue.EnqueueDebugging(((ServerPacketIds)p.Index).ToString());
        }

        public void SpellToggle(Spell spell, bool use)
        {
            UserMagic magic;

            magic = GetMagic(spell);
            if (magic == null) return;

            int cost;
            switch (spell)
            {
                case Spell.Thrusting:
                    Info.Thrusting = use;
                    break;
                case Spell.HalfMoon:
                    Info.HalfMoon = use;
                    break;
                case Spell.CrossHalfMoon:
                    Info.CrossHalfMoon = use;
                    break;
                case Spell.DoubleSlash:
                    Info.DoubleSlash = use;
                    break;
                case Spell.TwinDrakeBlade:
                    if (TwinDrakeBlade) return;
                    magic = GetMagic(spell);
                    if (magic == null) return;
                    cost = magic.Info.BaseCost + magic.Level * magic.Info.LevelCost;
                    if (cost >= MP) return;

                    TwinDrakeBlade = true;
                    ChangeMP(-cost);

                    Enqueue(new S.ObjectMagic { ObjectID = ObjectID, Direction = Direction, Location = CurrentLocation, Spell = spell });
                    break;
                case Spell.FlamingSword:
                    if (FlamingSword || Envir.Time < FlamingSwordTime) return;
                    magic = GetMagic(spell);
                    if (magic == null) return;
                    cost = magic.Info.BaseCost + magic.Level * magic.Info.LevelCost;
                    if (cost >= MP) return;

                    FlamingSword = true;
                    FlamingSwordTime = Envir.Time + 10000;
                    Enqueue(new S.SpellToggle { Spell = Spell.FlamingSword, CanUse = true });
                    ChangeMP(-cost);
                    break;
                case Spell.WhirlWind:
                    if (WhirlWind || Envir.Time < WhirlWindTime) return;
                    magic = GetMagic(spell);
                    if (magic == null) return;
                    cost = magic.Info.BaseCost + magic.Level * magic.Info.LevelCost;
                    if (cost >= MP) return;

                    WhirlWind = true;
                    WhirlWindTime = Envir.Time + 5000;
                    Enqueue(new S.SpellToggle { Spell = Spell.WhirlWind, CanUse = true });
                    ChangeMP(-cost);
                    break;
                case Spell.IceSword:
                    if (IceSword || Envir.Time < IceSwordTime) return;
                    magic = GetMagic(spell);
                    if (magic == null) return;
                    cost = magic.Info.BaseCost + magic.Level * magic.Info.LevelCost;
                    if (cost >= MP) return;

                    IceSword = true;
                    IceSwordTime = Envir.Time + 5000;
                    Enqueue(new S.SpellToggle { Spell = Spell.IceSword, CanUse = true });
                    ChangeMP(-cost);
                    break;
                case Spell.CounterAttack:
                    if (CounterAttack || Envir.Time < CounterAttackTime) return;
                    magic = GetMagic(spell);
                    if (magic == null) return;
                    cost = magic.Info.BaseCost + magic.Level * magic.Info.LevelCost;
                    if (cost >= MP) return;

                    CounterAttack = true;
                    CounterAttackTime = Envir.Time + (Settings.Second * 10);

                    var stats = new Stats 
                    { 
                        [Stat.MinAC] = 11 + magic.Level * 3,
                        [Stat.MinMAC] = 11 + magic.Level * 3,
                        [Stat.MaxAC] = 11 + magic.Level * 3,
                        [Stat.MaxMAC] = 11 + magic.Level * 3,
                    };

                    AddBuff(BuffType.CounterAttack, this, Settings.Second * 10, stats);
                    ChangeMP(-cost);
                    break;
                case Spell.MentalState:
                    Info.MentalState = (byte)((Info.MentalState + 1) % 3);

                    ShowMentalState();
                    break;
            }
        }

        private void ShowMentalState()
        {
            switch (Info.MentalState)
            {
                case 0:
                    ReceiveChat("Mentalstate: Agressive.", ChatType.Hint);
                    break;
                case 1:
                    ReceiveChat("Mentalstate: Trick shot.", ChatType.Hint);
                    break;
                case 2:
                    ReceiveChat("Mentalstate: Group mode.", ChatType.Hint);
                    break;
            }

            AddBuff(BuffType.MentalState, this, 0, new Stats(), false, Info.MentalState);
        }

        private void UpdateGMBuff()
        {
            if (!IsGM) return;

            GMOptions options = GMOptions.None;

            if (GMGameMaster) options |= GMOptions.GameMaster;
            if (GMNeverDie) options |= GMOptions.Superman;
            if (Observer) options |= GMOptions.Observer;

            AddBuff(BuffType.GameMaster, this, 0, null, false, (byte)options);
        }
        private void UpdateRebornBuff()
        {
            switch (Reborn)
            {
                case 0:
                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    break;
                case 1:
                    var Reborn1 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC1,
                        [Stat.MaxAC] = Settings.RebornMaxAC1,
                        [Stat.MinMAC] = Settings.RebornMinMAC1,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC1,
                        [Stat.MinDC] = Settings.RebornMinDC1,
                        [Stat.MaxDC] = Settings.RebornMaxDC1,
                        [Stat.MinMC] = Settings.RebornMinMC1,
                        [Stat.MaxMC] = Settings.RebornMaxMC1,
                        [Stat.MinSC] = Settings.RebornMinSC1,
                        [Stat.MaxSC] = Settings.RebornMaxSC1,
                        [Stat.HP] = Settings.RebornHP1,
                        [Stat.MP] = Settings.RebornMP1,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage1,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage1,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction1,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate1,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate1,
                        [Stat.Accuracy] = Settings.RebornAccuracy1,
                        [Stat.Agility] = Settings.RebornAgility1,
                        [Stat.Freezing] = Settings.RebornFreezing1,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack1,
                        [Stat.MagicResist] = Settings.RebornMagicResist1,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist1,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery1,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery1,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery1,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate1,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage1,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate1,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate1,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate1,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate1,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate1,
                        [Stat.HPRatePercent] = Settings.RebornHPRate1,
                        [Stat.MPRatePercent] = Settings.RebornMPRate1,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain1,
                    };

                    int tempAttr1 = Settings.RebornAttribute1;
                    if (tempAttr1 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr1 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr1);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn1, this, 0, Reborn1);
                    break;
                case 2:
                    var Reborn2 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC2,
                        [Stat.MaxAC] = Settings.RebornMaxAC2,
                        [Stat.MinMAC] = Settings.RebornMinMAC2,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC2,
                        [Stat.MinDC] = Settings.RebornMinDC2,
                        [Stat.MaxDC] = Settings.RebornMaxDC2,
                        [Stat.MinMC] = Settings.RebornMinMC2,
                        [Stat.MaxMC] = Settings.RebornMaxMC2,
                        [Stat.MinSC] = Settings.RebornMinSC2,
                        [Stat.MaxSC] = Settings.RebornMaxSC2,
                        [Stat.HP] = Settings.RebornHP2,
                        [Stat.MP] = Settings.RebornMP2,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage2,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage2,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction2,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate2,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate2,
                        [Stat.Accuracy] = Settings.RebornAccuracy2,
                        [Stat.Agility] = Settings.RebornAgility2,
                        [Stat.Freezing] = Settings.RebornFreezing2,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack2,
                        [Stat.MagicResist] = Settings.RebornMagicResist2,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist2,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery2,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery2,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery2,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate2,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage2,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate2,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate2,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate2,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate2,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate2,
                        [Stat.HPRatePercent] = Settings.RebornHPRate2,
                        [Stat.MPRatePercent] = Settings.RebornMPRate2,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain2,
                    };

                    int tempAttr2 = Settings.RebornAttribute2;
                    if (tempAttr2 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr2 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr2);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn2, this, 0, Reborn2);
                    break;
                case 3:
                    var Reborn3 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC3,
                        [Stat.MaxAC] = Settings.RebornMaxAC3,
                        [Stat.MinMAC] = Settings.RebornMinMAC3,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC3,
                        [Stat.MinDC] = Settings.RebornMinDC3,
                        [Stat.MaxDC] = Settings.RebornMaxDC3,
                        [Stat.MinMC] = Settings.RebornMinMC3,
                        [Stat.MaxMC] = Settings.RebornMaxMC3,
                        [Stat.MinSC] = Settings.RebornMinSC3,
                        [Stat.MaxSC] = Settings.RebornMaxSC3,
                        [Stat.HP] = Settings.RebornHP3,
                        [Stat.MP] = Settings.RebornMP3,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage3,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage3,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction3,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate3,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate3,
                        [Stat.Accuracy] = Settings.RebornAccuracy3,
                        [Stat.Agility] = Settings.RebornAgility3,
                        [Stat.Freezing] = Settings.RebornFreezing3,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack3,
                        [Stat.MagicResist] = Settings.RebornMagicResist3,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist3,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery3,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery3,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery3,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate3,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage3,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate3,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate3,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate3,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate3,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate3,
                        [Stat.HPRatePercent] = Settings.RebornHPRate3,
                        [Stat.MPRatePercent] = Settings.RebornMPRate3,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain3,
                    };

                    int tempAttr3 = Settings.RebornAttribute3;
                    if (tempAttr3 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr3 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr3);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn3, this, 0, Reborn3);
                    break;
                case 4:
                    var Reborn4 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC4,
                        [Stat.MaxAC] = Settings.RebornMaxAC4,
                        [Stat.MinMAC] = Settings.RebornMinMAC4,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC4,
                        [Stat.MinDC] = Settings.RebornMinDC4,
                        [Stat.MaxDC] = Settings.RebornMaxDC4,
                        [Stat.MinMC] = Settings.RebornMinMC4,
                        [Stat.MaxMC] = Settings.RebornMaxMC4,
                        [Stat.MinSC] = Settings.RebornMinSC4,
                        [Stat.MaxSC] = Settings.RebornMaxSC4,
                        [Stat.HP] = Settings.RebornHP4,
                        [Stat.MP] = Settings.RebornMP4,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage4,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage4,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction4,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate4,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate4,
                        [Stat.Accuracy] = Settings.RebornAccuracy4,
                        [Stat.Agility] = Settings.RebornAgility4,
                        [Stat.Freezing] = Settings.RebornFreezing4,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack4,
                        [Stat.MagicResist] = Settings.RebornMagicResist4,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist4,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery4,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery4,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery4,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate4,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage4,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate4,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate4,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate4,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate4,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate4,
                        [Stat.HPRatePercent] = Settings.RebornHPRate4,
                        [Stat.MPRatePercent] = Settings.RebornMPRate4,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain4,
                    };

                    int tempAttr4 = Settings.RebornAttribute4;
                    if (tempAttr4 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr4 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr4);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn4, this, 0, Reborn4);
                    break;
                case 5:
                    var Reborn5 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC5,
                        [Stat.MaxAC] = Settings.RebornMaxAC5,
                        [Stat.MinMAC] = Settings.RebornMinMAC5,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC5,
                        [Stat.MinDC] = Settings.RebornMinDC5,
                        [Stat.MaxDC] = Settings.RebornMaxDC5,
                        [Stat.MinMC] = Settings.RebornMinMC5,
                        [Stat.MaxMC] = Settings.RebornMaxMC5,
                        [Stat.MinSC] = Settings.RebornMinSC5,
                        [Stat.MaxSC] = Settings.RebornMaxSC5,
                        [Stat.HP] = Settings.RebornHP5,
                        [Stat.MP] = Settings.RebornMP5,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage5,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage5,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction5,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate5,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate5,
                        [Stat.Accuracy] = Settings.RebornAccuracy5,
                        [Stat.Agility] = Settings.RebornAgility5,
                        [Stat.Freezing] = Settings.RebornFreezing5,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack5,
                        [Stat.MagicResist] = Settings.RebornMagicResist5,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist5,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery5,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery5,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery5,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate5,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage5,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate5,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate5,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate5,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate5,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate5,
                        [Stat.HPRatePercent] = Settings.RebornHPRate5,
                        [Stat.MPRatePercent] = Settings.RebornMPRate5,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain5,
                    };

                    int tempAttr5 = Settings.RebornAttribute5;
                    if (tempAttr5 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr5 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr5);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn5, this, 0, Reborn5);
                    break;
                case 6:
                    var Reborn6 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC6,
                        [Stat.MaxAC] = Settings.RebornMaxAC6,
                        [Stat.MinMAC] = Settings.RebornMinMAC6,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC6,
                        [Stat.MinDC] = Settings.RebornMinDC6,
                        [Stat.MaxDC] = Settings.RebornMaxDC6,
                        [Stat.MinMC] = Settings.RebornMinMC6,
                        [Stat.MaxMC] = Settings.RebornMaxMC6,
                        [Stat.MinSC] = Settings.RebornMinSC6,
                        [Stat.MaxSC] = Settings.RebornMaxSC6,
                        [Stat.HP] = Settings.RebornHP6,
                        [Stat.MP] = Settings.RebornMP6,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage6,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage6,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction6,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate6,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate6,
                        [Stat.Accuracy] = Settings.RebornAccuracy6,
                        [Stat.Agility] = Settings.RebornAgility6,
                        [Stat.Freezing] = Settings.RebornFreezing6,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack6,
                        [Stat.MagicResist] = Settings.RebornMagicResist6,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist6,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery6,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery6,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery6,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate6,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage6,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate6,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate6,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate6,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate6,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate6,
                        [Stat.HPRatePercent] = Settings.RebornHPRate6,
                        [Stat.MPRatePercent] = Settings.RebornMPRate6,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain6,
                    };

                    int tempAttr6 = Settings.RebornAttribute6;
                    if (tempAttr6 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr6 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr6);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn6, this, 0, Reborn6);
                    break;
                case 7:
                    var Reborn7 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC7,
                        [Stat.MaxAC] = Settings.RebornMaxAC7,
                        [Stat.MinMAC] = Settings.RebornMinMAC7,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC7,
                        [Stat.MinDC] = Settings.RebornMinDC7,
                        [Stat.MaxDC] = Settings.RebornMaxDC7,
                        [Stat.MinMC] = Settings.RebornMinMC7,
                        [Stat.MaxMC] = Settings.RebornMaxMC7,
                        [Stat.MinSC] = Settings.RebornMinSC7,
                        [Stat.MaxSC] = Settings.RebornMaxSC7,
                        [Stat.HP] = Settings.RebornHP7,
                        [Stat.MP] = Settings.RebornMP7,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage7,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage7,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction7,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate7,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate7,
                        [Stat.Accuracy] = Settings.RebornAccuracy7,
                        [Stat.Agility] = Settings.RebornAgility7,
                        [Stat.Freezing] = Settings.RebornFreezing7,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack7,
                        [Stat.MagicResist] = Settings.RebornMagicResist7,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist7,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery7,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery7,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery7,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate7,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage7,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate7,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate7,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate7,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate7,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate7,
                        [Stat.HPRatePercent] = Settings.RebornHPRate7,
                        [Stat.MPRatePercent] = Settings.RebornMPRate7,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain7,
                    };

                    int tempAttr7 = Settings.RebornAttribute7;
                    if (tempAttr7 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr7 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr7);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn7, this, 0, Reborn7);
                    break;
                case 8:
                    var Reborn8 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC8,
                        [Stat.MaxAC] = Settings.RebornMaxAC8,
                        [Stat.MinMAC] = Settings.RebornMinMAC8,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC8,
                        [Stat.MinDC] = Settings.RebornMinDC8,
                        [Stat.MaxDC] = Settings.RebornMaxDC8,
                        [Stat.MinMC] = Settings.RebornMinMC8,
                        [Stat.MaxMC] = Settings.RebornMaxMC8,
                        [Stat.MinSC] = Settings.RebornMinSC8,
                        [Stat.MaxSC] = Settings.RebornMaxSC8,
                        [Stat.HP] = Settings.RebornHP8,
                        [Stat.MP] = Settings.RebornMP8,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage8,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage8,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction8,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate8,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate8,
                        [Stat.Accuracy] = Settings.RebornAccuracy8,
                        [Stat.Agility] = Settings.RebornAgility8,
                        [Stat.Freezing] = Settings.RebornFreezing8,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack8,
                        [Stat.MagicResist] = Settings.RebornMagicResist8,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist8,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery8,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery8,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery8,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate8,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage8,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate8,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate8,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate8,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate8,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate8,
                        [Stat.HPRatePercent] = Settings.RebornHPRate8,
                        [Stat.MPRatePercent] = Settings.RebornMPRate8,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain8,
                    };

                    int tempAttr8 = Settings.RebornAttribute8;
                    if (tempAttr8 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr8 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr8);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn8, this, 0, Reborn8);
                    break;
                case 9:
                    var Reborn9 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC9,
                        [Stat.MaxAC] = Settings.RebornMaxAC9,
                        [Stat.MinMAC] = Settings.RebornMinMAC9,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC9,
                        [Stat.MinDC] = Settings.RebornMinDC9,
                        [Stat.MaxDC] = Settings.RebornMaxDC9,
                        [Stat.MinMC] = Settings.RebornMinMC9,
                        [Stat.MaxMC] = Settings.RebornMaxMC9,
                        [Stat.MinSC] = Settings.RebornMinSC9,
                        [Stat.MaxSC] = Settings.RebornMaxSC9,
                        [Stat.HP] = Settings.RebornHP9,
                        [Stat.MP] = Settings.RebornMP9,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage9,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage9,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction9,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate9,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate9,
                        [Stat.Accuracy] = Settings.RebornAccuracy9,
                        [Stat.Agility] = Settings.RebornAgility9,
                        [Stat.Freezing] = Settings.RebornFreezing9,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack9,
                        [Stat.MagicResist] = Settings.RebornMagicResist9,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist9,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery9,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery9,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery9,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate9,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage9,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate9,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate9,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate9,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate9,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate9,
                        [Stat.HPRatePercent] = Settings.RebornHPRate9,
                        [Stat.MPRatePercent] = Settings.RebornMPRate9,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain9,
                    };

                    int tempAttr9 = Settings.RebornAttribute9;
                    if (tempAttr9 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr9 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr9);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn9, this, 0, Reborn9);
                    break;
                case 10:
                    var Reborn10 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC10,
                        [Stat.MaxAC] = Settings.RebornMaxAC10,
                        [Stat.MinMAC] = Settings.RebornMinMAC10,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC10,
                        [Stat.MinDC] = Settings.RebornMinDC10,
                        [Stat.MaxDC] = Settings.RebornMaxDC10,
                        [Stat.MinMC] = Settings.RebornMinMC10,
                        [Stat.MaxMC] = Settings.RebornMaxMC10,
                        [Stat.MinSC] = Settings.RebornMinSC10,
                        [Stat.MaxSC] = Settings.RebornMaxSC10,
                        [Stat.HP] = Settings.RebornHP10,
                        [Stat.MP] = Settings.RebornMP10,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage10,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage10,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction10,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate10,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate10,
                        [Stat.Accuracy] = Settings.RebornAccuracy10,
                        [Stat.Agility] = Settings.RebornAgility10,
                        [Stat.Freezing] = Settings.RebornFreezing10,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack10,
                        [Stat.MagicResist] = Settings.RebornMagicResist10,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist10,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery10,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery10,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery10,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate10,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage10,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate10,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate10,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate10,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate10,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate10,
                        [Stat.HPRatePercent] = Settings.RebornHPRate10,
                        [Stat.MPRatePercent] = Settings.RebornMPRate10,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain10,
                    };

                    int tempAttr10 = Settings.RebornAttribute10;
                    if (tempAttr10 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr10 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr10);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn10, this, 0, Reborn10);
                    break;
                case 11:
                    var Reborn11 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC11,
                        [Stat.MaxAC] = Settings.RebornMaxAC11,
                        [Stat.MinMAC] = Settings.RebornMinMAC11,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC11,
                        [Stat.MinDC] = Settings.RebornMinDC11,
                        [Stat.MaxDC] = Settings.RebornMaxDC11,
                        [Stat.MinMC] = Settings.RebornMinMC11,
                        [Stat.MaxMC] = Settings.RebornMaxMC11,
                        [Stat.MinSC] = Settings.RebornMinSC11,
                        [Stat.MaxSC] = Settings.RebornMaxSC11,
                        [Stat.HP] = Settings.RebornHP11,
                        [Stat.MP] = Settings.RebornMP11,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage11,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage11,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction11,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate11,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate11,
                        [Stat.Accuracy] = Settings.RebornAccuracy11,
                        [Stat.Agility] = Settings.RebornAgility11,
                        [Stat.Freezing] = Settings.RebornFreezing11,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack11,
                        [Stat.MagicResist] = Settings.RebornMagicResist11,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist11,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery11,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery11,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery11,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate11,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage11,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate11,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate11,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate11,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate11,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate11,
                        [Stat.HPRatePercent] = Settings.RebornHPRate11,
                        [Stat.MPRatePercent] = Settings.RebornMPRate11,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain11,
                    };

                    int tempAttr11 = Settings.RebornAttribute11;
                    if (tempAttr11 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr11 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr11);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn11, this, 0, Reborn11);
                    break;
                case 12:
                    var Reborn12 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC12,
                        [Stat.MaxAC] = Settings.RebornMaxAC12,
                        [Stat.MinMAC] = Settings.RebornMinMAC12,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC12,
                        [Stat.MinDC] = Settings.RebornMinDC12,
                        [Stat.MaxDC] = Settings.RebornMaxDC12,
                        [Stat.MinMC] = Settings.RebornMinMC12,
                        [Stat.MaxMC] = Settings.RebornMaxMC12,
                        [Stat.MinSC] = Settings.RebornMinSC12,
                        [Stat.MaxSC] = Settings.RebornMaxSC12,
                        [Stat.HP] = Settings.RebornHP12,
                        [Stat.MP] = Settings.RebornMP12,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage12,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage12,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction12,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate12,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate12,
                        [Stat.Accuracy] = Settings.RebornAccuracy12,
                        [Stat.Agility] = Settings.RebornAgility12,
                        [Stat.Freezing] = Settings.RebornFreezing12,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack12,
                        [Stat.MagicResist] = Settings.RebornMagicResist12,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist12,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery12,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery12,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery12,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate12,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage12,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate12,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate12,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate12,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate12,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate12,
                        [Stat.HPRatePercent] = Settings.RebornHPRate12,
                        [Stat.MPRatePercent] = Settings.RebornMPRate12,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain12,
                    };

                    int tempAttr12 = Settings.RebornAttribute12;
                    if (tempAttr12 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr12 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr12);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn12, this, 0, Reborn12);
                    break;
                case 13:
                    var Reborn13 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC13,
                        [Stat.MaxAC] = Settings.RebornMaxAC13,
                        [Stat.MinMAC] = Settings.RebornMinMAC13,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC13,
                        [Stat.MinDC] = Settings.RebornMinDC13,
                        [Stat.MaxDC] = Settings.RebornMaxDC13,
                        [Stat.MinMC] = Settings.RebornMinMC13,
                        [Stat.MaxMC] = Settings.RebornMaxMC13,
                        [Stat.MinSC] = Settings.RebornMinSC13,
                        [Stat.MaxSC] = Settings.RebornMaxSC13,
                        [Stat.HP] = Settings.RebornHP13,
                        [Stat.MP] = Settings.RebornMP13,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage13,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage13,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction13,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate13,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate13,
                        [Stat.Accuracy] = Settings.RebornAccuracy13,
                        [Stat.Agility] = Settings.RebornAgility13,
                        [Stat.Freezing] = Settings.RebornFreezing13,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack13,
                        [Stat.MagicResist] = Settings.RebornMagicResist13,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist13,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery13,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery13,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery13,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate13,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage13,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate13,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate13,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate13,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate13,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate13,
                        [Stat.HPRatePercent] = Settings.RebornHPRate13,
                        [Stat.MPRatePercent] = Settings.RebornMPRate13,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain13,
                    };

                    int tempAttr13 = Settings.RebornAttribute13;
                    if (tempAttr13 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr13 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr13);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn13, this, 0, Reborn13);
                    break;
                case 14:
                    var Reborn14 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC14,
                        [Stat.MaxAC] = Settings.RebornMaxAC14,
                        [Stat.MinMAC] = Settings.RebornMinMAC14,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC14,
                        [Stat.MinDC] = Settings.RebornMinDC14,
                        [Stat.MaxDC] = Settings.RebornMaxDC14,
                        [Stat.MinMC] = Settings.RebornMinMC14,
                        [Stat.MaxMC] = Settings.RebornMaxMC14,
                        [Stat.MinSC] = Settings.RebornMinSC14,
                        [Stat.MaxSC] = Settings.RebornMaxSC14,
                        [Stat.HP] = Settings.RebornHP14,
                        [Stat.MP] = Settings.RebornMP14,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage14,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage14,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction14,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate14,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate14,
                        [Stat.Accuracy] = Settings.RebornAccuracy14,
                        [Stat.Agility] = Settings.RebornAgility14,
                        [Stat.Freezing] = Settings.RebornFreezing14,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack14,
                        [Stat.MagicResist] = Settings.RebornMagicResist14,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist14,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery14,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery14,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery14,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate14,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage14,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate14,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate14,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate14,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate14,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate14,
                        [Stat.HPRatePercent] = Settings.RebornHPRate14,
                        [Stat.MPRatePercent] = Settings.RebornMPRate14,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain14,
                    };

                    int tempAttr14 = Settings.RebornAttribute14;
                    if (tempAttr14 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr14 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr14);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn14, this, 0, Reborn14);
                    break;
                case 15:
                    var Reborn15 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC15,
                        [Stat.MaxAC] = Settings.RebornMaxAC15,
                        [Stat.MinMAC] = Settings.RebornMinMAC15,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC15,
                        [Stat.MinDC] = Settings.RebornMinDC15,
                        [Stat.MaxDC] = Settings.RebornMaxDC15,
                        [Stat.MinMC] = Settings.RebornMinMC15,
                        [Stat.MaxMC] = Settings.RebornMaxMC15,
                        [Stat.MinSC] = Settings.RebornMinSC15,
                        [Stat.MaxSC] = Settings.RebornMaxSC15,
                        [Stat.HP] = Settings.RebornHP15,
                        [Stat.MP] = Settings.RebornMP15,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage15,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage15,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction15,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate15,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate15,
                        [Stat.Accuracy] = Settings.RebornAccuracy15,
                        [Stat.Agility] = Settings.RebornAgility15,
                        [Stat.Freezing] = Settings.RebornFreezing15,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack15,
                        [Stat.MagicResist] = Settings.RebornMagicResist15,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist15,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery15,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery15,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery15,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate15,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage15,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate15,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate15,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate15,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate15,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate15,
                        [Stat.HPRatePercent] = Settings.RebornHPRate15,
                        [Stat.MPRatePercent] = Settings.RebornMPRate15,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain15,
                    };

                    int tempAttr15 = Settings.RebornAttribute15;
                    if (tempAttr15 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr15 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr15);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn15, this, 0, Reborn15);
                    break;
                case 16:
                    var Reborn16 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC16,
                        [Stat.MaxAC] = Settings.RebornMaxAC16,
                        [Stat.MinMAC] = Settings.RebornMinMAC16,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC16,
                        [Stat.MinDC] = Settings.RebornMinDC16,
                        [Stat.MaxDC] = Settings.RebornMaxDC16,
                        [Stat.MinMC] = Settings.RebornMinMC16,
                        [Stat.MaxMC] = Settings.RebornMaxMC16,
                        [Stat.MinSC] = Settings.RebornMinSC16,
                        [Stat.MaxSC] = Settings.RebornMaxSC16,
                        [Stat.HP] = Settings.RebornHP16,
                        [Stat.MP] = Settings.RebornMP16,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage16,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage16,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction16,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate16,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate16,
                        [Stat.Accuracy] = Settings.RebornAccuracy16,
                        [Stat.Agility] = Settings.RebornAgility16,
                        [Stat.Freezing] = Settings.RebornFreezing16,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack16,
                        [Stat.MagicResist] = Settings.RebornMagicResist16,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist16,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery16,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery16,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery16,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate16,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage16,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate16,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate16,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate16,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate16,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate16,
                        [Stat.HPRatePercent] = Settings.RebornHPRate16,
                        [Stat.MPRatePercent] = Settings.RebornMPRate16,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain16,
                    };

                    int tempAttr16 = Settings.RebornAttribute16;
                    if (tempAttr16 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr16 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr16);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn16, this, 0, Reborn16);
                    break;
                case 17:
                    var Reborn17 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC17,
                        [Stat.MaxAC] = Settings.RebornMaxAC17,
                        [Stat.MinMAC] = Settings.RebornMinMAC17,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC17,
                        [Stat.MinDC] = Settings.RebornMinDC17,
                        [Stat.MaxDC] = Settings.RebornMaxDC17,
                        [Stat.MinMC] = Settings.RebornMinMC17,
                        [Stat.MaxMC] = Settings.RebornMaxMC17,
                        [Stat.MinSC] = Settings.RebornMinSC17,
                        [Stat.MaxSC] = Settings.RebornMaxSC17,
                        [Stat.HP] = Settings.RebornHP17,
                        [Stat.MP] = Settings.RebornMP17,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage17,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage17,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction17,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate17,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate17,
                        [Stat.Accuracy] = Settings.RebornAccuracy17,
                        [Stat.Agility] = Settings.RebornAgility17,
                        [Stat.Freezing] = Settings.RebornFreezing17,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack17,
                        [Stat.MagicResist] = Settings.RebornMagicResist17,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist17,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery17,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery17,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery17,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate17,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage17,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate17,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate17,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate17,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate17,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate17,
                        [Stat.HPRatePercent] = Settings.RebornHPRate17,
                        [Stat.MPRatePercent] = Settings.RebornMPRate17,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain17,
                    };

                    int tempAttr17 = Settings.RebornAttribute17;
                    if (tempAttr17 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr17 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr17);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn17, this, 0, Reborn17);
                    break;
                case 18:
                    var Reborn18 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC18,
                        [Stat.MaxAC] = Settings.RebornMaxAC18,
                        [Stat.MinMAC] = Settings.RebornMinMAC18,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC18,
                        [Stat.MinDC] = Settings.RebornMinDC18,
                        [Stat.MaxDC] = Settings.RebornMaxDC18,
                        [Stat.MinMC] = Settings.RebornMinMC18,
                        [Stat.MaxMC] = Settings.RebornMaxMC18,
                        [Stat.MinSC] = Settings.RebornMinSC18,
                        [Stat.MaxSC] = Settings.RebornMaxSC18,
                        [Stat.HP] = Settings.RebornHP18,
                        [Stat.MP] = Settings.RebornMP18,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage18,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage18,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction18,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate18,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate18,
                        [Stat.Accuracy] = Settings.RebornAccuracy18,
                        [Stat.Agility] = Settings.RebornAgility18,
                        [Stat.Freezing] = Settings.RebornFreezing18,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack18,
                        [Stat.MagicResist] = Settings.RebornMagicResist18,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist18,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery18,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery18,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery18,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate18,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage18,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate18,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate18,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate18,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate18,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate18,
                        [Stat.HPRatePercent] = Settings.RebornHPRate18,
                        [Stat.MPRatePercent] = Settings.RebornMPRate18,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain18,
                    };

                    int tempAttr18 = Settings.RebornAttribute18;
                    if (tempAttr18 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr18 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr18);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn18, this, 0, Reborn18);
                    break;
                case 19:
                    var Reborn19 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC19,
                        [Stat.MaxAC] = Settings.RebornMaxAC19,
                        [Stat.MinMAC] = Settings.RebornMinMAC19,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC19,
                        [Stat.MinDC] = Settings.RebornMinDC19,
                        [Stat.MaxDC] = Settings.RebornMaxDC19,
                        [Stat.MinMC] = Settings.RebornMinMC19,
                        [Stat.MaxMC] = Settings.RebornMaxMC19,
                        [Stat.MinSC] = Settings.RebornMinSC19,
                        [Stat.MaxSC] = Settings.RebornMaxSC19,
                        [Stat.HP] = Settings.RebornHP19,
                        [Stat.MP] = Settings.RebornMP19,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage19,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage19,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction19,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate19,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate19,
                        [Stat.Accuracy] = Settings.RebornAccuracy19,
                        [Stat.Agility] = Settings.RebornAgility19,
                        [Stat.Freezing] = Settings.RebornFreezing19,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack19,
                        [Stat.MagicResist] = Settings.RebornMagicResist19,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist19,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery19,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery19,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery19,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate19,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage19,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate19,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate19,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate19,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate19,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate19,
                        [Stat.HPRatePercent] = Settings.RebornHPRate19,
                        [Stat.MPRatePercent] = Settings.RebornMPRate19,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain19,
                    };

                    int tempAttr19 = Settings.RebornAttribute19;
                    if (tempAttr19 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr19 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr19);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn19, this, 0, Reborn19);
                    break;
                case 20:
                    var Reborn20 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC20,
                        [Stat.MaxAC] = Settings.RebornMaxAC20,
                        [Stat.MinMAC] = Settings.RebornMinMAC20,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC20,
                        [Stat.MinDC] = Settings.RebornMinDC20,
                        [Stat.MaxDC] = Settings.RebornMaxDC20,
                        [Stat.MinMC] = Settings.RebornMinMC20,
                        [Stat.MaxMC] = Settings.RebornMaxMC20,
                        [Stat.MinSC] = Settings.RebornMinSC20,
                        [Stat.MaxSC] = Settings.RebornMaxSC20,
                        [Stat.HP] = Settings.RebornHP20,
                        [Stat.MP] = Settings.RebornMP20,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage20,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage20,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction20,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate20,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate20,
                        [Stat.Accuracy] = Settings.RebornAccuracy20,
                        [Stat.Agility] = Settings.RebornAgility20,
                        [Stat.Freezing] = Settings.RebornFreezing20,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack20,
                        [Stat.MagicResist] = Settings.RebornMagicResist20,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist20,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery20,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery20,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery20,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate20,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage20,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate20,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate20,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate20,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate20,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate20,
                        [Stat.HPRatePercent] = Settings.RebornHPRate20,
                        [Stat.MPRatePercent] = Settings.RebornMPRate20,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain20,
                    };

                    int tempAttr20 = Settings.RebornAttribute20;
                    if (tempAttr20 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr20 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr20);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn20, this, 0, Reborn20);
                    break;
                case 21:
                    var Reborn21 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC21,
                        [Stat.MaxAC] = Settings.RebornMaxAC21,
                        [Stat.MinMAC] = Settings.RebornMinMAC21,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC21,
                        [Stat.MinDC] = Settings.RebornMinDC21,
                        [Stat.MaxDC] = Settings.RebornMaxDC21,
                        [Stat.MinMC] = Settings.RebornMinMC21,
                        [Stat.MaxMC] = Settings.RebornMaxMC21,
                        [Stat.MinSC] = Settings.RebornMinSC21,
                        [Stat.MaxSC] = Settings.RebornMaxSC21,
                        [Stat.HP] = Settings.RebornHP21,
                        [Stat.MP] = Settings.RebornMP21,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage21,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage21,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction21,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate21,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate21,
                        [Stat.Accuracy] = Settings.RebornAccuracy21,
                        [Stat.Agility] = Settings.RebornAgility21,
                        [Stat.Freezing] = Settings.RebornFreezing21,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack21,
                        [Stat.MagicResist] = Settings.RebornMagicResist21,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist21,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery21,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery21,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery21,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate21,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage21,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate21,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate21,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate21,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate21,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate21,
                        [Stat.HPRatePercent] = Settings.RebornHPRate21,
                        [Stat.MPRatePercent] = Settings.RebornMPRate21,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain21,
                    };

                    int tempAttr21 = Settings.RebornAttribute21;
                    if (tempAttr21 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr21 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr21);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn21, this, 0, Reborn21);
                    break;
                case 22:
                    var Reborn22 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC22,
                        [Stat.MaxAC] = Settings.RebornMaxAC22,
                        [Stat.MinMAC] = Settings.RebornMinMAC22,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC22,
                        [Stat.MinDC] = Settings.RebornMinDC22,
                        [Stat.MaxDC] = Settings.RebornMaxDC22,
                        [Stat.MinMC] = Settings.RebornMinMC22,
                        [Stat.MaxMC] = Settings.RebornMaxMC22,
                        [Stat.MinSC] = Settings.RebornMinSC22,
                        [Stat.MaxSC] = Settings.RebornMaxSC22,
                        [Stat.HP] = Settings.RebornHP22,
                        [Stat.MP] = Settings.RebornMP22,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage22,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage22,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction22,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate22,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate22,
                        [Stat.Accuracy] = Settings.RebornAccuracy22,
                        [Stat.Agility] = Settings.RebornAgility22,
                        [Stat.Freezing] = Settings.RebornFreezing22,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack22,
                        [Stat.MagicResist] = Settings.RebornMagicResist22,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist22,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery22,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery22,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery22,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate22,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage22,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate22,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate22,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate22,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate22,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate22,
                        [Stat.HPRatePercent] = Settings.RebornHPRate22,
                        [Stat.MPRatePercent] = Settings.RebornMPRate22,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain22,
                    };

                    int tempAttr22 = Settings.RebornAttribute22;
                    if (tempAttr22 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr22 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr22);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn22, this, 0, Reborn22);
                    break;
                case 23:
                    var Reborn23 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC23,
                        [Stat.MaxAC] = Settings.RebornMaxAC23,
                        [Stat.MinMAC] = Settings.RebornMinMAC23,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC23,
                        [Stat.MinDC] = Settings.RebornMinDC23,
                        [Stat.MaxDC] = Settings.RebornMaxDC23,
                        [Stat.MinMC] = Settings.RebornMinMC23,
                        [Stat.MaxMC] = Settings.RebornMaxMC23,
                        [Stat.MinSC] = Settings.RebornMinSC23,
                        [Stat.MaxSC] = Settings.RebornMaxSC23,
                        [Stat.HP] = Settings.RebornHP23,
                        [Stat.MP] = Settings.RebornMP23,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage23,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage23,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction23,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate23,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate23,
                        [Stat.Accuracy] = Settings.RebornAccuracy23,
                        [Stat.Agility] = Settings.RebornAgility23,
                        [Stat.Freezing] = Settings.RebornFreezing23,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack23,
                        [Stat.MagicResist] = Settings.RebornMagicResist23,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist23,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery23,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery23,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery23,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate23,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage23,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate23,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate23,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate23,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate23,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate23,
                        [Stat.HPRatePercent] = Settings.RebornHPRate23,
                        [Stat.MPRatePercent] = Settings.RebornMPRate23,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain23,
                    };

                    int tempAttr23 = Settings.RebornAttribute23;
                    if (tempAttr23 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr23 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr23);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn23, this, 0, Reborn23);
                    break;
                case 24:
                    var Reborn24 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC24,
                        [Stat.MaxAC] = Settings.RebornMaxAC24,
                        [Stat.MinMAC] = Settings.RebornMinMAC24,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC24,
                        [Stat.MinDC] = Settings.RebornMinDC24,
                        [Stat.MaxDC] = Settings.RebornMaxDC24,
                        [Stat.MinMC] = Settings.RebornMinMC24,
                        [Stat.MaxMC] = Settings.RebornMaxMC24,
                        [Stat.MinSC] = Settings.RebornMinSC24,
                        [Stat.MaxSC] = Settings.RebornMaxSC24,
                        [Stat.HP] = Settings.RebornHP24,
                        [Stat.MP] = Settings.RebornMP24,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage24,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage24,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction24,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate24,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate24,
                        [Stat.Accuracy] = Settings.RebornAccuracy24,
                        [Stat.Agility] = Settings.RebornAgility24,
                        [Stat.Freezing] = Settings.RebornFreezing24,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack24,
                        [Stat.MagicResist] = Settings.RebornMagicResist24,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist24,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery24,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery24,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery24,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate24,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage24,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate24,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate24,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate24,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate24,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate24,
                        [Stat.HPRatePercent] = Settings.RebornHPRate24,
                        [Stat.MPRatePercent] = Settings.RebornMPRate24,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain24,
                    };

                    int tempAttr24 = Settings.RebornAttribute24;
                    if (tempAttr24 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr24 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr24);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn24, this, 0, Reborn24);
                    break;
                case 25:
                    var Reborn25 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC25,
                        [Stat.MaxAC] = Settings.RebornMaxAC25,
                        [Stat.MinMAC] = Settings.RebornMinMAC25,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC25,
                        [Stat.MinDC] = Settings.RebornMinDC25,
                        [Stat.MaxDC] = Settings.RebornMaxDC25,
                        [Stat.MinMC] = Settings.RebornMinMC25,
                        [Stat.MaxMC] = Settings.RebornMaxMC25,
                        [Stat.MinSC] = Settings.RebornMinSC25,
                        [Stat.MaxSC] = Settings.RebornMaxSC25,
                        [Stat.HP] = Settings.RebornHP25,
                        [Stat.MP] = Settings.RebornMP25,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage25,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage25,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction25,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate25,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate25,
                        [Stat.Accuracy] = Settings.RebornAccuracy25,
                        [Stat.Agility] = Settings.RebornAgility25,
                        [Stat.Freezing] = Settings.RebornFreezing25,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack25,
                        [Stat.MagicResist] = Settings.RebornMagicResist25,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist25,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery25,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery25,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery25,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate25,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage25,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate25,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate25,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate25,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate25,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate25,
                        [Stat.HPRatePercent] = Settings.RebornHPRate25,
                        [Stat.MPRatePercent] = Settings.RebornMPRate25,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain25,
                    };

                    int tempAttr25 = Settings.RebornAttribute25;
                    if (tempAttr25 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr25 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr25);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn25, this, 0, Reborn25);
                    break;
                case 26:
                    var Reborn26 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC26,
                        [Stat.MaxAC] = Settings.RebornMaxAC26,
                        [Stat.MinMAC] = Settings.RebornMinMAC26,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC26,
                        [Stat.MinDC] = Settings.RebornMinDC26,
                        [Stat.MaxDC] = Settings.RebornMaxDC26,
                        [Stat.MinMC] = Settings.RebornMinMC26,
                        [Stat.MaxMC] = Settings.RebornMaxMC26,
                        [Stat.MinSC] = Settings.RebornMinSC26,
                        [Stat.MaxSC] = Settings.RebornMaxSC26,
                        [Stat.HP] = Settings.RebornHP26,
                        [Stat.MP] = Settings.RebornMP26,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage26,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage26,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction26,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate26,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate26,
                        [Stat.Accuracy] = Settings.RebornAccuracy26,
                        [Stat.Agility] = Settings.RebornAgility26,
                        [Stat.Freezing] = Settings.RebornFreezing26,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack26,
                        [Stat.MagicResist] = Settings.RebornMagicResist26,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist26,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery26,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery26,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery26,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate26,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage26,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate26,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate26,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate26,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate26,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate26,
                        [Stat.HPRatePercent] = Settings.RebornHPRate26,
                        [Stat.MPRatePercent] = Settings.RebornMPRate26,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain26,
                    };

                    int tempAttr26 = Settings.RebornAttribute26;
                    if (tempAttr26 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr26 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr26);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn26, this, 0, Reborn26);
                    break;
                case 27:
                    var Reborn27 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC27,
                        [Stat.MaxAC] = Settings.RebornMaxAC27,
                        [Stat.MinMAC] = Settings.RebornMinMAC27,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC27,
                        [Stat.MinDC] = Settings.RebornMinDC27,
                        [Stat.MaxDC] = Settings.RebornMaxDC27,
                        [Stat.MinMC] = Settings.RebornMinMC27,
                        [Stat.MaxMC] = Settings.RebornMaxMC27,
                        [Stat.MinSC] = Settings.RebornMinSC27,
                        [Stat.MaxSC] = Settings.RebornMaxSC27,
                        [Stat.HP] = Settings.RebornHP27,
                        [Stat.MP] = Settings.RebornMP27,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage27,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage27,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction27,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate27,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate27,
                        [Stat.Accuracy] = Settings.RebornAccuracy27,
                        [Stat.Agility] = Settings.RebornAgility27,
                        [Stat.Freezing] = Settings.RebornFreezing27,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack27,
                        [Stat.MagicResist] = Settings.RebornMagicResist27,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist27,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery27,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery27,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery27,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate27,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage27,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate27,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate27,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate27,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate27,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate27,
                        [Stat.HPRatePercent] = Settings.RebornHPRate27,
                        [Stat.MPRatePercent] = Settings.RebornMPRate27,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain27,
                    };

                    int tempAttr27 = Settings.RebornAttribute27;
                    if (tempAttr27 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr27 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr27);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn27, this, 0, Reborn27);
                    break;
                case 28:
                    var Reborn28 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC28,
                        [Stat.MaxAC] = Settings.RebornMaxAC28,
                        [Stat.MinMAC] = Settings.RebornMinMAC28,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC28,
                        [Stat.MinDC] = Settings.RebornMinDC28,
                        [Stat.MaxDC] = Settings.RebornMaxDC28,
                        [Stat.MinMC] = Settings.RebornMinMC28,
                        [Stat.MaxMC] = Settings.RebornMaxMC28,
                        [Stat.MinSC] = Settings.RebornMinSC28,
                        [Stat.MaxSC] = Settings.RebornMaxSC28,
                        [Stat.HP] = Settings.RebornHP28,
                        [Stat.MP] = Settings.RebornMP28,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage28,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage28,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction28,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate28,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate28,
                        [Stat.Accuracy] = Settings.RebornAccuracy28,
                        [Stat.Agility] = Settings.RebornAgility28,
                        [Stat.Freezing] = Settings.RebornFreezing28,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack28,
                        [Stat.MagicResist] = Settings.RebornMagicResist28,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist28,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery28,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery28,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery28,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate28,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage28,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate28,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate28,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate28,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate28,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate28,
                        [Stat.HPRatePercent] = Settings.RebornHPRate28,
                        [Stat.MPRatePercent] = Settings.RebornMPRate28,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain28,
                    };

                    int tempAttr28 = Settings.RebornAttribute28;
                    if (tempAttr28 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr28 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr28);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn28, this, 0, Reborn28);
                    break;
                case 29:
                    var Reborn29 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC29,
                        [Stat.MaxAC] = Settings.RebornMaxAC29,
                        [Stat.MinMAC] = Settings.RebornMinMAC29,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC29,
                        [Stat.MinDC] = Settings.RebornMinDC29,
                        [Stat.MaxDC] = Settings.RebornMaxDC29,
                        [Stat.MinMC] = Settings.RebornMinMC29,
                        [Stat.MaxMC] = Settings.RebornMaxMC29,
                        [Stat.MinSC] = Settings.RebornMinSC29,
                        [Stat.MaxSC] = Settings.RebornMaxSC29,
                        [Stat.HP] = Settings.RebornHP29,
                        [Stat.MP] = Settings.RebornMP29,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage29,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage29,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction29,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate29,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate29,
                        [Stat.Accuracy] = Settings.RebornAccuracy29,
                        [Stat.Agility] = Settings.RebornAgility29,
                        [Stat.Freezing] = Settings.RebornFreezing29,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack29,
                        [Stat.MagicResist] = Settings.RebornMagicResist29,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist29,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery29,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery29,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery29,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate29,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage29,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate29,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate29,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate29,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate29,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate29,
                        [Stat.HPRatePercent] = Settings.RebornHPRate29,
                        [Stat.MPRatePercent] = Settings.RebornMPRate29,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain29,
                    };

                    int tempAttr29 = Settings.RebornAttribute29;
                    if (tempAttr29 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr29 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr29);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn29, this, 0, Reborn29);
                    break;
                case 30:
                    var Reborn30 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC30,
                        [Stat.MaxAC] = Settings.RebornMaxAC30,
                        [Stat.MinMAC] = Settings.RebornMinMAC30,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC30,
                        [Stat.MinDC] = Settings.RebornMinDC30,
                        [Stat.MaxDC] = Settings.RebornMaxDC30,
                        [Stat.MinMC] = Settings.RebornMinMC30,
                        [Stat.MaxMC] = Settings.RebornMaxMC30,
                        [Stat.MinSC] = Settings.RebornMinSC30,
                        [Stat.MaxSC] = Settings.RebornMaxSC30,
                        [Stat.HP] = Settings.RebornHP30,
                        [Stat.MP] = Settings.RebornMP30,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage30,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage30,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction30,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate30,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate30,
                        [Stat.Accuracy] = Settings.RebornAccuracy30,
                        [Stat.Agility] = Settings.RebornAgility30,
                        [Stat.Freezing] = Settings.RebornFreezing30,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack30,
                        [Stat.MagicResist] = Settings.RebornMagicResist30,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist30,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery30,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery30,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery30,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate30,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage30,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate30,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate30,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate30,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate30,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate30,
                        [Stat.HPRatePercent] = Settings.RebornHPRate30,
                        [Stat.MPRatePercent] = Settings.RebornMPRate30,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain30,
                    };

                    int tempAttr30 = Settings.RebornAttribute30;
                    if (tempAttr30 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr30 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr30);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn30, this, 0, Reborn30);
                    break;
                case 31:
                    var Reborn31 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC31,
                        [Stat.MaxAC] = Settings.RebornMaxAC31,
                        [Stat.MinMAC] = Settings.RebornMinMAC31,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC31,
                        [Stat.MinDC] = Settings.RebornMinDC31,
                        [Stat.MaxDC] = Settings.RebornMaxDC31,
                        [Stat.MinMC] = Settings.RebornMinMC31,
                        [Stat.MaxMC] = Settings.RebornMaxMC31,
                        [Stat.MinSC] = Settings.RebornMinSC31,
                        [Stat.MaxSC] = Settings.RebornMaxSC31,
                        [Stat.HP] = Settings.RebornHP31,
                        [Stat.MP] = Settings.RebornMP31,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage31,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage31,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction31,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate31,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate31,
                        [Stat.Accuracy] = Settings.RebornAccuracy31,
                        [Stat.Agility] = Settings.RebornAgility31,
                        [Stat.Freezing] = Settings.RebornFreezing31,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack31,
                        [Stat.MagicResist] = Settings.RebornMagicResist31,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist31,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery31,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery31,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery31,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate31,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage31,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate31,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate31,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate31,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate31,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate31,
                        [Stat.HPRatePercent] = Settings.RebornHPRate31,
                        [Stat.MPRatePercent] = Settings.RebornMPRate31,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain31,
                    };

                    int tempAttr31 = Settings.RebornAttribute31;
                    if (tempAttr31 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr31 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr31);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn31, this, 0, Reborn31);
                    break;
                case 32:
                    var Reborn32 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC32,
                        [Stat.MaxAC] = Settings.RebornMaxAC32,
                        [Stat.MinMAC] = Settings.RebornMinMAC32,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC32,
                        [Stat.MinDC] = Settings.RebornMinDC32,
                        [Stat.MaxDC] = Settings.RebornMaxDC32,
                        [Stat.MinMC] = Settings.RebornMinMC32,
                        [Stat.MaxMC] = Settings.RebornMaxMC32,
                        [Stat.MinSC] = Settings.RebornMinSC32,
                        [Stat.MaxSC] = Settings.RebornMaxSC32,
                        [Stat.HP] = Settings.RebornHP32,
                        [Stat.MP] = Settings.RebornMP32,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage32,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage32,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction32,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate32,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate32,
                        [Stat.Accuracy] = Settings.RebornAccuracy32,
                        [Stat.Agility] = Settings.RebornAgility32,
                        [Stat.Freezing] = Settings.RebornFreezing32,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack32,
                        [Stat.MagicResist] = Settings.RebornMagicResist32,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist32,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery32,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery32,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery32,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate32,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage32,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate32,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate32,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate32,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate32,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate32,
                        [Stat.HPRatePercent] = Settings.RebornHPRate32,
                        [Stat.MPRatePercent] = Settings.RebornMPRate32,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain32,
                    };

                    int tempAttr32 = Settings.RebornAttribute32;
                    if (tempAttr32 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr32 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr32);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn32, this, 0, Reborn32);
                    break;
                case 33:
                    var Reborn33 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC33,
                        [Stat.MaxAC] = Settings.RebornMaxAC33,
                        [Stat.MinMAC] = Settings.RebornMinMAC33,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC33,
                        [Stat.MinDC] = Settings.RebornMinDC33,
                        [Stat.MaxDC] = Settings.RebornMaxDC33,
                        [Stat.MinMC] = Settings.RebornMinMC33,
                        [Stat.MaxMC] = Settings.RebornMaxMC33,
                        [Stat.MinSC] = Settings.RebornMinSC33,
                        [Stat.MaxSC] = Settings.RebornMaxSC33,
                        [Stat.HP] = Settings.RebornHP33,
                        [Stat.MP] = Settings.RebornMP33,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage33,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage33,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction33,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate33,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate33,
                        [Stat.Accuracy] = Settings.RebornAccuracy33,
                        [Stat.Agility] = Settings.RebornAgility33,
                        [Stat.Freezing] = Settings.RebornFreezing33,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack33,
                        [Stat.MagicResist] = Settings.RebornMagicResist33,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist33,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery33,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery33,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery33,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate33,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage33,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate33,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate33,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate33,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate33,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate33,
                        [Stat.HPRatePercent] = Settings.RebornHPRate33,
                        [Stat.MPRatePercent] = Settings.RebornMPRate33,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain33,
                    };

                    int tempAttr33 = Settings.RebornAttribute33;
                    if (tempAttr33 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr33 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr33);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn33, this, 0, Reborn33);
                    break;
                case 34:
                    var Reborn34 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC34,
                        [Stat.MaxAC] = Settings.RebornMaxAC34,
                        [Stat.MinMAC] = Settings.RebornMinMAC34,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC34,
                        [Stat.MinDC] = Settings.RebornMinDC34,
                        [Stat.MaxDC] = Settings.RebornMaxDC34,
                        [Stat.MinMC] = Settings.RebornMinMC34,
                        [Stat.MaxMC] = Settings.RebornMaxMC34,
                        [Stat.MinSC] = Settings.RebornMinSC34,
                        [Stat.MaxSC] = Settings.RebornMaxSC34,
                        [Stat.HP] = Settings.RebornHP34,
                        [Stat.MP] = Settings.RebornMP34,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage34,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage34,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction34,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate34,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate34,
                        [Stat.Accuracy] = Settings.RebornAccuracy34,
                        [Stat.Agility] = Settings.RebornAgility34,
                        [Stat.Freezing] = Settings.RebornFreezing34,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack34,
                        [Stat.MagicResist] = Settings.RebornMagicResist34,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist34,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery34,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery34,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery34,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate34,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage34,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate34,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate34,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate34,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate34,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate34,
                        [Stat.HPRatePercent] = Settings.RebornHPRate34,
                        [Stat.MPRatePercent] = Settings.RebornMPRate34,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain34,
                    };

                    int tempAttr34 = Settings.RebornAttribute34;
                    if (tempAttr34 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr34 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr34);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn34, this, 0, Reborn34);
                    break;
                case 35:
                    var Reborn35 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC35,
                        [Stat.MaxAC] = Settings.RebornMaxAC35,
                        [Stat.MinMAC] = Settings.RebornMinMAC35,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC35,
                        [Stat.MinDC] = Settings.RebornMinDC35,
                        [Stat.MaxDC] = Settings.RebornMaxDC35,
                        [Stat.MinMC] = Settings.RebornMinMC35,
                        [Stat.MaxMC] = Settings.RebornMaxMC35,
                        [Stat.MinSC] = Settings.RebornMinSC35,
                        [Stat.MaxSC] = Settings.RebornMaxSC35,
                        [Stat.HP] = Settings.RebornHP35,
                        [Stat.MP] = Settings.RebornMP35,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage35,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage35,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction35,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate35,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate35,
                        [Stat.Accuracy] = Settings.RebornAccuracy35,
                        [Stat.Agility] = Settings.RebornAgility35,
                        [Stat.Freezing] = Settings.RebornFreezing35,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack35,
                        [Stat.MagicResist] = Settings.RebornMagicResist35,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist35,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery35,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery35,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery35,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate35,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage35,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate35,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate35,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate35,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate35,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate35,
                        [Stat.HPRatePercent] = Settings.RebornHPRate35,
                        [Stat.MPRatePercent] = Settings.RebornMPRate35,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain35,
                    };

                    int tempAttr35 = Settings.RebornAttribute35;
                    if (tempAttr35 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr35 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr35);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn35, this, 0, Reborn35);
                    break;
                case 36:
                    var Reborn36 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC36,
                        [Stat.MaxAC] = Settings.RebornMaxAC36,
                        [Stat.MinMAC] = Settings.RebornMinMAC36,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC36,
                        [Stat.MinDC] = Settings.RebornMinDC36,
                        [Stat.MaxDC] = Settings.RebornMaxDC36,
                        [Stat.MinMC] = Settings.RebornMinMC36,
                        [Stat.MaxMC] = Settings.RebornMaxMC36,
                        [Stat.MinSC] = Settings.RebornMinSC36,
                        [Stat.MaxSC] = Settings.RebornMaxSC36,
                        [Stat.HP] = Settings.RebornHP36,
                        [Stat.MP] = Settings.RebornMP36,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage36,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage36,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction36,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate36,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate36,
                        [Stat.Accuracy] = Settings.RebornAccuracy36,
                        [Stat.Agility] = Settings.RebornAgility36,
                        [Stat.Freezing] = Settings.RebornFreezing36,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack36,
                        [Stat.MagicResist] = Settings.RebornMagicResist36,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist36,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery36,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery36,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery36,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate36,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage36,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate36,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate36,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate36,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate36,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate36,
                        [Stat.HPRatePercent] = Settings.RebornHPRate36,
                        [Stat.MPRatePercent] = Settings.RebornMPRate36,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain36,
                    };

                    int tempAttr36 = Settings.RebornAttribute36;
                    if (tempAttr36 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr36 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr36);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn36, this, 0, Reborn36);
                    break;
                case 37:
                    var Reborn37 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC37,
                        [Stat.MaxAC] = Settings.RebornMaxAC37,
                        [Stat.MinMAC] = Settings.RebornMinMAC37,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC37,
                        [Stat.MinDC] = Settings.RebornMinDC37,
                        [Stat.MaxDC] = Settings.RebornMaxDC37,
                        [Stat.MinMC] = Settings.RebornMinMC37,
                        [Stat.MaxMC] = Settings.RebornMaxMC37,
                        [Stat.MinSC] = Settings.RebornMinSC37,
                        [Stat.MaxSC] = Settings.RebornMaxSC37,
                        [Stat.HP] = Settings.RebornHP37,
                        [Stat.MP] = Settings.RebornMP37,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage37,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage37,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction37,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate37,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate37,
                        [Stat.Accuracy] = Settings.RebornAccuracy37,
                        [Stat.Agility] = Settings.RebornAgility37,
                        [Stat.Freezing] = Settings.RebornFreezing37,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack37,
                        [Stat.MagicResist] = Settings.RebornMagicResist37,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist37,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery37,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery37,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery37,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate37,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage37,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate37,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate37,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate37,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate37,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate37,
                        [Stat.HPRatePercent] = Settings.RebornHPRate37,
                        [Stat.MPRatePercent] = Settings.RebornMPRate37,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain37,
                    };

                    int tempAttr37 = Settings.RebornAttribute37;
                    if (tempAttr37 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr37 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr37);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn37, this, 0, Reborn37);
                    break;
                case 38:
                    var Reborn38 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC38,
                        [Stat.MaxAC] = Settings.RebornMaxAC38,
                        [Stat.MinMAC] = Settings.RebornMinMAC38,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC38,
                        [Stat.MinDC] = Settings.RebornMinDC38,
                        [Stat.MaxDC] = Settings.RebornMaxDC38,
                        [Stat.MinMC] = Settings.RebornMinMC38,
                        [Stat.MaxMC] = Settings.RebornMaxMC38,
                        [Stat.MinSC] = Settings.RebornMinSC38,
                        [Stat.MaxSC] = Settings.RebornMaxSC38,
                        [Stat.HP] = Settings.RebornHP38,
                        [Stat.MP] = Settings.RebornMP38,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage38,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage38,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction38,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate38,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate38,
                        [Stat.Accuracy] = Settings.RebornAccuracy38,
                        [Stat.Agility] = Settings.RebornAgility38,
                        [Stat.Freezing] = Settings.RebornFreezing38,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack38,
                        [Stat.MagicResist] = Settings.RebornMagicResist38,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist38,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery38,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery38,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery38,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate38,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage38,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate38,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate38,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate38,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate38,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate38,
                        [Stat.HPRatePercent] = Settings.RebornHPRate38,
                        [Stat.MPRatePercent] = Settings.RebornMPRate38,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain38,
                    };

                    int tempAttr38 = Settings.RebornAttribute38;
                    if (tempAttr38 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr38 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr38);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn38, this, 0, Reborn38);
                    break;
                case 39:
                    var Reborn39 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC39,
                        [Stat.MaxAC] = Settings.RebornMaxAC39,
                        [Stat.MinMAC] = Settings.RebornMinMAC39,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC39,
                        [Stat.MinDC] = Settings.RebornMinDC39,
                        [Stat.MaxDC] = Settings.RebornMaxDC39,
                        [Stat.MinMC] = Settings.RebornMinMC39,
                        [Stat.MaxMC] = Settings.RebornMaxMC39,
                        [Stat.MinSC] = Settings.RebornMinSC39,
                        [Stat.MaxSC] = Settings.RebornMaxSC39,
                        [Stat.HP] = Settings.RebornHP39,
                        [Stat.MP] = Settings.RebornMP39,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage39,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage39,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction39,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate39,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate39,
                        [Stat.Accuracy] = Settings.RebornAccuracy39,
                        [Stat.Agility] = Settings.RebornAgility39,
                        [Stat.Freezing] = Settings.RebornFreezing39,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack39,
                        [Stat.MagicResist] = Settings.RebornMagicResist39,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist39,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery39,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery39,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery39,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate39,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage39,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate39,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate39,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate39,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate39,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate39,
                        [Stat.HPRatePercent] = Settings.RebornHPRate39,
                        [Stat.MPRatePercent] = Settings.RebornMPRate39,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain39,
                    };

                    int tempAttr39 = Settings.RebornAttribute39;
                    if (tempAttr39 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr39 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr39);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn39, this, 0, Reborn39);
                    break;
                case 40:
                    var Reborn40 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC40,
                        [Stat.MaxAC] = Settings.RebornMaxAC40,
                        [Stat.MinMAC] = Settings.RebornMinMAC40,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC40,
                        [Stat.MinDC] = Settings.RebornMinDC40,
                        [Stat.MaxDC] = Settings.RebornMaxDC40,
                        [Stat.MinMC] = Settings.RebornMinMC40,
                        [Stat.MaxMC] = Settings.RebornMaxMC40,
                        [Stat.MinSC] = Settings.RebornMinSC40,
                        [Stat.MaxSC] = Settings.RebornMaxSC40,
                        [Stat.HP] = Settings.RebornHP40,
                        [Stat.MP] = Settings.RebornMP40,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage40,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage40,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction40,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate40,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate40,
                        [Stat.Accuracy] = Settings.RebornAccuracy40,
                        [Stat.Agility] = Settings.RebornAgility40,
                        [Stat.Freezing] = Settings.RebornFreezing40,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack40,
                        [Stat.MagicResist] = Settings.RebornMagicResist40,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist40,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery40,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery40,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery40,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate40,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage40,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate40,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate40,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate40,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate40,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate40,
                        [Stat.HPRatePercent] = Settings.RebornHPRate40,
                        [Stat.MPRatePercent] = Settings.RebornMPRate40,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain40,
                    };

                    int tempAttr40 = Settings.RebornAttribute40;
                    if (tempAttr40 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr40 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr40);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn40, this, 0, Reborn40);
                    break;
                case 41:
                    var Reborn41 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC41,
                        [Stat.MaxAC] = Settings.RebornMaxAC41,
                        [Stat.MinMAC] = Settings.RebornMinMAC41,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC41,
                        [Stat.MinDC] = Settings.RebornMinDC41,
                        [Stat.MaxDC] = Settings.RebornMaxDC41,
                        [Stat.MinMC] = Settings.RebornMinMC41,
                        [Stat.MaxMC] = Settings.RebornMaxMC41,
                        [Stat.MinSC] = Settings.RebornMinSC41,
                        [Stat.MaxSC] = Settings.RebornMaxSC41,
                        [Stat.HP] = Settings.RebornHP41,
                        [Stat.MP] = Settings.RebornMP41,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage41,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage41,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction41,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate41,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate41,
                        [Stat.Accuracy] = Settings.RebornAccuracy41,
                        [Stat.Agility] = Settings.RebornAgility41,
                        [Stat.Freezing] = Settings.RebornFreezing41,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack41,
                        [Stat.MagicResist] = Settings.RebornMagicResist41,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist41,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery41,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery41,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery41,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate41,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage41,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate41,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate41,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate41,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate41,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate41,
                        [Stat.HPRatePercent] = Settings.RebornHPRate41,
                        [Stat.MPRatePercent] = Settings.RebornMPRate41,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain41,
                    };

                    int tempAttr41 = Settings.RebornAttribute41;
                    if (tempAttr41 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr41 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr41);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn41, this, 0, Reborn41);
                    break;
                case 42:
                    var Reborn42 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC42,
                        [Stat.MaxAC] = Settings.RebornMaxAC42,
                        [Stat.MinMAC] = Settings.RebornMinMAC42,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC42,
                        [Stat.MinDC] = Settings.RebornMinDC42,
                        [Stat.MaxDC] = Settings.RebornMaxDC42,
                        [Stat.MinMC] = Settings.RebornMinMC42,
                        [Stat.MaxMC] = Settings.RebornMaxMC42,
                        [Stat.MinSC] = Settings.RebornMinSC42,
                        [Stat.MaxSC] = Settings.RebornMaxSC42,
                        [Stat.HP] = Settings.RebornHP42,
                        [Stat.MP] = Settings.RebornMP42,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage42,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage42,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction42,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate42,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate42,
                        [Stat.Accuracy] = Settings.RebornAccuracy42,
                        [Stat.Agility] = Settings.RebornAgility42,
                        [Stat.Freezing] = Settings.RebornFreezing42,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack42,
                        [Stat.MagicResist] = Settings.RebornMagicResist42,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist42,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery42,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery42,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery42,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate42,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage42,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate42,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate42,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate42,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate42,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate42,
                        [Stat.HPRatePercent] = Settings.RebornHPRate42,
                        [Stat.MPRatePercent] = Settings.RebornMPRate42,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain42,
                    };

                    int tempAttr42 = Settings.RebornAttribute42;
                    if (tempAttr42 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr42 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr42);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn42, this, 0, Reborn42);
                    break;
                case 43:
                    var Reborn43 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC43,
                        [Stat.MaxAC] = Settings.RebornMaxAC43,
                        [Stat.MinMAC] = Settings.RebornMinMAC43,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC43,
                        [Stat.MinDC] = Settings.RebornMinDC43,
                        [Stat.MaxDC] = Settings.RebornMaxDC43,
                        [Stat.MinMC] = Settings.RebornMinMC43,
                        [Stat.MaxMC] = Settings.RebornMaxMC43,
                        [Stat.MinSC] = Settings.RebornMinSC43,
                        [Stat.MaxSC] = Settings.RebornMaxSC43,
                        [Stat.HP] = Settings.RebornHP43,
                        [Stat.MP] = Settings.RebornMP43,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage43,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage43,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction43,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate43,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate43,
                        [Stat.Accuracy] = Settings.RebornAccuracy43,
                        [Stat.Agility] = Settings.RebornAgility43,
                        [Stat.Freezing] = Settings.RebornFreezing43,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack43,
                        [Stat.MagicResist] = Settings.RebornMagicResist43,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist43,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery43,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery43,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery43,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate43,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage43,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate43,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate43,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate43,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate43,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate43,
                        [Stat.HPRatePercent] = Settings.RebornHPRate43,
                        [Stat.MPRatePercent] = Settings.RebornMPRate43,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain43,
                    };

                    int tempAttr43 = Settings.RebornAttribute43;
                    if (tempAttr43 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr43 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr43);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn43, this, 0, Reborn43);
                    break;
                case 44:
                    var Reborn44 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC44,
                        [Stat.MaxAC] = Settings.RebornMaxAC44,
                        [Stat.MinMAC] = Settings.RebornMinMAC44,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC44,
                        [Stat.MinDC] = Settings.RebornMinDC44,
                        [Stat.MaxDC] = Settings.RebornMaxDC44,
                        [Stat.MinMC] = Settings.RebornMinMC44,
                        [Stat.MaxMC] = Settings.RebornMaxMC44,
                        [Stat.MinSC] = Settings.RebornMinSC44,
                        [Stat.MaxSC] = Settings.RebornMaxSC44,
                        [Stat.HP] = Settings.RebornHP44,
                        [Stat.MP] = Settings.RebornMP44,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage44,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage44,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction44,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate44,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate44,
                        [Stat.Accuracy] = Settings.RebornAccuracy44,
                        [Stat.Agility] = Settings.RebornAgility44,
                        [Stat.Freezing] = Settings.RebornFreezing44,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack44,
                        [Stat.MagicResist] = Settings.RebornMagicResist44,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist44,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery44,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery44,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery44,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate44,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage44,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate44,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate44,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate44,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate44,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate44,
                        [Stat.HPRatePercent] = Settings.RebornHPRate44,
                        [Stat.MPRatePercent] = Settings.RebornMPRate44,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain44,
                    };

                    int tempAttr44 = Settings.RebornAttribute44;
                    if (tempAttr44 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr44 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr44);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn44, this, 0, Reborn44);
                    break;
                case 45:
                    var Reborn45 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC45,
                        [Stat.MaxAC] = Settings.RebornMaxAC45,
                        [Stat.MinMAC] = Settings.RebornMinMAC45,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC45,
                        [Stat.MinDC] = Settings.RebornMinDC45,
                        [Stat.MaxDC] = Settings.RebornMaxDC45,
                        [Stat.MinMC] = Settings.RebornMinMC45,
                        [Stat.MaxMC] = Settings.RebornMaxMC45,
                        [Stat.MinSC] = Settings.RebornMinSC45,
                        [Stat.MaxSC] = Settings.RebornMaxSC45,
                        [Stat.HP] = Settings.RebornHP45,
                        [Stat.MP] = Settings.RebornMP45,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage45,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage45,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction45,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate45,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate45,
                        [Stat.Accuracy] = Settings.RebornAccuracy45,
                        [Stat.Agility] = Settings.RebornAgility45,
                        [Stat.Freezing] = Settings.RebornFreezing45,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack45,
                        [Stat.MagicResist] = Settings.RebornMagicResist45,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist45,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery45,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery45,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery45,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate45,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage45,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate45,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate45,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate45,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate45,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate45,
                        [Stat.HPRatePercent] = Settings.RebornHPRate45,
                        [Stat.MPRatePercent] = Settings.RebornMPRate45,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain45,
                    };

                    int tempAttr45 = Settings.RebornAttribute45;
                    if (tempAttr45 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr45 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr45);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn45, this, 0, Reborn45);
                    break;
                case 46:
                    var Reborn46 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC46,
                        [Stat.MaxAC] = Settings.RebornMaxAC46,
                        [Stat.MinMAC] = Settings.RebornMinMAC46,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC46,
                        [Stat.MinDC] = Settings.RebornMinDC46,
                        [Stat.MaxDC] = Settings.RebornMaxDC46,
                        [Stat.MinMC] = Settings.RebornMinMC46,
                        [Stat.MaxMC] = Settings.RebornMaxMC46,
                        [Stat.MinSC] = Settings.RebornMinSC46,
                        [Stat.MaxSC] = Settings.RebornMaxSC46,
                        [Stat.HP] = Settings.RebornHP46,
                        [Stat.MP] = Settings.RebornMP46,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage46,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage46,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction46,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate46,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate46,
                        [Stat.Accuracy] = Settings.RebornAccuracy46,
                        [Stat.Agility] = Settings.RebornAgility46,
                        [Stat.Freezing] = Settings.RebornFreezing46,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack46,
                        [Stat.MagicResist] = Settings.RebornMagicResist46,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist46,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery46,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery46,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery46,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate46,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage46,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate46,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate46,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate46,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate46,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate46,
                        [Stat.HPRatePercent] = Settings.RebornHPRate46,
                        [Stat.MPRatePercent] = Settings.RebornMPRate46,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain46,
                    };

                    int tempAttr46 = Settings.RebornAttribute46;
                    if (tempAttr46 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr46 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr46);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn46, this, 0, Reborn46);
                    break;
                case 47:
                    var Reborn47 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC47,
                        [Stat.MaxAC] = Settings.RebornMaxAC47,
                        [Stat.MinMAC] = Settings.RebornMinMAC47,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC47,
                        [Stat.MinDC] = Settings.RebornMinDC47,
                        [Stat.MaxDC] = Settings.RebornMaxDC47,
                        [Stat.MinMC] = Settings.RebornMinMC47,
                        [Stat.MaxMC] = Settings.RebornMaxMC47,
                        [Stat.MinSC] = Settings.RebornMinSC47,
                        [Stat.MaxSC] = Settings.RebornMaxSC47,
                        [Stat.HP] = Settings.RebornHP47,
                        [Stat.MP] = Settings.RebornMP47,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage47,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage47,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction47,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate47,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate47,
                        [Stat.Accuracy] = Settings.RebornAccuracy47,
                        [Stat.Agility] = Settings.RebornAgility47,
                        [Stat.Freezing] = Settings.RebornFreezing47,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack47,
                        [Stat.MagicResist] = Settings.RebornMagicResist47,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist47,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery47,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery47,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery47,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate47,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage47,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate47,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate47,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate47,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate47,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate47,
                        [Stat.HPRatePercent] = Settings.RebornHPRate47,
                        [Stat.MPRatePercent] = Settings.RebornMPRate47,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain47,
                    };

                    int tempAttr47 = Settings.RebornAttribute47;
                    if (tempAttr47 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr47 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr47);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn47, this, 0, Reborn47);
                    break;
                case 48:
                    var Reborn48 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC48,
                        [Stat.MaxAC] = Settings.RebornMaxAC48,
                        [Stat.MinMAC] = Settings.RebornMinMAC48,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC48,
                        [Stat.MinDC] = Settings.RebornMinDC48,
                        [Stat.MaxDC] = Settings.RebornMaxDC48,
                        [Stat.MinMC] = Settings.RebornMinMC48,
                        [Stat.MaxMC] = Settings.RebornMaxMC48,
                        [Stat.MinSC] = Settings.RebornMinSC48,
                        [Stat.MaxSC] = Settings.RebornMaxSC48,
                        [Stat.HP] = Settings.RebornHP48,
                        [Stat.MP] = Settings.RebornMP48,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage48,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage48,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction48,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate48,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate48,
                        [Stat.Accuracy] = Settings.RebornAccuracy48,
                        [Stat.Agility] = Settings.RebornAgility48,
                        [Stat.Freezing] = Settings.RebornFreezing48,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack48,
                        [Stat.MagicResist] = Settings.RebornMagicResist48,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist48,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery48,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery48,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery48,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate48,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage48,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate48,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate48,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate48,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate48,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate48,
                        [Stat.HPRatePercent] = Settings.RebornHPRate48,
                        [Stat.MPRatePercent] = Settings.RebornMPRate48,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain48,
                    };

                    int tempAttr48 = Settings.RebornAttribute48;
                    if (tempAttr48 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr48 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr48);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn48, this, 0, Reborn48);
                    break;
                case 49:
                    var Reborn49 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC49,
                        [Stat.MaxAC] = Settings.RebornMaxAC49,
                        [Stat.MinMAC] = Settings.RebornMinMAC49,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC49,
                        [Stat.MinDC] = Settings.RebornMinDC49,
                        [Stat.MaxDC] = Settings.RebornMaxDC49,
                        [Stat.MinMC] = Settings.RebornMinMC49,
                        [Stat.MaxMC] = Settings.RebornMaxMC49,
                        [Stat.MinSC] = Settings.RebornMinSC49,
                        [Stat.MaxSC] = Settings.RebornMaxSC49,
                        [Stat.HP] = Settings.RebornHP49,
                        [Stat.MP] = Settings.RebornMP49,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage49,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage49,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction49,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate49,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate49,
                        [Stat.Accuracy] = Settings.RebornAccuracy49,
                        [Stat.Agility] = Settings.RebornAgility49,
                        [Stat.Freezing] = Settings.RebornFreezing49,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack49,
                        [Stat.MagicResist] = Settings.RebornMagicResist49,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist49,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery49,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery49,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery49,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate49,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage49,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate49,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate49,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate49,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate49,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate49,
                        [Stat.HPRatePercent] = Settings.RebornHPRate49,
                        [Stat.MPRatePercent] = Settings.RebornMPRate49,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain49,
                    };

                    int tempAttr49 = Settings.RebornAttribute49;
                    if (tempAttr49 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr49 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr49);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn49, this, 0, Reborn49);
                    break;
                case 50:
                    var Reborn50 = new Stats
                    {
                        [Stat.MinAC] = Settings.RebornMinAC50,
                        [Stat.MaxAC] = Settings.RebornMaxAC50,
                        [Stat.MinMAC] = Settings.RebornMinMAC50,
                        [Stat.MaxMAC] = Settings.RebornMaxMAC50,
                        [Stat.MinDC] = Settings.RebornMinDC50,
                        [Stat.MaxDC] = Settings.RebornMaxDC50,
                        [Stat.MinMC] = Settings.RebornMinMC50,
                        [Stat.MaxMC] = Settings.RebornMaxMC50,
                        [Stat.MinSC] = Settings.RebornMinSC50,
                        [Stat.MaxSC] = Settings.RebornMaxSC50,
                        [Stat.HP] = Settings.RebornHP50,
                        [Stat.MP] = Settings.RebornMP50,
                        [Stat.PVEDamage] = Settings.RebornPVEDamage50,
                        [Stat.PVPDamage] = Settings.RebornPVPDamage50,
                        [Stat.DamageReductionPercent] = Settings.RebornDamageReduction50,
                        [Stat.ExpRatePercent] = Settings.RebornExpRate50,
                        [Stat.GoldDropRatePercent] = Settings.RebornGoldRate50,
                        [Stat.Accuracy] = Settings.RebornAccuracy50,
                        [Stat.Agility] = Settings.RebornAgility50,
                        [Stat.Freezing] = Settings.RebornFreezing50,
                        [Stat.PoisonAttack] = Settings.RebornPoisonAttack50,
                        [Stat.MagicResist] = Settings.RebornMagicResist50,
                        [Stat.PoisonResist] = Settings.RebornPoisonResist50,
                        [Stat.HealthRecovery] = Settings.RebornHealthRecovery50,
                        [Stat.SpellRecovery] = Settings.RebornSpellRecovery50,
                        [Stat.PoisonRecovery] = Settings.RebornPoisonRecovery50,
                        [Stat.CriticalRate] = Settings.RebornCriticalRate50,
                        [Stat.CriticalDamage] = Settings.RebornCriticalDamage50,
                        [Stat.MaxACRatePercent] = Settings.RebornMaxACRate50,
                        [Stat.MaxMACRatePercent] = Settings.RebornMaxMacRate50,
                        [Stat.MaxDCRatePercent] = Settings.RebornMaxDCRate50,
                        [Stat.MaxMCRatePercent] = Settings.RebornMaxMCRate50,
                        [Stat.MaxSCRatePercent] = Settings.RebornMaxSCRate50,
                        [Stat.HPRatePercent] = Settings.RebornHPRate50,
                        [Stat.MPRatePercent] = Settings.RebornMPRate50,
                        [Stat.HPDrainRatePercent] = Settings.RebornHPDrain50,
                    };

                    int tempAttr50 = Settings.RebornAttribute50;
                    if (tempAttr50 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr50 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr50);

                    RemoveBuff(BuffType.Reborn1);
                    RemoveBuff(BuffType.Reborn2);
                    RemoveBuff(BuffType.Reborn3);
                    RemoveBuff(BuffType.Reborn4);
                    RemoveBuff(BuffType.Reborn5);
                    RemoveBuff(BuffType.Reborn6);
                    RemoveBuff(BuffType.Reborn7);
                    RemoveBuff(BuffType.Reborn8);
                    RemoveBuff(BuffType.Reborn9);
                    RemoveBuff(BuffType.Reborn10);
                    RemoveBuff(BuffType.Reborn11);
                    RemoveBuff(BuffType.Reborn12);
                    RemoveBuff(BuffType.Reborn13);
                    RemoveBuff(BuffType.Reborn14);
                    RemoveBuff(BuffType.Reborn15);
                    RemoveBuff(BuffType.Reborn16);
                    RemoveBuff(BuffType.Reborn17);
                    RemoveBuff(BuffType.Reborn18);
                    RemoveBuff(BuffType.Reborn19);
                    RemoveBuff(BuffType.Reborn20);
                    RemoveBuff(BuffType.Reborn21);
                    RemoveBuff(BuffType.Reborn22);
                    RemoveBuff(BuffType.Reborn23);
                    RemoveBuff(BuffType.Reborn24);
                    RemoveBuff(BuffType.Reborn25);
                    RemoveBuff(BuffType.Reborn26);
                    RemoveBuff(BuffType.Reborn27);
                    RemoveBuff(BuffType.Reborn28);
                    RemoveBuff(BuffType.Reborn29);
                    RemoveBuff(BuffType.Reborn30);
                    RemoveBuff(BuffType.Reborn31);
                    RemoveBuff(BuffType.Reborn32);
                    RemoveBuff(BuffType.Reborn33);
                    RemoveBuff(BuffType.Reborn34);
                    RemoveBuff(BuffType.Reborn35);
                    RemoveBuff(BuffType.Reborn36);
                    RemoveBuff(BuffType.Reborn37);
                    RemoveBuff(BuffType.Reborn38);
                    RemoveBuff(BuffType.Reborn39);
                    RemoveBuff(BuffType.Reborn40);
                    RemoveBuff(BuffType.Reborn41);
                    RemoveBuff(BuffType.Reborn42);
                    RemoveBuff(BuffType.Reborn43);
                    RemoveBuff(BuffType.Reborn44);
                    RemoveBuff(BuffType.Reborn45);
                    RemoveBuff(BuffType.Reborn46);
                    RemoveBuff(BuffType.Reborn47);
                    RemoveBuff(BuffType.Reborn48);
                    RemoveBuff(BuffType.Reborn49);
                    RemoveBuff(BuffType.Reborn50);
                    AddBuff(BuffType.Reborn50, this, 0, Reborn50);
                    break;
            }
        }
        private void UpdateInstanceStageBuff()
        {
            switch (InstanceStage)
            {
                case 0:
                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    break;
                case 1:
                    var InstanceStage1 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC1,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC1,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC1,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC1,
                        [Stat.MinDC] = Settings.InstanceStageMinDC1,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC1,
                        [Stat.MinMC] = Settings.InstanceStageMinMC1,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC1,
                        [Stat.MinSC] = Settings.InstanceStageMinSC1,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC1,
                        [Stat.HP] = Settings.InstanceStageHP1,
                        [Stat.MP] = Settings.InstanceStageMP1,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage1,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage1,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction1,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate1,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate1,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy1,
                        [Stat.Agility] = Settings.InstanceStageAgility1,
                        [Stat.Freezing] = Settings.InstanceStageFreezing1,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack1,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist1,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist1,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery1,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery1,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery1,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate1,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage1,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate1,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate1,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate1,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate1,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate1,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate1,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate1,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain1,
                    };

                    int tempAttr1 = Settings.InstanceStageAttribute1;
                    if (tempAttr1 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr1 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr1);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage1, this, 0, InstanceStage1);
                    break;
                case 2:
                    var InstanceStage2 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC2,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC2,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC2,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC2,
                        [Stat.MinDC] = Settings.InstanceStageMinDC2,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC2,
                        [Stat.MinMC] = Settings.InstanceStageMinMC2,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC2,
                        [Stat.MinSC] = Settings.InstanceStageMinSC2,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC2,
                        [Stat.HP] = Settings.InstanceStageHP2,
                        [Stat.MP] = Settings.InstanceStageMP2,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage2,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage2,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction2,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate2,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate2,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy2,
                        [Stat.Agility] = Settings.InstanceStageAgility2,
                        [Stat.Freezing] = Settings.InstanceStageFreezing2,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack2,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist2,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist2,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery2,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery2,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery2,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate2,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage2,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate2,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate2,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate2,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate2,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate2,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate2,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate2,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain2,
                    };

                    int tempAttr2 = Settings.InstanceStageAttribute2;
                    if (tempAttr2 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr2 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr2);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage2, this, 0, InstanceStage2);
                    break;
                case 3:
                    var InstanceStage3 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC3,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC3,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC3,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC3,
                        [Stat.MinDC] = Settings.InstanceStageMinDC3,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC3,
                        [Stat.MinMC] = Settings.InstanceStageMinMC3,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC3,
                        [Stat.MinSC] = Settings.InstanceStageMinSC3,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC3,
                        [Stat.HP] = Settings.InstanceStageHP3,
                        [Stat.MP] = Settings.InstanceStageMP3,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage3,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage3,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction3,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate3,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate3,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy3,
                        [Stat.Agility] = Settings.InstanceStageAgility3,
                        [Stat.Freezing] = Settings.InstanceStageFreezing3,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack3,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist3,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist3,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery3,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery3,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery3,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate3,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage3,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate3,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate3,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate3,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate3,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate3,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate3,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate3,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain3,
                    };

                    int tempAttr3 = Settings.InstanceStageAttribute3;
                    if (tempAttr3 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr3 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr3);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage3, this, 0, InstanceStage3);
                    break;
                case 4:
                    var InstanceStage4 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC4,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC4,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC4,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC4,
                        [Stat.MinDC] = Settings.InstanceStageMinDC4,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC4,
                        [Stat.MinMC] = Settings.InstanceStageMinMC4,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC4,
                        [Stat.MinSC] = Settings.InstanceStageMinSC4,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC4,
                        [Stat.HP] = Settings.InstanceStageHP4,
                        [Stat.MP] = Settings.InstanceStageMP4,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage4,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage4,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction4,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate4,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate4,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy4,
                        [Stat.Agility] = Settings.InstanceStageAgility4,
                        [Stat.Freezing] = Settings.InstanceStageFreezing4,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack4,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist4,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist4,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery4,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery4,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery4,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate4,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage4,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate4,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate4,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate4,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate4,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate4,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate4,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate4,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain4,
                    };

                    int tempAttr4 = Settings.InstanceStageAttribute4;
                    if (tempAttr4 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr4 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr4);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage4, this, 0, InstanceStage4);
                    break;
                case 5:
                    var InstanceStage5 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC5,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC5,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC5,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC5,
                        [Stat.MinDC] = Settings.InstanceStageMinDC5,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC5,
                        [Stat.MinMC] = Settings.InstanceStageMinMC5,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC5,
                        [Stat.MinSC] = Settings.InstanceStageMinSC5,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC5,
                        [Stat.HP] = Settings.InstanceStageHP5,
                        [Stat.MP] = Settings.InstanceStageMP5,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage5,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage5,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction5,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate5,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate5,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy5,
                        [Stat.Agility] = Settings.InstanceStageAgility5,
                        [Stat.Freezing] = Settings.InstanceStageFreezing5,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack5,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist5,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist5,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery5,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery5,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery5,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate5,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage5,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate5,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate5,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate5,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate5,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate5,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate5,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate5,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain5,
                    };

                    int tempAttr5 = Settings.InstanceStageAttribute5;
                    if (tempAttr5 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr5 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr5);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage5, this, 0, InstanceStage5);
                    break;
                case 6:
                    var InstanceStage6 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC6,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC6,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC6,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC6,
                        [Stat.MinDC] = Settings.InstanceStageMinDC6,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC6,
                        [Stat.MinMC] = Settings.InstanceStageMinMC6,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC6,
                        [Stat.MinSC] = Settings.InstanceStageMinSC6,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC6,
                        [Stat.HP] = Settings.InstanceStageHP6,
                        [Stat.MP] = Settings.InstanceStageMP6,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage6,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage6,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction6,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate6,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate6,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy6,
                        [Stat.Agility] = Settings.InstanceStageAgility6,
                        [Stat.Freezing] = Settings.InstanceStageFreezing6,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack6,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist6,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist6,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery6,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery6,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery6,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate6,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage6,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate6,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate6,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate6,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate6,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate6,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate6,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate6,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain6,
                    };

                    int tempAttr6 = Settings.InstanceStageAttribute6;
                    if (tempAttr6 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr6 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr6);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage6, this, 0, InstanceStage6);
                    break;
                case 7:
                    var InstanceStage7 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC7,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC7,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC7,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC7,
                        [Stat.MinDC] = Settings.InstanceStageMinDC7,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC7,
                        [Stat.MinMC] = Settings.InstanceStageMinMC7,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC7,
                        [Stat.MinSC] = Settings.InstanceStageMinSC7,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC7,
                        [Stat.HP] = Settings.InstanceStageHP7,
                        [Stat.MP] = Settings.InstanceStageMP7,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage7,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage7,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction7,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate7,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate7,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy7,
                        [Stat.Agility] = Settings.InstanceStageAgility7,
                        [Stat.Freezing] = Settings.InstanceStageFreezing7,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack7,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist7,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist7,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery7,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery7,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery7,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate7,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage7,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate7,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate7,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate7,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate7,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate7,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate7,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate7,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain7,
                    };

                    int tempAttr7 = Settings.InstanceStageAttribute7;
                    if (tempAttr7 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr7 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr7);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage7, this, 0, InstanceStage7);
                    break;
                case 8:
                    var InstanceStage8 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC8,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC8,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC8,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC8,
                        [Stat.MinDC] = Settings.InstanceStageMinDC8,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC8,
                        [Stat.MinMC] = Settings.InstanceStageMinMC8,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC8,
                        [Stat.MinSC] = Settings.InstanceStageMinSC8,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC8,
                        [Stat.HP] = Settings.InstanceStageHP8,
                        [Stat.MP] = Settings.InstanceStageMP8,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage8,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage8,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction8,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate8,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate8,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy8,
                        [Stat.Agility] = Settings.InstanceStageAgility8,
                        [Stat.Freezing] = Settings.InstanceStageFreezing8,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack8,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist8,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist8,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery8,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery8,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery8,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate8,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage8,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate8,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate8,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate8,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate8,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate8,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate8,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate8,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain8,
                    };

                    int tempAttr8 = Settings.InstanceStageAttribute8;
                    if (tempAttr8 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr8 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr8);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage8, this, 0, InstanceStage8);
                    break;
                case 9:
                    var InstanceStage9 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC9,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC9,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC9,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC9,
                        [Stat.MinDC] = Settings.InstanceStageMinDC9,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC9,
                        [Stat.MinMC] = Settings.InstanceStageMinMC9,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC9,
                        [Stat.MinSC] = Settings.InstanceStageMinSC9,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC9,
                        [Stat.HP] = Settings.InstanceStageHP9,
                        [Stat.MP] = Settings.InstanceStageMP9,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage9,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage9,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction9,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate9,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate9,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy9,
                        [Stat.Agility] = Settings.InstanceStageAgility9,
                        [Stat.Freezing] = Settings.InstanceStageFreezing9,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack9,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist9,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist9,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery9,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery9,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery9,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate9,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage9,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate9,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate9,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate9,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate9,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate9,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate9,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate9,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain9,
                    };

                    int tempAttr9 = Settings.InstanceStageAttribute9;
                    if (tempAttr9 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr9 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr9);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage9, this, 0, InstanceStage9);
                    break;
                case 10:
                    var InstanceStage10 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC10,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC10,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC10,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC10,
                        [Stat.MinDC] = Settings.InstanceStageMinDC10,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC10,
                        [Stat.MinMC] = Settings.InstanceStageMinMC10,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC10,
                        [Stat.MinSC] = Settings.InstanceStageMinSC10,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC10,
                        [Stat.HP] = Settings.InstanceStageHP10,
                        [Stat.MP] = Settings.InstanceStageMP10,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage10,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage10,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction10,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate10,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate10,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy10,
                        [Stat.Agility] = Settings.InstanceStageAgility10,
                        [Stat.Freezing] = Settings.InstanceStageFreezing10,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack10,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist10,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist10,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery10,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery10,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery10,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate10,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage10,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate10,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate10,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate10,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate10,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate10,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate10,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate10,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain10,
                    };

                    int tempAttr10 = Settings.InstanceStageAttribute10;
                    if (tempAttr10 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr10 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr10);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage10, this, 0, InstanceStage10);
                    break;
                case 11:
                    var InstanceStage11 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC11,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC11,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC11,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC11,
                        [Stat.MinDC] = Settings.InstanceStageMinDC11,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC11,
                        [Stat.MinMC] = Settings.InstanceStageMinMC11,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC11,
                        [Stat.MinSC] = Settings.InstanceStageMinSC11,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC11,
                        [Stat.HP] = Settings.InstanceStageHP11,
                        [Stat.MP] = Settings.InstanceStageMP11,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage11,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage11,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction11,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate11,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate11,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy11,
                        [Stat.Agility] = Settings.InstanceStageAgility11,
                        [Stat.Freezing] = Settings.InstanceStageFreezing11,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack11,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist11,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist11,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery11,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery11,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery11,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate11,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage11,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate11,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate11,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate11,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate11,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate11,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate11,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate11,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain11,
                    };

                    int tempAttr11 = Settings.InstanceStageAttribute11;
                    if (tempAttr11 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr11 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr11);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage11, this, 0, InstanceStage11);
                    break;
                case 12:
                    var InstanceStage12 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC12,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC12,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC12,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC12,
                        [Stat.MinDC] = Settings.InstanceStageMinDC12,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC12,
                        [Stat.MinMC] = Settings.InstanceStageMinMC12,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC12,
                        [Stat.MinSC] = Settings.InstanceStageMinSC12,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC12,
                        [Stat.HP] = Settings.InstanceStageHP12,
                        [Stat.MP] = Settings.InstanceStageMP12,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage12,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage12,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction12,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate12,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate12,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy12,
                        [Stat.Agility] = Settings.InstanceStageAgility12,
                        [Stat.Freezing] = Settings.InstanceStageFreezing12,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack12,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist12,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist12,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery12,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery12,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery12,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate12,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage12,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate12,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate12,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate12,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate12,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate12,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate12,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate12,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain12,
                    };

                    int tempAttr12 = Settings.InstanceStageAttribute12;
                    if (tempAttr12 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr12 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr12);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage12, this, 0, InstanceStage12);
                    break;
                case 13:
                    var InstanceStage13 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC13,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC13,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC13,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC13,
                        [Stat.MinDC] = Settings.InstanceStageMinDC13,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC13,
                        [Stat.MinMC] = Settings.InstanceStageMinMC13,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC13,
                        [Stat.MinSC] = Settings.InstanceStageMinSC13,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC13,
                        [Stat.HP] = Settings.InstanceStageHP13,
                        [Stat.MP] = Settings.InstanceStageMP13,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage13,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage13,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction13,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate13,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate13,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy13,
                        [Stat.Agility] = Settings.InstanceStageAgility13,
                        [Stat.Freezing] = Settings.InstanceStageFreezing13,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack13,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist13,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist13,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery13,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery13,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery13,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate13,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage13,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate13,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate13,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate13,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate13,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate13,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate13,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate13,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain13,
                    };

                    int tempAttr13 = Settings.InstanceStageAttribute13;
                    if (tempAttr13 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr13 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr13);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage13, this, 0, InstanceStage13);
                    break;
                case 14:
                    var InstanceStage14 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC14,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC14,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC14,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC14,
                        [Stat.MinDC] = Settings.InstanceStageMinDC14,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC14,
                        [Stat.MinMC] = Settings.InstanceStageMinMC14,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC14,
                        [Stat.MinSC] = Settings.InstanceStageMinSC14,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC14,
                        [Stat.HP] = Settings.InstanceStageHP14,
                        [Stat.MP] = Settings.InstanceStageMP14,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage14,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage14,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction14,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate14,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate14,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy14,
                        [Stat.Agility] = Settings.InstanceStageAgility14,
                        [Stat.Freezing] = Settings.InstanceStageFreezing14,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack14,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist14,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist14,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery14,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery14,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery14,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate14,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage14,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate14,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate14,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate14,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate14,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate14,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate14,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate14,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain14,
                    };

                    int tempAttr14 = Settings.InstanceStageAttribute14;
                    if (tempAttr14 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr14 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr14);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage14, this, 0, InstanceStage14);
                    break;
                case 15:
                    var InstanceStage15 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC15,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC15,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC15,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC15,
                        [Stat.MinDC] = Settings.InstanceStageMinDC15,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC15,
                        [Stat.MinMC] = Settings.InstanceStageMinMC15,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC15,
                        [Stat.MinSC] = Settings.InstanceStageMinSC15,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC15,
                        [Stat.HP] = Settings.InstanceStageHP15,
                        [Stat.MP] = Settings.InstanceStageMP15,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage15,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage15,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction15,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate15,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate15,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy15,
                        [Stat.Agility] = Settings.InstanceStageAgility15,
                        [Stat.Freezing] = Settings.InstanceStageFreezing15,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack15,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist15,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist15,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery15,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery15,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery15,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate15,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage15,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate15,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate15,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate15,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate15,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate15,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate15,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate15,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain15,
                    };

                    int tempAttr15 = Settings.InstanceStageAttribute15;
                    if (tempAttr15 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr15 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr15);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage15, this, 0, InstanceStage15);
                    break;
                case 16:
                    var InstanceStage16 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC16,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC16,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC16,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC16,
                        [Stat.MinDC] = Settings.InstanceStageMinDC16,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC16,
                        [Stat.MinMC] = Settings.InstanceStageMinMC16,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC16,
                        [Stat.MinSC] = Settings.InstanceStageMinSC16,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC16,
                        [Stat.HP] = Settings.InstanceStageHP16,
                        [Stat.MP] = Settings.InstanceStageMP16,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage16,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage16,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction16,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate16,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate16,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy16,
                        [Stat.Agility] = Settings.InstanceStageAgility16,
                        [Stat.Freezing] = Settings.InstanceStageFreezing16,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack16,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist16,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist16,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery16,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery16,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery16,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate16,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage16,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate16,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate16,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate16,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate16,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate16,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate16,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate16,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain16,
                    };

                    int tempAttr16 = Settings.InstanceStageAttribute16;
                    if (tempAttr16 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr16 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr16);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage16, this, 0, InstanceStage16);
                    break;
                case 17:
                    var InstanceStage17 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC17,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC17,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC17,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC17,
                        [Stat.MinDC] = Settings.InstanceStageMinDC17,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC17,
                        [Stat.MinMC] = Settings.InstanceStageMinMC17,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC17,
                        [Stat.MinSC] = Settings.InstanceStageMinSC17,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC17,
                        [Stat.HP] = Settings.InstanceStageHP17,
                        [Stat.MP] = Settings.InstanceStageMP17,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage17,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage17,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction17,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate17,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate17,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy17,
                        [Stat.Agility] = Settings.InstanceStageAgility17,
                        [Stat.Freezing] = Settings.InstanceStageFreezing17,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack17,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist17,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist17,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery17,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery17,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery17,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate17,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage17,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate17,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate17,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate17,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate17,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate17,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate17,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate17,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain17,
                    };

                    int tempAttr17 = Settings.InstanceStageAttribute17;
                    if (tempAttr17 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr17 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr17);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage17, this, 0, InstanceStage17);
                    break;
                case 18:
                    var InstanceStage18 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC18,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC18,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC18,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC18,
                        [Stat.MinDC] = Settings.InstanceStageMinDC18,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC18,
                        [Stat.MinMC] = Settings.InstanceStageMinMC18,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC18,
                        [Stat.MinSC] = Settings.InstanceStageMinSC18,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC18,
                        [Stat.HP] = Settings.InstanceStageHP18,
                        [Stat.MP] = Settings.InstanceStageMP18,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage18,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage18,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction18,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate18,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate18,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy18,
                        [Stat.Agility] = Settings.InstanceStageAgility18,
                        [Stat.Freezing] = Settings.InstanceStageFreezing18,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack18,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist18,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist18,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery18,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery18,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery18,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate18,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage18,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate18,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate18,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate18,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate18,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate18,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate18,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate18,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain18,
                    };

                    int tempAttr18 = Settings.InstanceStageAttribute18;
                    if (tempAttr18 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr18 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr18);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage18, this, 0, InstanceStage18);
                    break;
                case 19:
                    var InstanceStage19 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC19,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC19,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC19,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC19,
                        [Stat.MinDC] = Settings.InstanceStageMinDC19,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC19,
                        [Stat.MinMC] = Settings.InstanceStageMinMC19,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC19,
                        [Stat.MinSC] = Settings.InstanceStageMinSC19,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC19,
                        [Stat.HP] = Settings.InstanceStageHP19,
                        [Stat.MP] = Settings.InstanceStageMP19,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage19,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage19,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction19,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate19,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate19,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy19,
                        [Stat.Agility] = Settings.InstanceStageAgility19,
                        [Stat.Freezing] = Settings.InstanceStageFreezing19,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack19,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist19,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist19,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery19,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery19,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery19,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate19,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage19,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate19,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate19,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate19,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate19,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate19,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate19,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate19,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain19,
                    };

                    int tempAttr19 = Settings.InstanceStageAttribute19;
                    if (tempAttr19 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr19 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr19);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage19, this, 0, InstanceStage19);
                    break;
                case 20:
                    var InstanceStage20 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC20,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC20,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC20,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC20,
                        [Stat.MinDC] = Settings.InstanceStageMinDC20,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC20,
                        [Stat.MinMC] = Settings.InstanceStageMinMC20,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC20,
                        [Stat.MinSC] = Settings.InstanceStageMinSC20,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC20,
                        [Stat.HP] = Settings.InstanceStageHP20,
                        [Stat.MP] = Settings.InstanceStageMP20,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage20,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage20,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction20,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate20,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate20,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy20,
                        [Stat.Agility] = Settings.InstanceStageAgility20,
                        [Stat.Freezing] = Settings.InstanceStageFreezing20,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack20,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist20,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist20,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery20,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery20,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery20,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate20,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage20,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate20,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate20,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate20,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate20,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate20,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate20,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate20,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain20,
                    };

                    int tempAttr20 = Settings.InstanceStageAttribute20;
                    if (tempAttr20 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr20 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr20);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage20, this, 0, InstanceStage20);
                    break;
                case 21:
                    var InstanceStage21 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC21,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC21,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC21,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC21,
                        [Stat.MinDC] = Settings.InstanceStageMinDC21,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC21,
                        [Stat.MinMC] = Settings.InstanceStageMinMC21,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC21,
                        [Stat.MinSC] = Settings.InstanceStageMinSC21,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC21,
                        [Stat.HP] = Settings.InstanceStageHP21,
                        [Stat.MP] = Settings.InstanceStageMP21,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage21,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage21,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction21,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate21,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate21,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy21,
                        [Stat.Agility] = Settings.InstanceStageAgility21,
                        [Stat.Freezing] = Settings.InstanceStageFreezing21,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack21,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist21,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist21,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery21,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery21,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery21,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate21,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage21,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate21,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate21,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate21,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate21,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate21,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate21,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate21,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain21,
                    };

                    int tempAttr21 = Settings.InstanceStageAttribute21;
                    if (tempAttr21 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr21 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr21);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage21, this, 0, InstanceStage21);
                    break;
                case 22:
                    var InstanceStage22 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC22,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC22,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC22,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC22,
                        [Stat.MinDC] = Settings.InstanceStageMinDC22,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC22,
                        [Stat.MinMC] = Settings.InstanceStageMinMC22,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC22,
                        [Stat.MinSC] = Settings.InstanceStageMinSC22,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC22,
                        [Stat.HP] = Settings.InstanceStageHP22,
                        [Stat.MP] = Settings.InstanceStageMP22,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage22,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage22,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction22,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate22,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate22,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy22,
                        [Stat.Agility] = Settings.InstanceStageAgility22,
                        [Stat.Freezing] = Settings.InstanceStageFreezing22,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack22,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist22,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist22,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery22,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery22,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery22,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate22,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage22,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate22,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate22,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate22,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate22,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate22,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate22,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate22,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain22,
                    };

                    int tempAttr22 = Settings.InstanceStageAttribute22;
                    if (tempAttr22 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr22 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr22);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage22, this, 0, InstanceStage22);
                    break;
                case 23:
                    var InstanceStage23 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC23,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC23,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC23,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC23,
                        [Stat.MinDC] = Settings.InstanceStageMinDC23,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC23,
                        [Stat.MinMC] = Settings.InstanceStageMinMC23,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC23,
                        [Stat.MinSC] = Settings.InstanceStageMinSC23,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC23,
                        [Stat.HP] = Settings.InstanceStageHP23,
                        [Stat.MP] = Settings.InstanceStageMP23,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage23,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage23,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction23,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate23,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate23,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy23,
                        [Stat.Agility] = Settings.InstanceStageAgility23,
                        [Stat.Freezing] = Settings.InstanceStageFreezing23,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack23,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist23,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist23,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery23,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery23,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery23,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate23,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage23,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate23,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate23,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate23,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate23,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate23,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate23,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate23,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain23,
                    };

                    int tempAttr23 = Settings.InstanceStageAttribute23;
                    if (tempAttr23 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr23 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr23);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage23, this, 0, InstanceStage23);
                    break;
                case 24:
                    var InstanceStage24 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC24,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC24,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC24,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC24,
                        [Stat.MinDC] = Settings.InstanceStageMinDC24,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC24,
                        [Stat.MinMC] = Settings.InstanceStageMinMC24,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC24,
                        [Stat.MinSC] = Settings.InstanceStageMinSC24,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC24,
                        [Stat.HP] = Settings.InstanceStageHP24,
                        [Stat.MP] = Settings.InstanceStageMP24,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage24,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage24,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction24,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate24,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate24,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy24,
                        [Stat.Agility] = Settings.InstanceStageAgility24,
                        [Stat.Freezing] = Settings.InstanceStageFreezing24,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack24,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist24,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist24,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery24,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery24,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery24,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate24,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage24,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate24,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate24,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate24,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate24,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate24,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate24,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate24,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain24,
                    };

                    int tempAttr24 = Settings.InstanceStageAttribute24;
                    if (tempAttr24 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr24 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr24);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage24, this, 0, InstanceStage24);
                    break;
                case 25:
                    var InstanceStage25 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC25,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC25,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC25,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC25,
                        [Stat.MinDC] = Settings.InstanceStageMinDC25,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC25,
                        [Stat.MinMC] = Settings.InstanceStageMinMC25,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC25,
                        [Stat.MinSC] = Settings.InstanceStageMinSC25,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC25,
                        [Stat.HP] = Settings.InstanceStageHP25,
                        [Stat.MP] = Settings.InstanceStageMP25,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage25,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage25,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction25,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate25,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate25,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy25,
                        [Stat.Agility] = Settings.InstanceStageAgility25,
                        [Stat.Freezing] = Settings.InstanceStageFreezing25,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack25,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist25,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist25,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery25,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery25,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery25,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate25,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage25,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate25,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate25,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate25,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate25,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate25,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate25,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate25,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain25,
                    };

                    int tempAttr25 = Settings.InstanceStageAttribute25;
                    if (tempAttr25 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr25 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr25);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage25, this, 0, InstanceStage25);
                    break;
                case 26:
                    var InstanceStage26 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC26,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC26,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC26,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC26,
                        [Stat.MinDC] = Settings.InstanceStageMinDC26,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC26,
                        [Stat.MinMC] = Settings.InstanceStageMinMC26,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC26,
                        [Stat.MinSC] = Settings.InstanceStageMinSC26,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC26,
                        [Stat.HP] = Settings.InstanceStageHP26,
                        [Stat.MP] = Settings.InstanceStageMP26,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage26,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage26,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction26,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate26,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate26,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy26,
                        [Stat.Agility] = Settings.InstanceStageAgility26,
                        [Stat.Freezing] = Settings.InstanceStageFreezing26,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack26,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist26,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist26,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery26,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery26,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery26,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate26,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage26,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate26,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate26,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate26,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate26,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate26,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate26,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate26,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain26,
                    };

                    int tempAttr26 = Settings.InstanceStageAttribute26;
                    if (tempAttr26 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr26 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr26);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage26, this, 0, InstanceStage26);
                    break;
                case 27:
                    var InstanceStage27 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC27,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC27,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC27,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC27,
                        [Stat.MinDC] = Settings.InstanceStageMinDC27,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC27,
                        [Stat.MinMC] = Settings.InstanceStageMinMC27,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC27,
                        [Stat.MinSC] = Settings.InstanceStageMinSC27,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC27,
                        [Stat.HP] = Settings.InstanceStageHP27,
                        [Stat.MP] = Settings.InstanceStageMP27,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage27,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage27,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction27,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate27,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate27,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy27,
                        [Stat.Agility] = Settings.InstanceStageAgility27,
                        [Stat.Freezing] = Settings.InstanceStageFreezing27,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack27,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist27,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist27,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery27,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery27,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery27,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate27,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage27,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate27,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate27,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate27,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate27,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate27,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate27,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate27,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain27,
                    };

                    int tempAttr27 = Settings.InstanceStageAttribute27;
                    if (tempAttr27 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr27 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr27);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage27, this, 0, InstanceStage27);
                    break;
                case 28:
                    var InstanceStage28 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC28,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC28,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC28,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC28,
                        [Stat.MinDC] = Settings.InstanceStageMinDC28,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC28,
                        [Stat.MinMC] = Settings.InstanceStageMinMC28,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC28,
                        [Stat.MinSC] = Settings.InstanceStageMinSC28,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC28,
                        [Stat.HP] = Settings.InstanceStageHP28,
                        [Stat.MP] = Settings.InstanceStageMP28,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage28,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage28,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction28,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate28,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate28,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy28,
                        [Stat.Agility] = Settings.InstanceStageAgility28,
                        [Stat.Freezing] = Settings.InstanceStageFreezing28,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack28,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist28,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist28,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery28,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery28,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery28,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate28,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage28,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate28,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate28,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate28,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate28,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate28,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate28,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate28,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain28,
                    };

                    int tempAttr28 = Settings.InstanceStageAttribute28;
                    if (tempAttr28 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr28 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr28);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage28, this, 0, InstanceStage28);
                    break;
                case 29:
                    var InstanceStage29 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC29,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC29,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC29,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC29,
                        [Stat.MinDC] = Settings.InstanceStageMinDC29,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC29,
                        [Stat.MinMC] = Settings.InstanceStageMinMC29,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC29,
                        [Stat.MinSC] = Settings.InstanceStageMinSC29,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC29,
                        [Stat.HP] = Settings.InstanceStageHP29,
                        [Stat.MP] = Settings.InstanceStageMP29,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage29,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage29,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction29,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate29,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate29,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy29,
                        [Stat.Agility] = Settings.InstanceStageAgility29,
                        [Stat.Freezing] = Settings.InstanceStageFreezing29,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack29,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist29,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist29,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery29,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery29,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery29,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate29,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage29,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate29,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate29,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate29,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate29,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate29,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate29,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate29,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain29,
                    };

                    int tempAttr29 = Settings.InstanceStageAttribute29;
                    if (tempAttr29 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr29 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr29);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage29, this, 0, InstanceStage29);
                    break;
                case 30:
                    var InstanceStage30 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC30,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC30,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC30,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC30,
                        [Stat.MinDC] = Settings.InstanceStageMinDC30,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC30,
                        [Stat.MinMC] = Settings.InstanceStageMinMC30,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC30,
                        [Stat.MinSC] = Settings.InstanceStageMinSC30,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC30,
                        [Stat.HP] = Settings.InstanceStageHP30,
                        [Stat.MP] = Settings.InstanceStageMP30,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage30,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage30,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction30,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate30,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate30,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy30,
                        [Stat.Agility] = Settings.InstanceStageAgility30,
                        [Stat.Freezing] = Settings.InstanceStageFreezing30,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack30,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist30,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist30,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery30,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery30,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery30,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate30,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage30,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate30,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate30,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate30,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate30,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate30,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate30,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate30,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain30,
                    };

                    int tempAttr30 = Settings.InstanceStageAttribute30;
                    if (tempAttr30 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr30 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr30);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage30, this, 0, InstanceStage30);
                    break;
                case 31:
                    var InstanceStage31 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC31,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC31,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC31,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC31,
                        [Stat.MinDC] = Settings.InstanceStageMinDC31,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC31,
                        [Stat.MinMC] = Settings.InstanceStageMinMC31,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC31,
                        [Stat.MinSC] = Settings.InstanceStageMinSC31,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC31,
                        [Stat.HP] = Settings.InstanceStageHP31,
                        [Stat.MP] = Settings.InstanceStageMP31,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage31,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage31,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction31,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate31,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate31,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy31,
                        [Stat.Agility] = Settings.InstanceStageAgility31,
                        [Stat.Freezing] = Settings.InstanceStageFreezing31,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack31,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist31,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist31,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery31,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery31,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery31,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate31,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage31,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate31,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate31,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate31,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate31,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate31,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate31,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate31,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain31,
                    };

                    int tempAttr31 = Settings.InstanceStageAttribute31;
                    if (tempAttr31 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr31 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr31);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage31, this, 0, InstanceStage31);
                    break;
                case 32:
                    var InstanceStage32 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC32,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC32,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC32,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC32,
                        [Stat.MinDC] = Settings.InstanceStageMinDC32,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC32,
                        [Stat.MinMC] = Settings.InstanceStageMinMC32,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC32,
                        [Stat.MinSC] = Settings.InstanceStageMinSC32,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC32,
                        [Stat.HP] = Settings.InstanceStageHP32,
                        [Stat.MP] = Settings.InstanceStageMP32,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage32,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage32,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction32,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate32,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate32,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy32,
                        [Stat.Agility] = Settings.InstanceStageAgility32,
                        [Stat.Freezing] = Settings.InstanceStageFreezing32,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack32,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist32,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist32,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery32,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery32,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery32,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate32,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage32,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate32,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate32,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate32,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate32,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate32,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate32,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate32,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain32,
                    };

                    int tempAttr32 = Settings.InstanceStageAttribute32;
                    if (tempAttr32 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr32 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr32);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage32, this, 0, InstanceStage32);
                    break;
                case 33:
                    var InstanceStage33 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC33,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC33,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC33,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC33,
                        [Stat.MinDC] = Settings.InstanceStageMinDC33,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC33,
                        [Stat.MinMC] = Settings.InstanceStageMinMC33,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC33,
                        [Stat.MinSC] = Settings.InstanceStageMinSC33,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC33,
                        [Stat.HP] = Settings.InstanceStageHP33,
                        [Stat.MP] = Settings.InstanceStageMP33,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage33,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage33,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction33,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate33,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate33,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy33,
                        [Stat.Agility] = Settings.InstanceStageAgility33,
                        [Stat.Freezing] = Settings.InstanceStageFreezing33,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack33,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist33,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist33,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery33,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery33,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery33,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate33,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage33,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate33,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate33,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate33,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate33,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate33,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate33,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate33,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain33,
                    };

                    int tempAttr33 = Settings.InstanceStageAttribute33;
                    if (tempAttr33 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr33 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr33);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage33, this, 0, InstanceStage33);
                    break;
                case 34:
                    var InstanceStage34 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC34,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC34,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC34,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC34,
                        [Stat.MinDC] = Settings.InstanceStageMinDC34,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC34,
                        [Stat.MinMC] = Settings.InstanceStageMinMC34,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC34,
                        [Stat.MinSC] = Settings.InstanceStageMinSC34,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC34,
                        [Stat.HP] = Settings.InstanceStageHP34,
                        [Stat.MP] = Settings.InstanceStageMP34,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage34,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage34,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction34,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate34,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate34,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy34,
                        [Stat.Agility] = Settings.InstanceStageAgility34,
                        [Stat.Freezing] = Settings.InstanceStageFreezing34,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack34,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist34,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist34,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery34,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery34,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery34,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate34,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage34,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate34,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate34,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate34,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate34,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate34,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate34,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate34,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain34,
                    };

                    int tempAttr34 = Settings.InstanceStageAttribute34;
                    if (tempAttr34 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr34 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr34);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage34, this, 0, InstanceStage34);
                    break;
                case 35:
                    var InstanceStage35 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC35,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC35,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC35,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC35,
                        [Stat.MinDC] = Settings.InstanceStageMinDC35,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC35,
                        [Stat.MinMC] = Settings.InstanceStageMinMC35,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC35,
                        [Stat.MinSC] = Settings.InstanceStageMinSC35,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC35,
                        [Stat.HP] = Settings.InstanceStageHP35,
                        [Stat.MP] = Settings.InstanceStageMP35,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage35,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage35,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction35,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate35,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate35,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy35,
                        [Stat.Agility] = Settings.InstanceStageAgility35,
                        [Stat.Freezing] = Settings.InstanceStageFreezing35,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack35,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist35,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist35,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery35,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery35,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery35,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate35,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage35,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate35,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate35,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate35,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate35,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate35,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate35,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate35,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain35,
                    };

                    int tempAttr35 = Settings.InstanceStageAttribute35;
                    if (tempAttr35 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr35 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr35);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage35, this, 0, InstanceStage35);
                    break;
                case 36:
                    var InstanceStage36 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC36,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC36,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC36,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC36,
                        [Stat.MinDC] = Settings.InstanceStageMinDC36,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC36,
                        [Stat.MinMC] = Settings.InstanceStageMinMC36,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC36,
                        [Stat.MinSC] = Settings.InstanceStageMinSC36,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC36,
                        [Stat.HP] = Settings.InstanceStageHP36,
                        [Stat.MP] = Settings.InstanceStageMP36,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage36,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage36,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction36,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate36,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate36,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy36,
                        [Stat.Agility] = Settings.InstanceStageAgility36,
                        [Stat.Freezing] = Settings.InstanceStageFreezing36,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack36,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist36,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist36,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery36,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery36,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery36,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate36,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage36,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate36,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate36,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate36,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate36,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate36,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate36,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate36,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain36,
                    };

                    int tempAttr36 = Settings.InstanceStageAttribute36;
                    if (tempAttr36 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr36 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr36);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage36, this, 0, InstanceStage36);
                    break;
                case 37:
                    var InstanceStage37 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC37,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC37,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC37,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC37,
                        [Stat.MinDC] = Settings.InstanceStageMinDC37,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC37,
                        [Stat.MinMC] = Settings.InstanceStageMinMC37,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC37,
                        [Stat.MinSC] = Settings.InstanceStageMinSC37,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC37,
                        [Stat.HP] = Settings.InstanceStageHP37,
                        [Stat.MP] = Settings.InstanceStageMP37,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage37,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage37,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction37,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate37,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate37,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy37,
                        [Stat.Agility] = Settings.InstanceStageAgility37,
                        [Stat.Freezing] = Settings.InstanceStageFreezing37,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack37,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist37,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist37,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery37,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery37,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery37,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate37,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage37,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate37,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate37,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate37,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate37,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate37,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate37,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate37,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain37,
                    };

                    int tempAttr37 = Settings.InstanceStageAttribute37;
                    if (tempAttr37 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr37 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr37);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage37, this, 0, InstanceStage37);
                    break;
                case 38:
                    var InstanceStage38 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC38,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC38,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC38,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC38,
                        [Stat.MinDC] = Settings.InstanceStageMinDC38,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC38,
                        [Stat.MinMC] = Settings.InstanceStageMinMC38,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC38,
                        [Stat.MinSC] = Settings.InstanceStageMinSC38,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC38,
                        [Stat.HP] = Settings.InstanceStageHP38,
                        [Stat.MP] = Settings.InstanceStageMP38,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage38,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage38,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction38,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate38,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate38,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy38,
                        [Stat.Agility] = Settings.InstanceStageAgility38,
                        [Stat.Freezing] = Settings.InstanceStageFreezing38,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack38,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist38,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist38,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery38,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery38,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery38,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate38,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage38,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate38,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate38,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate38,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate38,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate38,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate38,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate38,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain38,
                    };

                    int tempAttr38 = Settings.InstanceStageAttribute38;
                    if (tempAttr38 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr38 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr38);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage38, this, 0, InstanceStage38);
                    break;
                case 39:
                    var InstanceStage39 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC39,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC39,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC39,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC39,
                        [Stat.MinDC] = Settings.InstanceStageMinDC39,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC39,
                        [Stat.MinMC] = Settings.InstanceStageMinMC39,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC39,
                        [Stat.MinSC] = Settings.InstanceStageMinSC39,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC39,
                        [Stat.HP] = Settings.InstanceStageHP39,
                        [Stat.MP] = Settings.InstanceStageMP39,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage39,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage39,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction39,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate39,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate39,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy39,
                        [Stat.Agility] = Settings.InstanceStageAgility39,
                        [Stat.Freezing] = Settings.InstanceStageFreezing39,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack39,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist39,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist39,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery39,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery39,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery39,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate39,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage39,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate39,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate39,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate39,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate39,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate39,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate39,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate39,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain39,
                    };

                    int tempAttr39 = Settings.InstanceStageAttribute39;
                    if (tempAttr39 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr39 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr39);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage39, this, 0, InstanceStage39);
                    break;
                case 40:
                    var InstanceStage40 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC40,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC40,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC40,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC40,
                        [Stat.MinDC] = Settings.InstanceStageMinDC40,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC40,
                        [Stat.MinMC] = Settings.InstanceStageMinMC40,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC40,
                        [Stat.MinSC] = Settings.InstanceStageMinSC40,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC40,
                        [Stat.HP] = Settings.InstanceStageHP40,
                        [Stat.MP] = Settings.InstanceStageMP40,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage40,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage40,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction40,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate40,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate40,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy40,
                        [Stat.Agility] = Settings.InstanceStageAgility40,
                        [Stat.Freezing] = Settings.InstanceStageFreezing40,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack40,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist40,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist40,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery40,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery40,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery40,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate40,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage40,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate40,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate40,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate40,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate40,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate40,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate40,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate40,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain40,
                    };

                    int tempAttr40 = Settings.InstanceStageAttribute40;
                    if (tempAttr40 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr40 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr40);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage40, this, 0, InstanceStage40);
                    break;
                case 41:
                    var InstanceStage41 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC41,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC41,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC41,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC41,
                        [Stat.MinDC] = Settings.InstanceStageMinDC41,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC41,
                        [Stat.MinMC] = Settings.InstanceStageMinMC41,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC41,
                        [Stat.MinSC] = Settings.InstanceStageMinSC41,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC41,
                        [Stat.HP] = Settings.InstanceStageHP41,
                        [Stat.MP] = Settings.InstanceStageMP41,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage41,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage41,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction41,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate41,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate41,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy41,
                        [Stat.Agility] = Settings.InstanceStageAgility41,
                        [Stat.Freezing] = Settings.InstanceStageFreezing41,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack41,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist41,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist41,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery41,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery41,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery41,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate41,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage41,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate41,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate41,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate41,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate41,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate41,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate41,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate41,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain41,
                    };

                    int tempAttr41 = Settings.InstanceStageAttribute41;
                    if (tempAttr41 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr41 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr41);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage41, this, 0, InstanceStage41);
                    break;
                case 42:
                    var InstanceStage42 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC42,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC42,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC42,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC42,
                        [Stat.MinDC] = Settings.InstanceStageMinDC42,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC42,
                        [Stat.MinMC] = Settings.InstanceStageMinMC42,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC42,
                        [Stat.MinSC] = Settings.InstanceStageMinSC42,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC42,
                        [Stat.HP] = Settings.InstanceStageHP42,
                        [Stat.MP] = Settings.InstanceStageMP42,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage42,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage42,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction42,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate42,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate42,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy42,
                        [Stat.Agility] = Settings.InstanceStageAgility42,
                        [Stat.Freezing] = Settings.InstanceStageFreezing42,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack42,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist42,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist42,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery42,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery42,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery42,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate42,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage42,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate42,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate42,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate42,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate42,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate42,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate42,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate42,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain42,
                    };

                    int tempAttr42 = Settings.InstanceStageAttribute42;
                    if (tempAttr42 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr42 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr42);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage42, this, 0, InstanceStage42);
                    break;
                case 43:
                    var InstanceStage43 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC43,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC43,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC43,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC43,
                        [Stat.MinDC] = Settings.InstanceStageMinDC43,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC43,
                        [Stat.MinMC] = Settings.InstanceStageMinMC43,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC43,
                        [Stat.MinSC] = Settings.InstanceStageMinSC43,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC43,
                        [Stat.HP] = Settings.InstanceStageHP43,
                        [Stat.MP] = Settings.InstanceStageMP43,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage43,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage43,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction43,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate43,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate43,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy43,
                        [Stat.Agility] = Settings.InstanceStageAgility43,
                        [Stat.Freezing] = Settings.InstanceStageFreezing43,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack43,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist43,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist43,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery43,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery43,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery43,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate43,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage43,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate43,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate43,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate43,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate43,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate43,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate43,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate43,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain43,
                    };

                    int tempAttr43 = Settings.InstanceStageAttribute43;
                    if (tempAttr43 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr43 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr43);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage43, this, 0, InstanceStage43);
                    break;
                case 44:
                    var InstanceStage44 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC44,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC44,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC44,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC44,
                        [Stat.MinDC] = Settings.InstanceStageMinDC44,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC44,
                        [Stat.MinMC] = Settings.InstanceStageMinMC44,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC44,
                        [Stat.MinSC] = Settings.InstanceStageMinSC44,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC44,
                        [Stat.HP] = Settings.InstanceStageHP44,
                        [Stat.MP] = Settings.InstanceStageMP44,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage44,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage44,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction44,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate44,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate44,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy44,
                        [Stat.Agility] = Settings.InstanceStageAgility44,
                        [Stat.Freezing] = Settings.InstanceStageFreezing44,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack44,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist44,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist44,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery44,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery44,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery44,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate44,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage44,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate44,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate44,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate44,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate44,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate44,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate44,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate44,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain44,
                    };

                    int tempAttr44 = Settings.InstanceStageAttribute44;
                    if (tempAttr44 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr44 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr44);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage44, this, 0, InstanceStage44);
                    break;
                case 45:
                    var InstanceStage45 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC45,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC45,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC45,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC45,
                        [Stat.MinDC] = Settings.InstanceStageMinDC45,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC45,
                        [Stat.MinMC] = Settings.InstanceStageMinMC45,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC45,
                        [Stat.MinSC] = Settings.InstanceStageMinSC45,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC45,
                        [Stat.HP] = Settings.InstanceStageHP45,
                        [Stat.MP] = Settings.InstanceStageMP45,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage45,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage45,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction45,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate45,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate45,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy45,
                        [Stat.Agility] = Settings.InstanceStageAgility45,
                        [Stat.Freezing] = Settings.InstanceStageFreezing45,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack45,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist45,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist45,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery45,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery45,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery45,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate45,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage45,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate45,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate45,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate45,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate45,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate45,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate45,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate45,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain45,
                    };

                    int tempAttr45 = Settings.InstanceStageAttribute45;
                    if (tempAttr45 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr45 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr45);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage45, this, 0, InstanceStage45);
                    break;
                case 46:
                    var InstanceStage46 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC46,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC46,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC46,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC46,
                        [Stat.MinDC] = Settings.InstanceStageMinDC46,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC46,
                        [Stat.MinMC] = Settings.InstanceStageMinMC46,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC46,
                        [Stat.MinSC] = Settings.InstanceStageMinSC46,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC46,
                        [Stat.HP] = Settings.InstanceStageHP46,
                        [Stat.MP] = Settings.InstanceStageMP46,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage46,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage46,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction46,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate46,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate46,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy46,
                        [Stat.Agility] = Settings.InstanceStageAgility46,
                        [Stat.Freezing] = Settings.InstanceStageFreezing46,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack46,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist46,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist46,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery46,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery46,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery46,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate46,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage46,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate46,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate46,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate46,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate46,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate46,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate46,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate46,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain46,
                    };

                    int tempAttr46 = Settings.InstanceStageAttribute46;
                    if (tempAttr46 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr46 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr46);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage46, this, 0, InstanceStage46);
                    break;
                case 47:
                    var InstanceStage47 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC47,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC47,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC47,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC47,
                        [Stat.MinDC] = Settings.InstanceStageMinDC47,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC47,
                        [Stat.MinMC] = Settings.InstanceStageMinMC47,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC47,
                        [Stat.MinSC] = Settings.InstanceStageMinSC47,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC47,
                        [Stat.HP] = Settings.InstanceStageHP47,
                        [Stat.MP] = Settings.InstanceStageMP47,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage47,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage47,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction47,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate47,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate47,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy47,
                        [Stat.Agility] = Settings.InstanceStageAgility47,
                        [Stat.Freezing] = Settings.InstanceStageFreezing47,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack47,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist47,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist47,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery47,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery47,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery47,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate47,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage47,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate47,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate47,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate47,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate47,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate47,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate47,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate47,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain47,
                    };

                    int tempAttr47 = Settings.InstanceStageAttribute47;
                    if (tempAttr47 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr47 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr47);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage47, this, 0, InstanceStage47);
                    break;
                case 48:
                    var InstanceStage48 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC48,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC48,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC48,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC48,
                        [Stat.MinDC] = Settings.InstanceStageMinDC48,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC48,
                        [Stat.MinMC] = Settings.InstanceStageMinMC48,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC48,
                        [Stat.MinSC] = Settings.InstanceStageMinSC48,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC48,
                        [Stat.HP] = Settings.InstanceStageHP48,
                        [Stat.MP] = Settings.InstanceStageMP48,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage48,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage48,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction48,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate48,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate48,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy48,
                        [Stat.Agility] = Settings.InstanceStageAgility48,
                        [Stat.Freezing] = Settings.InstanceStageFreezing48,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack48,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist48,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist48,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery48,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery48,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery48,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate48,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage48,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate48,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate48,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate48,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate48,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate48,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate48,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate48,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain48,
                    };

                    int tempAttr48 = Settings.InstanceStageAttribute48;
                    if (tempAttr48 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr48 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr48);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage48, this, 0, InstanceStage48);
                    break;
                case 49:
                    var InstanceStage49 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC49,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC49,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC49,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC49,
                        [Stat.MinDC] = Settings.InstanceStageMinDC49,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC49,
                        [Stat.MinMC] = Settings.InstanceStageMinMC49,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC49,
                        [Stat.MinSC] = Settings.InstanceStageMinSC49,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC49,
                        [Stat.HP] = Settings.InstanceStageHP49,
                        [Stat.MP] = Settings.InstanceStageMP49,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage49,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage49,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction49,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate49,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate49,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy49,
                        [Stat.Agility] = Settings.InstanceStageAgility49,
                        [Stat.Freezing] = Settings.InstanceStageFreezing49,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack49,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist49,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist49,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery49,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery49,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery49,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate49,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage49,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate49,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate49,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate49,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate49,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate49,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate49,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate49,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain49,
                    };

                    int tempAttr49 = Settings.InstanceStageAttribute49;
                    if (tempAttr49 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr49 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr49);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage49, this, 0, InstanceStage49);
                    break;
                case 50:
                    var InstanceStage50 = new Stats
                    {
                        [Stat.MinAC] = Settings.InstanceStageMinAC50,
                        [Stat.MaxAC] = Settings.InstanceStageMaxAC50,
                        [Stat.MinMAC] = Settings.InstanceStageMinMAC50,
                        [Stat.MaxMAC] = Settings.InstanceStageMaxMAC50,
                        [Stat.MinDC] = Settings.InstanceStageMinDC50,
                        [Stat.MaxDC] = Settings.InstanceStageMaxDC50,
                        [Stat.MinMC] = Settings.InstanceStageMinMC50,
                        [Stat.MaxMC] = Settings.InstanceStageMaxMC50,
                        [Stat.MinSC] = Settings.InstanceStageMinSC50,
                        [Stat.MaxSC] = Settings.InstanceStageMaxSC50,
                        [Stat.HP] = Settings.InstanceStageHP50,
                        [Stat.MP] = Settings.InstanceStageMP50,
                        [Stat.PVEDamage] = Settings.InstanceStagePVEDamage50,
                        [Stat.PVPDamage] = Settings.InstanceStagePVPDamage50,
                        [Stat.DamageReductionPercent] = Settings.InstanceStageDamageReduction50,
                        [Stat.ExpRatePercent] = Settings.InstanceStageExpRate50,
                        [Stat.GoldDropRatePercent] = Settings.InstanceStageGoldRate50,
                        [Stat.Accuracy] = Settings.InstanceStageAccuracy50,
                        [Stat.Agility] = Settings.InstanceStageAgility50,
                        [Stat.Freezing] = Settings.InstanceStageFreezing50,
                        [Stat.PoisonAttack] = Settings.InstanceStagePoisonAttack50,
                        [Stat.MagicResist] = Settings.InstanceStageMagicResist50,
                        [Stat.PoisonResist] = Settings.InstanceStagePoisonResist50,
                        [Stat.HealthRecovery] = Settings.InstanceStageHealthRecovery50,
                        [Stat.SpellRecovery] = Settings.InstanceStageSpellRecovery50,
                        [Stat.PoisonRecovery] = Settings.InstanceStagePoisonRecovery50,
                        [Stat.CriticalRate] = Settings.InstanceStageCriticalRate50,
                        [Stat.CriticalDamage] = Settings.InstanceStageCriticalDamage50,
                        [Stat.MaxACRatePercent] = Settings.InstanceStageMaxACRate50,
                        [Stat.MaxMACRatePercent] = Settings.InstanceStageMaxMacRate50,
                        [Stat.MaxDCRatePercent] = Settings.InstanceStageMaxDCRate50,
                        [Stat.MaxMCRatePercent] = Settings.InstanceStageMaxMCRate50,
                        [Stat.MaxSCRatePercent] = Settings.InstanceStageMaxSCRate50,
                        [Stat.HPRatePercent] = Settings.InstanceStageHPRate50,
                        [Stat.MPRatePercent] = Settings.InstanceStageMPRate50,
                        [Stat.HPDrainRatePercent] = Settings.InstanceStageHPDrain50,
                    };

                    int tempAttr50 = Settings.InstanceStageAttribute50;
                    if (tempAttr50 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr50 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr50);

                    RemoveBuff(BuffType.InstanceStage1);
                    RemoveBuff(BuffType.InstanceStage2);
                    RemoveBuff(BuffType.InstanceStage3);
                    RemoveBuff(BuffType.InstanceStage4);
                    RemoveBuff(BuffType.InstanceStage5);
                    RemoveBuff(BuffType.InstanceStage6);
                    RemoveBuff(BuffType.InstanceStage7);
                    RemoveBuff(BuffType.InstanceStage8);
                    RemoveBuff(BuffType.InstanceStage9);
                    RemoveBuff(BuffType.InstanceStage10);
                    RemoveBuff(BuffType.InstanceStage11);
                    RemoveBuff(BuffType.InstanceStage12);
                    RemoveBuff(BuffType.InstanceStage13);
                    RemoveBuff(BuffType.InstanceStage14);
                    RemoveBuff(BuffType.InstanceStage15);
                    RemoveBuff(BuffType.InstanceStage16);
                    RemoveBuff(BuffType.InstanceStage17);
                    RemoveBuff(BuffType.InstanceStage18);
                    RemoveBuff(BuffType.InstanceStage19);
                    RemoveBuff(BuffType.InstanceStage20);
                    RemoveBuff(BuffType.InstanceStage21);
                    RemoveBuff(BuffType.InstanceStage22);
                    RemoveBuff(BuffType.InstanceStage23);
                    RemoveBuff(BuffType.InstanceStage24);
                    RemoveBuff(BuffType.InstanceStage25);
                    RemoveBuff(BuffType.InstanceStage26);
                    RemoveBuff(BuffType.InstanceStage27);
                    RemoveBuff(BuffType.InstanceStage28);
                    RemoveBuff(BuffType.InstanceStage29);
                    RemoveBuff(BuffType.InstanceStage30);
                    RemoveBuff(BuffType.InstanceStage31);
                    RemoveBuff(BuffType.InstanceStage32);
                    RemoveBuff(BuffType.InstanceStage33);
                    RemoveBuff(BuffType.InstanceStage34);
                    RemoveBuff(BuffType.InstanceStage35);
                    RemoveBuff(BuffType.InstanceStage36);
                    RemoveBuff(BuffType.InstanceStage37);
                    RemoveBuff(BuffType.InstanceStage38);
                    RemoveBuff(BuffType.InstanceStage39);
                    RemoveBuff(BuffType.InstanceStage40);
                    RemoveBuff(BuffType.InstanceStage41);
                    RemoveBuff(BuffType.InstanceStage42);
                    RemoveBuff(BuffType.InstanceStage43);
                    RemoveBuff(BuffType.InstanceStage44);
                    RemoveBuff(BuffType.InstanceStage45);
                    RemoveBuff(BuffType.InstanceStage46);
                    RemoveBuff(BuffType.InstanceStage47);
                    RemoveBuff(BuffType.InstanceStage48);
                    RemoveBuff(BuffType.InstanceStage49);
                    RemoveBuff(BuffType.InstanceStage50);
                    AddBuff(BuffType.InstanceStage50, this, 0, InstanceStage50);
                    break;
            }
        }
        private void UpdateChallengeStageBuff()
        {
            switch (ChallengeStage)
            {
                case 0:
                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    break;
                case 1:
                    var ChallengeStage1 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC1,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC1,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC1,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC1,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC1,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC1,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC1,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC1,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC1,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC1,
                        [Stat.HP] = Settings.ChallengeStageHP1,
                        [Stat.MP] = Settings.ChallengeStageMP1,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage1,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage1,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction1,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate1,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate1,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy1,
                        [Stat.Agility] = Settings.ChallengeStageAgility1,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing1,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack1,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist1,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist1,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery1,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery1,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery1,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate1,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage1,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate1,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate1,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate1,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate1,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate1,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate1,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate1,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain1,
                    };

                    int tempAttr1 = Settings.ChallengeStageAttribute1;
                    if (tempAttr1 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr1 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr1);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage1, this, 0, ChallengeStage1);
                    break;
                case 2:
                    var ChallengeStage2 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC2,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC2,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC2,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC2,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC2,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC2,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC2,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC2,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC2,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC2,
                        [Stat.HP] = Settings.ChallengeStageHP2,
                        [Stat.MP] = Settings.ChallengeStageMP2,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage2,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage2,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction2,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate2,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate2,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy2,
                        [Stat.Agility] = Settings.ChallengeStageAgility2,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing2,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack2,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist2,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist2,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery2,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery2,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery2,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate2,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage2,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate2,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate2,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate2,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate2,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate2,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate2,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate2,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain2,
                    };

                    int tempAttr2 = Settings.ChallengeStageAttribute2;
                    if (tempAttr2 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr2 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr2);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage2, this, 0, ChallengeStage2);
                    break;
                case 3:
                    var ChallengeStage3 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC3,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC3,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC3,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC3,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC3,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC3,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC3,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC3,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC3,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC3,
                        [Stat.HP] = Settings.ChallengeStageHP3,
                        [Stat.MP] = Settings.ChallengeStageMP3,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage3,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage3,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction3,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate3,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate3,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy3,
                        [Stat.Agility] = Settings.ChallengeStageAgility3,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing3,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack3,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist3,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist3,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery3,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery3,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery3,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate3,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage3,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate3,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate3,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate3,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate3,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate3,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate3,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate3,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain3,
                    };

                    int tempAttr3 = Settings.ChallengeStageAttribute3;
                    if (tempAttr3 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr3 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr3);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage3, this, 0, ChallengeStage3);
                    break;
                case 4:
                    var ChallengeStage4 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC4,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC4,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC4,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC4,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC4,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC4,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC4,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC4,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC4,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC4,
                        [Stat.HP] = Settings.ChallengeStageHP4,
                        [Stat.MP] = Settings.ChallengeStageMP4,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage4,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage4,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction4,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate4,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate4,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy4,
                        [Stat.Agility] = Settings.ChallengeStageAgility4,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing4,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack4,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist4,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist4,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery4,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery4,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery4,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate4,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage4,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate4,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate4,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate4,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate4,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate4,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate4,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate4,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain4,
                    };

                    int tempAttr4 = Settings.ChallengeStageAttribute4;
                    if (tempAttr4 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr4 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr4);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage4, this, 0, ChallengeStage4);
                    break;
                case 5:
                    var ChallengeStage5 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC5,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC5,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC5,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC5,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC5,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC5,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC5,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC5,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC5,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC5,
                        [Stat.HP] = Settings.ChallengeStageHP5,
                        [Stat.MP] = Settings.ChallengeStageMP5,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage5,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage5,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction5,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate5,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate5,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy5,
                        [Stat.Agility] = Settings.ChallengeStageAgility5,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing5,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack5,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist5,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist5,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery5,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery5,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery5,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate5,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage5,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate5,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate5,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate5,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate5,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate5,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate5,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate5,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain5,
                    };

                    int tempAttr5 = Settings.ChallengeStageAttribute5;
                    if (tempAttr5 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr5 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr5);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage5, this, 0, ChallengeStage5);
                    break;
                case 6:
                    var ChallengeStage6 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC6,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC6,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC6,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC6,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC6,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC6,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC6,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC6,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC6,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC6,
                        [Stat.HP] = Settings.ChallengeStageHP6,
                        [Stat.MP] = Settings.ChallengeStageMP6,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage6,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage6,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction6,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate6,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate6,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy6,
                        [Stat.Agility] = Settings.ChallengeStageAgility6,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing6,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack6,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist6,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist6,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery6,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery6,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery6,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate6,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage6,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate6,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate6,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate6,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate6,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate6,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate6,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate6,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain6,
                    };

                    int tempAttr6 = Settings.ChallengeStageAttribute6;
                    if (tempAttr6 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr6 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr6);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage6, this, 0, ChallengeStage6);
                    break;
                case 7:
                    var ChallengeStage7 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC7,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC7,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC7,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC7,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC7,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC7,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC7,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC7,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC7,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC7,
                        [Stat.HP] = Settings.ChallengeStageHP7,
                        [Stat.MP] = Settings.ChallengeStageMP7,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage7,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage7,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction7,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate7,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate7,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy7,
                        [Stat.Agility] = Settings.ChallengeStageAgility7,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing7,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack7,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist7,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist7,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery7,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery7,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery7,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate7,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage7,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate7,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate7,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate7,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate7,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate7,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate7,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate7,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain7,
                    };

                    int tempAttr7 = Settings.ChallengeStageAttribute7;
                    if (tempAttr7 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr7 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr7);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage7, this, 0, ChallengeStage7);
                    break;
                case 8:
                    var ChallengeStage8 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC8,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC8,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC8,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC8,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC8,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC8,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC8,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC8,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC8,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC8,
                        [Stat.HP] = Settings.ChallengeStageHP8,
                        [Stat.MP] = Settings.ChallengeStageMP8,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage8,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage8,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction8,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate8,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate8,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy8,
                        [Stat.Agility] = Settings.ChallengeStageAgility8,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing8,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack8,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist8,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist8,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery8,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery8,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery8,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate8,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage8,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate8,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate8,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate8,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate8,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate8,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate8,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate8,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain8,
                    };

                    int tempAttr8 = Settings.ChallengeStageAttribute8;
                    if (tempAttr8 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr8 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr8);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage8, this, 0, ChallengeStage8);
                    break;
                case 9:
                    var ChallengeStage9 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC9,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC9,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC9,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC9,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC9,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC9,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC9,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC9,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC9,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC9,
                        [Stat.HP] = Settings.ChallengeStageHP9,
                        [Stat.MP] = Settings.ChallengeStageMP9,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage9,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage9,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction9,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate9,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate9,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy9,
                        [Stat.Agility] = Settings.ChallengeStageAgility9,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing9,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack9,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist9,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist9,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery9,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery9,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery9,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate9,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage9,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate9,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate9,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate9,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate9,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate9,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate9,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate9,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain9,
                    };

                    int tempAttr9 = Settings.ChallengeStageAttribute9;
                    if (tempAttr9 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr9 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr9);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage9, this, 0, ChallengeStage9);
                    break;
                case 10:
                    var ChallengeStage10 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC10,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC10,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC10,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC10,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC10,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC10,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC10,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC10,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC10,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC10,
                        [Stat.HP] = Settings.ChallengeStageHP10,
                        [Stat.MP] = Settings.ChallengeStageMP10,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage10,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage10,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction10,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate10,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate10,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy10,
                        [Stat.Agility] = Settings.ChallengeStageAgility10,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing10,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack10,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist10,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist10,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery10,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery10,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery10,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate10,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage10,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate10,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate10,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate10,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate10,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate10,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate10,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate10,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain10,
                    };

                    int tempAttr10 = Settings.ChallengeStageAttribute10;
                    if (tempAttr10 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr10 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr10);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage10, this, 0, ChallengeStage10);
                    break;
                case 11:
                    var ChallengeStage11 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC11,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC11,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC11,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC11,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC11,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC11,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC11,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC11,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC11,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC11,
                        [Stat.HP] = Settings.ChallengeStageHP11,
                        [Stat.MP] = Settings.ChallengeStageMP11,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage11,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage11,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction11,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate11,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate11,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy11,
                        [Stat.Agility] = Settings.ChallengeStageAgility11,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing11,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack11,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist11,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist11,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery11,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery11,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery11,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate11,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage11,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate11,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate11,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate11,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate11,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate11,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate11,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate11,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain11,
                    };

                    int tempAttr11 = Settings.ChallengeStageAttribute11;
                    if (tempAttr11 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr11 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr11);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage11, this, 0, ChallengeStage11);
                    break;
                case 12:
                    var ChallengeStage12 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC12,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC12,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC12,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC12,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC12,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC12,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC12,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC12,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC12,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC12,
                        [Stat.HP] = Settings.ChallengeStageHP12,
                        [Stat.MP] = Settings.ChallengeStageMP12,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage12,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage12,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction12,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate12,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate12,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy12,
                        [Stat.Agility] = Settings.ChallengeStageAgility12,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing12,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack12,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist12,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist12,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery12,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery12,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery12,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate12,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage12,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate12,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate12,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate12,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate12,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate12,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate12,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate12,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain12,
                    };

                    int tempAttr12 = Settings.ChallengeStageAttribute12;
                    if (tempAttr12 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr12 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr12);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage12, this, 0, ChallengeStage12);
                    break;
                case 13:
                    var ChallengeStage13 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC13,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC13,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC13,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC13,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC13,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC13,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC13,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC13,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC13,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC13,
                        [Stat.HP] = Settings.ChallengeStageHP13,
                        [Stat.MP] = Settings.ChallengeStageMP13,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage13,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage13,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction13,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate13,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate13,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy13,
                        [Stat.Agility] = Settings.ChallengeStageAgility13,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing13,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack13,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist13,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist13,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery13,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery13,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery13,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate13,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage13,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate13,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate13,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate13,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate13,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate13,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate13,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate13,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain13,
                    };

                    int tempAttr13 = Settings.ChallengeStageAttribute13;
                    if (tempAttr13 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr13 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr13);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage13, this, 0, ChallengeStage13);
                    break;
                case 14:
                    var ChallengeStage14 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC14,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC14,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC14,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC14,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC14,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC14,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC14,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC14,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC14,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC14,
                        [Stat.HP] = Settings.ChallengeStageHP14,
                        [Stat.MP] = Settings.ChallengeStageMP14,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage14,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage14,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction14,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate14,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate14,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy14,
                        [Stat.Agility] = Settings.ChallengeStageAgility14,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing14,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack14,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist14,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist14,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery14,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery14,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery14,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate14,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage14,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate14,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate14,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate14,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate14,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate14,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate14,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate14,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain14,
                    };

                    int tempAttr14 = Settings.ChallengeStageAttribute14;
                    if (tempAttr14 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr14 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr14);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage14, this, 0, ChallengeStage14);
                    break;
                case 15:
                    var ChallengeStage15 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC15,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC15,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC15,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC15,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC15,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC15,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC15,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC15,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC15,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC15,
                        [Stat.HP] = Settings.ChallengeStageHP15,
                        [Stat.MP] = Settings.ChallengeStageMP15,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage15,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage15,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction15,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate15,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate15,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy15,
                        [Stat.Agility] = Settings.ChallengeStageAgility15,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing15,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack15,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist15,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist15,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery15,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery15,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery15,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate15,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage15,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate15,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate15,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate15,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate15,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate15,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate15,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate15,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain15,
                    };

                    int tempAttr15 = Settings.ChallengeStageAttribute15;
                    if (tempAttr15 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr15 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr15);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage15, this, 0, ChallengeStage15);
                    break;
                case 16:
                    var ChallengeStage16 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC16,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC16,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC16,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC16,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC16,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC16,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC16,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC16,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC16,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC16,
                        [Stat.HP] = Settings.ChallengeStageHP16,
                        [Stat.MP] = Settings.ChallengeStageMP16,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage16,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage16,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction16,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate16,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate16,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy16,
                        [Stat.Agility] = Settings.ChallengeStageAgility16,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing16,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack16,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist16,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist16,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery16,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery16,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery16,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate16,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage16,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate16,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate16,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate16,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate16,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate16,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate16,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate16,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain16,
                    };

                    int tempAttr16 = Settings.ChallengeStageAttribute16;
                    if (tempAttr16 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr16 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr16);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage16, this, 0, ChallengeStage16);
                    break;
                case 17:
                    var ChallengeStage17 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC17,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC17,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC17,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC17,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC17,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC17,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC17,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC17,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC17,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC17,
                        [Stat.HP] = Settings.ChallengeStageHP17,
                        [Stat.MP] = Settings.ChallengeStageMP17,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage17,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage17,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction17,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate17,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate17,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy17,
                        [Stat.Agility] = Settings.ChallengeStageAgility17,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing17,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack17,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist17,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist17,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery17,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery17,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery17,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate17,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage17,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate17,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate17,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate17,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate17,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate17,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate17,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate17,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain17,
                    };

                    int tempAttr17 = Settings.ChallengeStageAttribute17;
                    if (tempAttr17 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr17 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr17);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage17, this, 0, ChallengeStage17);
                    break;
                case 18:
                    var ChallengeStage18 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC18,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC18,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC18,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC18,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC18,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC18,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC18,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC18,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC18,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC18,
                        [Stat.HP] = Settings.ChallengeStageHP18,
                        [Stat.MP] = Settings.ChallengeStageMP18,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage18,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage18,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction18,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate18,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate18,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy18,
                        [Stat.Agility] = Settings.ChallengeStageAgility18,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing18,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack18,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist18,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist18,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery18,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery18,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery18,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate18,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage18,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate18,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate18,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate18,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate18,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate18,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate18,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate18,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain18,
                    };

                    int tempAttr18 = Settings.ChallengeStageAttribute18;
                    if (tempAttr18 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr18 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr18);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage18, this, 0, ChallengeStage18);
                    break;
                case 19:
                    var ChallengeStage19 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC19,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC19,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC19,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC19,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC19,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC19,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC19,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC19,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC19,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC19,
                        [Stat.HP] = Settings.ChallengeStageHP19,
                        [Stat.MP] = Settings.ChallengeStageMP19,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage19,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage19,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction19,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate19,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate19,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy19,
                        [Stat.Agility] = Settings.ChallengeStageAgility19,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing19,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack19,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist19,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist19,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery19,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery19,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery19,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate19,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage19,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate19,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate19,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate19,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate19,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate19,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate19,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate19,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain19,
                    };

                    int tempAttr19 = Settings.ChallengeStageAttribute19;
                    if (tempAttr19 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr19 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr19);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage19, this, 0, ChallengeStage19);
                    break;
                case 20:
                    var ChallengeStage20 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC20,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC20,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC20,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC20,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC20,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC20,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC20,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC20,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC20,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC20,
                        [Stat.HP] = Settings.ChallengeStageHP20,
                        [Stat.MP] = Settings.ChallengeStageMP20,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage20,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage20,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction20,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate20,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate20,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy20,
                        [Stat.Agility] = Settings.ChallengeStageAgility20,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing20,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack20,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist20,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist20,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery20,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery20,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery20,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate20,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage20,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate20,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate20,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate20,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate20,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate20,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate20,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate20,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain20,
                    };

                    int tempAttr20 = Settings.ChallengeStageAttribute20;
                    if (tempAttr20 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr20 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr20);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage20, this, 0, ChallengeStage20);
                    break;
                case 21:
                    var ChallengeStage21 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC21,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC21,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC21,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC21,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC21,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC21,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC21,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC21,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC21,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC21,
                        [Stat.HP] = Settings.ChallengeStageHP21,
                        [Stat.MP] = Settings.ChallengeStageMP21,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage21,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage21,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction21,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate21,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate21,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy21,
                        [Stat.Agility] = Settings.ChallengeStageAgility21,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing21,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack21,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist21,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist21,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery21,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery21,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery21,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate21,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage21,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate21,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate21,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate21,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate21,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate21,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate21,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate21,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain21,
                    };

                    int tempAttr21 = Settings.ChallengeStageAttribute21;
                    if (tempAttr21 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr21 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr21);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage21, this, 0, ChallengeStage21);
                    break;
                case 22:
                    var ChallengeStage22 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC22,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC22,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC22,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC22,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC22,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC22,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC22,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC22,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC22,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC22,
                        [Stat.HP] = Settings.ChallengeStageHP22,
                        [Stat.MP] = Settings.ChallengeStageMP22,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage22,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage22,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction22,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate22,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate22,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy22,
                        [Stat.Agility] = Settings.ChallengeStageAgility22,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing22,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack22,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist22,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist22,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery22,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery22,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery22,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate22,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage22,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate22,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate22,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate22,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate22,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate22,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate22,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate22,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain22,
                    };

                    int tempAttr22 = Settings.ChallengeStageAttribute22;
                    if (tempAttr22 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr22 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr22);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage22, this, 0, ChallengeStage22);
                    break;
                case 23:
                    var ChallengeStage23 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC23,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC23,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC23,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC23,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC23,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC23,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC23,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC23,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC23,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC23,
                        [Stat.HP] = Settings.ChallengeStageHP23,
                        [Stat.MP] = Settings.ChallengeStageMP23,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage23,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage23,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction23,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate23,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate23,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy23,
                        [Stat.Agility] = Settings.ChallengeStageAgility23,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing23,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack23,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist23,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist23,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery23,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery23,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery23,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate23,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage23,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate23,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate23,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate23,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate23,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate23,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate23,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate23,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain23,
                    };

                    int tempAttr23 = Settings.ChallengeStageAttribute23;
                    if (tempAttr23 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr23 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr23);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage23, this, 0, ChallengeStage23);
                    break;
                case 24:
                    var ChallengeStage24 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC24,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC24,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC24,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC24,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC24,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC24,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC24,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC24,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC24,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC24,
                        [Stat.HP] = Settings.ChallengeStageHP24,
                        [Stat.MP] = Settings.ChallengeStageMP24,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage24,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage24,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction24,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate24,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate24,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy24,
                        [Stat.Agility] = Settings.ChallengeStageAgility24,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing24,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack24,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist24,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist24,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery24,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery24,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery24,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate24,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage24,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate24,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate24,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate24,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate24,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate24,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate24,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate24,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain24,
                    };

                    int tempAttr24 = Settings.ChallengeStageAttribute24;
                    if (tempAttr24 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr24 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr24);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage24, this, 0, ChallengeStage24);
                    break;
                case 25:
                    var ChallengeStage25 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC25,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC25,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC25,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC25,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC25,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC25,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC25,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC25,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC25,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC25,
                        [Stat.HP] = Settings.ChallengeStageHP25,
                        [Stat.MP] = Settings.ChallengeStageMP25,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage25,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage25,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction25,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate25,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate25,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy25,
                        [Stat.Agility] = Settings.ChallengeStageAgility25,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing25,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack25,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist25,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist25,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery25,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery25,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery25,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate25,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage25,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate25,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate25,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate25,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate25,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate25,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate25,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate25,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain25,
                    };

                    int tempAttr25 = Settings.ChallengeStageAttribute25;
                    if (tempAttr25 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr25 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr25);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage25, this, 0, ChallengeStage25);
                    break;
                case 26:
                    var ChallengeStage26 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC26,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC26,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC26,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC26,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC26,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC26,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC26,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC26,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC26,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC26,
                        [Stat.HP] = Settings.ChallengeStageHP26,
                        [Stat.MP] = Settings.ChallengeStageMP26,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage26,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage26,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction26,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate26,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate26,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy26,
                        [Stat.Agility] = Settings.ChallengeStageAgility26,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing26,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack26,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist26,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist26,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery26,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery26,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery26,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate26,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage26,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate26,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate26,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate26,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate26,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate26,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate26,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate26,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain26,
                    };

                    int tempAttr26 = Settings.ChallengeStageAttribute26;
                    if (tempAttr26 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr26 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr26);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage26, this, 0, ChallengeStage26);
                    break;
                case 27:
                    var ChallengeStage27 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC27,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC27,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC27,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC27,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC27,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC27,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC27,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC27,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC27,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC27,
                        [Stat.HP] = Settings.ChallengeStageHP27,
                        [Stat.MP] = Settings.ChallengeStageMP27,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage27,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage27,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction27,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate27,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate27,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy27,
                        [Stat.Agility] = Settings.ChallengeStageAgility27,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing27,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack27,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist27,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist27,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery27,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery27,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery27,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate27,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage27,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate27,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate27,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate27,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate27,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate27,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate27,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate27,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain27,
                    };

                    int tempAttr27 = Settings.ChallengeStageAttribute27;
                    if (tempAttr27 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr27 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr27);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage27, this, 0, ChallengeStage27);
                    break;
                case 28:
                    var ChallengeStage28 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC28,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC28,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC28,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC28,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC28,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC28,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC28,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC28,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC28,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC28,
                        [Stat.HP] = Settings.ChallengeStageHP28,
                        [Stat.MP] = Settings.ChallengeStageMP28,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage28,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage28,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction28,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate28,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate28,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy28,
                        [Stat.Agility] = Settings.ChallengeStageAgility28,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing28,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack28,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist28,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist28,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery28,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery28,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery28,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate28,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage28,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate28,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate28,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate28,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate28,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate28,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate28,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate28,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain28,
                    };

                    int tempAttr28 = Settings.ChallengeStageAttribute28;
                    if (tempAttr28 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr28 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr28);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage28, this, 0, ChallengeStage28);
                    break;
                case 29:
                    var ChallengeStage29 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC29,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC29,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC29,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC29,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC29,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC29,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC29,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC29,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC29,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC29,
                        [Stat.HP] = Settings.ChallengeStageHP29,
                        [Stat.MP] = Settings.ChallengeStageMP29,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage29,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage29,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction29,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate29,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate29,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy29,
                        [Stat.Agility] = Settings.ChallengeStageAgility29,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing29,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack29,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist29,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist29,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery29,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery29,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery29,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate29,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage29,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate29,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate29,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate29,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate29,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate29,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate29,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate29,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain29,
                    };

                    int tempAttr29 = Settings.ChallengeStageAttribute29;
                    if (tempAttr29 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr29 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr29);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage29, this, 0, ChallengeStage29);
                    break;
                case 30:
                    var ChallengeStage30 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC30,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC30,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC30,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC30,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC30,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC30,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC30,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC30,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC30,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC30,
                        [Stat.HP] = Settings.ChallengeStageHP30,
                        [Stat.MP] = Settings.ChallengeStageMP30,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage30,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage30,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction30,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate30,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate30,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy30,
                        [Stat.Agility] = Settings.ChallengeStageAgility30,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing30,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack30,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist30,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist30,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery30,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery30,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery30,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate30,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage30,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate30,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate30,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate30,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate30,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate30,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate30,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate30,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain30,
                    };

                    int tempAttr30 = Settings.ChallengeStageAttribute30;
                    if (tempAttr30 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr30 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr30);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage30, this, 0, ChallengeStage30);
                    break;
                case 31:
                    var ChallengeStage31 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC31,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC31,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC31,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC31,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC31,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC31,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC31,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC31,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC31,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC31,
                        [Stat.HP] = Settings.ChallengeStageHP31,
                        [Stat.MP] = Settings.ChallengeStageMP31,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage31,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage31,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction31,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate31,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate31,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy31,
                        [Stat.Agility] = Settings.ChallengeStageAgility31,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing31,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack31,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist31,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist31,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery31,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery31,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery31,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate31,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage31,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate31,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate31,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate31,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate31,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate31,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate31,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate31,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain31,
                    };

                    int tempAttr31 = Settings.ChallengeStageAttribute31;
                    if (tempAttr31 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr31 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr31);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage31, this, 0, ChallengeStage31);
                    break;
                case 32:
                    var ChallengeStage32 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC32,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC32,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC32,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC32,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC32,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC32,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC32,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC32,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC32,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC32,
                        [Stat.HP] = Settings.ChallengeStageHP32,
                        [Stat.MP] = Settings.ChallengeStageMP32,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage32,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage32,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction32,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate32,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate32,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy32,
                        [Stat.Agility] = Settings.ChallengeStageAgility32,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing32,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack32,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist32,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist32,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery32,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery32,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery32,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate32,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage32,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate32,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate32,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate32,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate32,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate32,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate32,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate32,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain32,
                    };

                    int tempAttr32 = Settings.ChallengeStageAttribute32;
                    if (tempAttr32 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr32 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr32);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage32, this, 0, ChallengeStage32);
                    break;
                case 33:
                    var ChallengeStage33 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC33,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC33,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC33,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC33,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC33,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC33,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC33,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC33,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC33,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC33,
                        [Stat.HP] = Settings.ChallengeStageHP33,
                        [Stat.MP] = Settings.ChallengeStageMP33,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage33,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage33,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction33,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate33,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate33,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy33,
                        [Stat.Agility] = Settings.ChallengeStageAgility33,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing33,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack33,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist33,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist33,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery33,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery33,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery33,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate33,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage33,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate33,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate33,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate33,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate33,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate33,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate33,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate33,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain33,
                    };

                    int tempAttr33 = Settings.ChallengeStageAttribute33;
                    if (tempAttr33 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr33 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr33);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage33, this, 0, ChallengeStage33);
                    break;
                case 34:
                    var ChallengeStage34 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC34,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC34,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC34,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC34,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC34,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC34,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC34,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC34,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC34,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC34,
                        [Stat.HP] = Settings.ChallengeStageHP34,
                        [Stat.MP] = Settings.ChallengeStageMP34,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage34,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage34,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction34,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate34,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate34,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy34,
                        [Stat.Agility] = Settings.ChallengeStageAgility34,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing34,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack34,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist34,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist34,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery34,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery34,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery34,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate34,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage34,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate34,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate34,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate34,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate34,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate34,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate34,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate34,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain34,
                    };

                    int tempAttr34 = Settings.ChallengeStageAttribute34;
                    if (tempAttr34 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr34 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr34);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage34, this, 0, ChallengeStage34);
                    break;
                case 35:
                    var ChallengeStage35 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC35,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC35,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC35,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC35,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC35,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC35,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC35,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC35,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC35,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC35,
                        [Stat.HP] = Settings.ChallengeStageHP35,
                        [Stat.MP] = Settings.ChallengeStageMP35,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage35,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage35,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction35,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate35,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate35,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy35,
                        [Stat.Agility] = Settings.ChallengeStageAgility35,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing35,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack35,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist35,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist35,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery35,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery35,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery35,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate35,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage35,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate35,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate35,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate35,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate35,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate35,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate35,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate35,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain35,
                    };

                    int tempAttr35 = Settings.ChallengeStageAttribute35;
                    if (tempAttr35 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr35 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr35);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage35, this, 0, ChallengeStage35);
                    break;
                case 36:
                    var ChallengeStage36 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC36,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC36,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC36,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC36,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC36,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC36,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC36,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC36,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC36,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC36,
                        [Stat.HP] = Settings.ChallengeStageHP36,
                        [Stat.MP] = Settings.ChallengeStageMP36,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage36,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage36,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction36,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate36,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate36,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy36,
                        [Stat.Agility] = Settings.ChallengeStageAgility36,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing36,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack36,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist36,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist36,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery36,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery36,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery36,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate36,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage36,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate36,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate36,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate36,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate36,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate36,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate36,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate36,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain36,
                    };

                    int tempAttr36 = Settings.ChallengeStageAttribute36;
                    if (tempAttr36 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr36 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr36);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage36, this, 0, ChallengeStage36);
                    break;
                case 37:
                    var ChallengeStage37 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC37,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC37,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC37,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC37,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC37,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC37,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC37,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC37,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC37,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC37,
                        [Stat.HP] = Settings.ChallengeStageHP37,
                        [Stat.MP] = Settings.ChallengeStageMP37,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage37,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage37,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction37,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate37,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate37,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy37,
                        [Stat.Agility] = Settings.ChallengeStageAgility37,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing37,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack37,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist37,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist37,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery37,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery37,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery37,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate37,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage37,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate37,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate37,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate37,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate37,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate37,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate37,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate37,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain37,
                    };

                    int tempAttr37 = Settings.ChallengeStageAttribute37;
                    if (tempAttr37 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr37 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr37);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage37, this, 0, ChallengeStage37);
                    break;
                case 38:
                    var ChallengeStage38 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC38,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC38,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC38,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC38,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC38,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC38,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC38,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC38,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC38,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC38,
                        [Stat.HP] = Settings.ChallengeStageHP38,
                        [Stat.MP] = Settings.ChallengeStageMP38,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage38,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage38,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction38,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate38,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate38,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy38,
                        [Stat.Agility] = Settings.ChallengeStageAgility38,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing38,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack38,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist38,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist38,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery38,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery38,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery38,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate38,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage38,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate38,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate38,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate38,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate38,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate38,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate38,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate38,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain38,
                    };

                    int tempAttr38 = Settings.ChallengeStageAttribute38;
                    if (tempAttr38 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr38 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr38);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage38, this, 0, ChallengeStage38);
                    break;
                case 39:
                    var ChallengeStage39 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC39,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC39,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC39,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC39,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC39,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC39,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC39,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC39,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC39,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC39,
                        [Stat.HP] = Settings.ChallengeStageHP39,
                        [Stat.MP] = Settings.ChallengeStageMP39,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage39,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage39,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction39,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate39,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate39,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy39,
                        [Stat.Agility] = Settings.ChallengeStageAgility39,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing39,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack39,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist39,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist39,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery39,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery39,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery39,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate39,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage39,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate39,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate39,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate39,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate39,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate39,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate39,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate39,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain39,
                    };

                    int tempAttr39 = Settings.ChallengeStageAttribute39;
                    if (tempAttr39 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr39 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr39);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage39, this, 0, ChallengeStage39);
                    break;
                case 40:
                    var ChallengeStage40 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC40,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC40,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC40,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC40,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC40,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC40,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC40,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC40,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC40,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC40,
                        [Stat.HP] = Settings.ChallengeStageHP40,
                        [Stat.MP] = Settings.ChallengeStageMP40,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage40,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage40,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction40,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate40,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate40,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy40,
                        [Stat.Agility] = Settings.ChallengeStageAgility40,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing40,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack40,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist40,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist40,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery40,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery40,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery40,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate40,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage40,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate40,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate40,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate40,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate40,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate40,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate40,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate40,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain40,
                    };

                    int tempAttr40 = Settings.ChallengeStageAttribute40;
                    if (tempAttr40 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr40 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr40);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage40, this, 0, ChallengeStage40);
                    break;
                case 41:
                    var ChallengeStage41 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC41,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC41,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC41,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC41,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC41,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC41,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC41,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC41,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC41,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC41,
                        [Stat.HP] = Settings.ChallengeStageHP41,
                        [Stat.MP] = Settings.ChallengeStageMP41,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage41,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage41,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction41,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate41,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate41,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy41,
                        [Stat.Agility] = Settings.ChallengeStageAgility41,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing41,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack41,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist41,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist41,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery41,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery41,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery41,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate41,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage41,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate41,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate41,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate41,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate41,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate41,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate41,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate41,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain41,
                    };

                    int tempAttr41 = Settings.ChallengeStageAttribute41;
                    if (tempAttr41 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr41 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr41);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage41, this, 0, ChallengeStage41);
                    break;
                case 42:
                    var ChallengeStage42 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC42,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC42,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC42,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC42,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC42,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC42,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC42,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC42,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC42,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC42,
                        [Stat.HP] = Settings.ChallengeStageHP42,
                        [Stat.MP] = Settings.ChallengeStageMP42,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage42,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage42,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction42,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate42,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate42,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy42,
                        [Stat.Agility] = Settings.ChallengeStageAgility42,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing42,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack42,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist42,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist42,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery42,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery42,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery42,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate42,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage42,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate42,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate42,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate42,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate42,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate42,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate42,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate42,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain42,
                    };

                    int tempAttr42 = Settings.ChallengeStageAttribute42;
                    if (tempAttr42 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr42 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr42);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage42, this, 0, ChallengeStage42);
                    break;
                case 43:
                    var ChallengeStage43 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC43,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC43,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC43,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC43,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC43,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC43,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC43,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC43,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC43,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC43,
                        [Stat.HP] = Settings.ChallengeStageHP43,
                        [Stat.MP] = Settings.ChallengeStageMP43,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage43,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage43,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction43,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate43,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate43,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy43,
                        [Stat.Agility] = Settings.ChallengeStageAgility43,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing43,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack43,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist43,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist43,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery43,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery43,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery43,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate43,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage43,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate43,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate43,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate43,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate43,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate43,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate43,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate43,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain43,
                    };

                    int tempAttr43 = Settings.ChallengeStageAttribute43;
                    if (tempAttr43 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr43 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr43);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage43, this, 0, ChallengeStage43);
                    break;
                case 44:
                    var ChallengeStage44 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC44,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC44,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC44,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC44,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC44,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC44,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC44,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC44,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC44,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC44,
                        [Stat.HP] = Settings.ChallengeStageHP44,
                        [Stat.MP] = Settings.ChallengeStageMP44,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage44,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage44,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction44,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate44,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate44,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy44,
                        [Stat.Agility] = Settings.ChallengeStageAgility44,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing44,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack44,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist44,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist44,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery44,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery44,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery44,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate44,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage44,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate44,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate44,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate44,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate44,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate44,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate44,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate44,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain44,
                    };

                    int tempAttr44 = Settings.ChallengeStageAttribute44;
                    if (tempAttr44 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr44 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr44);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage44, this, 0, ChallengeStage44);
                    break;
                case 45:
                    var ChallengeStage45 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC45,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC45,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC45,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC45,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC45,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC45,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC45,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC45,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC45,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC45,
                        [Stat.HP] = Settings.ChallengeStageHP45,
                        [Stat.MP] = Settings.ChallengeStageMP45,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage45,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage45,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction45,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate45,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate45,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy45,
                        [Stat.Agility] = Settings.ChallengeStageAgility45,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing45,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack45,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist45,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist45,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery45,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery45,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery45,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate45,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage45,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate45,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate45,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate45,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate45,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate45,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate45,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate45,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain45,
                    };

                    int tempAttr45 = Settings.ChallengeStageAttribute45;
                    if (tempAttr45 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr45 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr45);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage45, this, 0, ChallengeStage45);
                    break;
                case 46:
                    var ChallengeStage46 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC46,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC46,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC46,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC46,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC46,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC46,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC46,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC46,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC46,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC46,
                        [Stat.HP] = Settings.ChallengeStageHP46,
                        [Stat.MP] = Settings.ChallengeStageMP46,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage46,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage46,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction46,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate46,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate46,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy46,
                        [Stat.Agility] = Settings.ChallengeStageAgility46,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing46,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack46,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist46,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist46,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery46,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery46,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery46,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate46,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage46,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate46,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate46,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate46,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate46,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate46,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate46,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate46,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain46,
                    };

                    int tempAttr46 = Settings.ChallengeStageAttribute46;
                    if (tempAttr46 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr46 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr46);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage46, this, 0, ChallengeStage46);
                    break;
                case 47:
                    var ChallengeStage47 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC47,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC47,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC47,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC47,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC47,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC47,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC47,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC47,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC47,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC47,
                        [Stat.HP] = Settings.ChallengeStageHP47,
                        [Stat.MP] = Settings.ChallengeStageMP47,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage47,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage47,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction47,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate47,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate47,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy47,
                        [Stat.Agility] = Settings.ChallengeStageAgility47,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing47,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack47,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist47,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist47,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery47,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery47,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery47,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate47,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage47,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate47,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate47,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate47,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate47,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate47,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate47,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate47,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain47,
                    };

                    int tempAttr47 = Settings.ChallengeStageAttribute47;
                    if (tempAttr47 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr47 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr47);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage47, this, 0, ChallengeStage47);
                    break;
                case 48:
                    var ChallengeStage48 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC48,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC48,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC48,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC48,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC48,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC48,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC48,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC48,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC48,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC48,
                        [Stat.HP] = Settings.ChallengeStageHP48,
                        [Stat.MP] = Settings.ChallengeStageMP48,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage48,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage48,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction48,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate48,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate48,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy48,
                        [Stat.Agility] = Settings.ChallengeStageAgility48,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing48,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack48,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist48,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist48,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery48,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery48,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery48,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate48,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage48,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate48,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate48,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate48,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate48,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate48,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate48,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate48,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain48,
                    };

                    int tempAttr48 = Settings.ChallengeStageAttribute48;
                    if (tempAttr48 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr48 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr48);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage48, this, 0, ChallengeStage48);
                    break;
                case 49:
                    var ChallengeStage49 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC49,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC49,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC49,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC49,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC49,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC49,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC49,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC49,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC49,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC49,
                        [Stat.HP] = Settings.ChallengeStageHP49,
                        [Stat.MP] = Settings.ChallengeStageMP49,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage49,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage49,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction49,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate49,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate49,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy49,
                        [Stat.Agility] = Settings.ChallengeStageAgility49,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing49,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack49,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist49,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist49,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery49,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery49,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery49,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate49,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage49,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate49,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate49,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate49,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate49,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate49,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate49,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate49,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain49,
                    };

                    int tempAttr49 = Settings.ChallengeStageAttribute49;
                    if (tempAttr49 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr49 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr49);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage49, this, 0, ChallengeStage49);
                    break;
                case 50:
                    var ChallengeStage50 = new Stats
                    {
                        [Stat.MinAC] = Settings.ChallengeStageMinAC50,
                        [Stat.MaxAC] = Settings.ChallengeStageMaxAC50,
                        [Stat.MinMAC] = Settings.ChallengeStageMinMAC50,
                        [Stat.MaxMAC] = Settings.ChallengeStageMaxMAC50,
                        [Stat.MinDC] = Settings.ChallengeStageMinDC50,
                        [Stat.MaxDC] = Settings.ChallengeStageMaxDC50,
                        [Stat.MinMC] = Settings.ChallengeStageMinMC50,
                        [Stat.MaxMC] = Settings.ChallengeStageMaxMC50,
                        [Stat.MinSC] = Settings.ChallengeStageMinSC50,
                        [Stat.MaxSC] = Settings.ChallengeStageMaxSC50,
                        [Stat.HP] = Settings.ChallengeStageHP50,
                        [Stat.MP] = Settings.ChallengeStageMP50,
                        [Stat.PVEDamage] = Settings.ChallengeStagePVEDamage50,
                        [Stat.PVPDamage] = Settings.ChallengeStagePVPDamage50,
                        [Stat.DamageReductionPercent] = Settings.ChallengeStageDamageReduction50,
                        [Stat.ExpRatePercent] = Settings.ChallengeStageExpRate50,
                        [Stat.GoldDropRatePercent] = Settings.ChallengeStageGoldRate50,
                        [Stat.Accuracy] = Settings.ChallengeStageAccuracy50,
                        [Stat.Agility] = Settings.ChallengeStageAgility50,
                        [Stat.Freezing] = Settings.ChallengeStageFreezing50,
                        [Stat.PoisonAttack] = Settings.ChallengeStagePoisonAttack50,
                        [Stat.MagicResist] = Settings.ChallengeStageMagicResist50,
                        [Stat.PoisonResist] = Settings.ChallengeStagePoisonResist50,
                        [Stat.HealthRecovery] = Settings.ChallengeStageHealthRecovery50,
                        [Stat.SpellRecovery] = Settings.ChallengeStageSpellRecovery50,
                        [Stat.PoisonRecovery] = Settings.ChallengeStagePoisonRecovery50,
                        [Stat.CriticalRate] = Settings.ChallengeStageCriticalRate50,
                        [Stat.CriticalDamage] = Settings.ChallengeStageCriticalDamage50,
                        [Stat.MaxACRatePercent] = Settings.ChallengeStageMaxACRate50,
                        [Stat.MaxMACRatePercent] = Settings.ChallengeStageMaxMacRate50,
                        [Stat.MaxDCRatePercent] = Settings.ChallengeStageMaxDCRate50,
                        [Stat.MaxMCRatePercent] = Settings.ChallengeStageMaxMCRate50,
                        [Stat.MaxSCRatePercent] = Settings.ChallengeStageMaxSCRate50,
                        [Stat.HPRatePercent] = Settings.ChallengeStageHPRate50,
                        [Stat.MPRatePercent] = Settings.ChallengeStageMPRate50,
                        [Stat.HPDrainRatePercent] = Settings.ChallengeStageHPDrain50,
                    };

                    int tempAttr50 = Settings.ChallengeStageAttribute50;
                    if (tempAttr50 + Info.CurrentAttributePoints >= int.MaxValue)
                        tempAttr50 = int.MaxValue - Info.CurrentAttributePoints;
                    GainAttributePoint(tempAttr50);

                    RemoveBuff(BuffType.ChallengeStage1);
                    RemoveBuff(BuffType.ChallengeStage2);
                    RemoveBuff(BuffType.ChallengeStage3);
                    RemoveBuff(BuffType.ChallengeStage4);
                    RemoveBuff(BuffType.ChallengeStage5);
                    RemoveBuff(BuffType.ChallengeStage6);
                    RemoveBuff(BuffType.ChallengeStage7);
                    RemoveBuff(BuffType.ChallengeStage8);
                    RemoveBuff(BuffType.ChallengeStage9);
                    RemoveBuff(BuffType.ChallengeStage10);
                    RemoveBuff(BuffType.ChallengeStage11);
                    RemoveBuff(BuffType.ChallengeStage12);
                    RemoveBuff(BuffType.ChallengeStage13);
                    RemoveBuff(BuffType.ChallengeStage14);
                    RemoveBuff(BuffType.ChallengeStage15);
                    RemoveBuff(BuffType.ChallengeStage16);
                    RemoveBuff(BuffType.ChallengeStage17);
                    RemoveBuff(BuffType.ChallengeStage18);
                    RemoveBuff(BuffType.ChallengeStage19);
                    RemoveBuff(BuffType.ChallengeStage20);
                    RemoveBuff(BuffType.ChallengeStage21);
                    RemoveBuff(BuffType.ChallengeStage22);
                    RemoveBuff(BuffType.ChallengeStage23);
                    RemoveBuff(BuffType.ChallengeStage24);
                    RemoveBuff(BuffType.ChallengeStage25);
                    RemoveBuff(BuffType.ChallengeStage26);
                    RemoveBuff(BuffType.ChallengeStage27);
                    RemoveBuff(BuffType.ChallengeStage28);
                    RemoveBuff(BuffType.ChallengeStage29);
                    RemoveBuff(BuffType.ChallengeStage30);
                    RemoveBuff(BuffType.ChallengeStage31);
                    RemoveBuff(BuffType.ChallengeStage32);
                    RemoveBuff(BuffType.ChallengeStage33);
                    RemoveBuff(BuffType.ChallengeStage34);
                    RemoveBuff(BuffType.ChallengeStage35);
                    RemoveBuff(BuffType.ChallengeStage36);
                    RemoveBuff(BuffType.ChallengeStage37);
                    RemoveBuff(BuffType.ChallengeStage38);
                    RemoveBuff(BuffType.ChallengeStage39);
                    RemoveBuff(BuffType.ChallengeStage40);
                    RemoveBuff(BuffType.ChallengeStage41);
                    RemoveBuff(BuffType.ChallengeStage42);
                    RemoveBuff(BuffType.ChallengeStage43);
                    RemoveBuff(BuffType.ChallengeStage44);
                    RemoveBuff(BuffType.ChallengeStage45);
                    RemoveBuff(BuffType.ChallengeStage46);
                    RemoveBuff(BuffType.ChallengeStage47);
                    RemoveBuff(BuffType.ChallengeStage48);
                    RemoveBuff(BuffType.ChallengeStage49);
                    RemoveBuff(BuffType.ChallengeStage50);
                    AddBuff(BuffType.ChallengeStage50, this, 0, ChallengeStage50);
                    break;
            }
        }
        public void Opendoor(byte Doorindex)
        {
            //todo: add check for sw doors
            if (CurrentMap.OpenDoor(Doorindex))
            {
                Enqueue(new S.Opendoor() { DoorIndex = Doorindex });
                Broadcast(new S.Opendoor() { DoorIndex = Doorindex });
            }
        }


        #region NPC

        public void CallDefaultNPC(DefaultNPCType type, params object[] value)
        {
            string key = string.Empty;
            if (type == DefaultNPCType.Login)
                MessageQueue.Enqueue($"Login trigger");

            switch (type)
            {
                case DefaultNPCType.Login:
                    key = "Login";
                    break;
                case DefaultNPCType.UseItem:
                    if (value.Length < 1) return;
                    key = string.Format("UseItem({0})", value[0]);
                    break;
                case DefaultNPCType.MapCoord:
                    if (value.Length < 3) return;
                    key = string.Format("MapCoord({0},{1},{2})", value[0], value[1], value[2]);
                    break;
                case DefaultNPCType.MapEnter:
                    if (value.Length < 1) return;
                    key = string.Format("MapEnter({0})", value[0]);
                    break;
                case DefaultNPCType.Die:
                    key = "Die";
                    break;
                case DefaultNPCType.LevelUp:
                    key = "LevelUp";
                    break;
                case DefaultNPCType.RebornUp:
                    key = "RebornUp";
                    break;
                case DefaultNPCType.InstanceStageUp:
                    key = "InstanceStageUp";
                    break;
                case DefaultNPCType.ChallengeStageUp:
                    key = "ChallengeStageUp";
                    break;
                case DefaultNPCType.CustomCommand:
                    if (value.Length < 1) return;
                    key = string.Format("CustomCommand({0})", value[0]);
                    break;
                case DefaultNPCType.WorldMap:
                    if (value.Length < 1) return;
                    key = string.Format("WorldMap({0})", value[0]);
                    break;
                case DefaultNPCType.OnAcceptQuest:
                    if (value.Length < 1) return;
                    key = string.Format("OnAcceptQuest({0})", value[0]);
                    break;
                case DefaultNPCType.OnFinishQuest:
                    if (value.Length < 1) return;
                    key = string.Format("OnFinishQuest({0})", value[0]);
                    break;
                case DefaultNPCType.Daily:
                    key = "Daily";
                    Info.NewDay = false;
                    break;
                case DefaultNPCType.Weekly:
                    key = "Weekly";
                    Info.NewWeek = false;
                    break;
                case DefaultNPCType.Client:
                    key = "Client";
                    break;
            }

            key = string.Format("[@_{0}]", key);

            DelayedAction action = new DelayedAction(DelayedType.NPC, Envir.Time + 0, DefaultNPC.LoadedObjectID, DefaultNPC.ScriptID, key);
            ActionList.Add(action);

            Enqueue(new S.NPCUpdate { NPCID = DefaultNPC.LoadedObjectID });
        }

        public void CallDefaultNPC(string key)
        {
            if (NPCObjectID != DefaultNPC.LoadedObjectID) return;

            var script = NPCScript.Get(NPCScriptID);
            script.Call(this, NPCObjectID, key.ToUpper());

            CallNPCNextPage();
        }

        public void CallNPC(uint objectID, string key)
        {
            if (Dead) return;

            key = key.ToUpper();

            for (int i = 0; i < CurrentMap.NPCs.Count; i++)
            {
                NPCObject ob = CurrentMap.NPCs[i];
                if (ob.ObjectID != objectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                ob.CheckVisible(this);

                if (!ob.VisibleLog[Info.Index] || !ob.Visible) return;

                var scriptID = NPCScriptID;
                if (objectID != NPCObjectID || key == NPCScript.MainKey)
                {
                    scriptID = ob.ScriptID;
                }

                var script = NPCScript.Get(scriptID);
                script.Call(this, objectID, key);

                break;
            }

            CallNPCNextPage();
        }
        private void CallNPCNextPage()
        {
            //process any new npc calls immediately
            for (int i = 0; i < ActionList.Count; i++)
            {
                if (ActionList[i].Type != DelayedType.NPC || ActionList[i].Time != -1) continue;
                var action = ActionList[i];

                ActionList.RemoveAt(i);

                CompleteNPC(action.Params);
            }
        }

        public void BuyItem(ulong index, ushort count, PanelType type)
        {
            if (Dead || count < 1) return;

            if (NPCPage == null ||
                !(String.Equals(NPCPage.Key, NPCScript.BuySellKey, StringComparison.CurrentCultureIgnoreCase) ||
                String.Equals(NPCPage.Key, NPCScript.BuyKey, StringComparison.CurrentCultureIgnoreCase) ||
                String.Equals(NPCPage.Key, NPCScript.BuyBackKey, StringComparison.CurrentCultureIgnoreCase) ||
                String.Equals(NPCPage.Key, NPCScript.BuyUsedKey, StringComparison.CurrentCultureIgnoreCase) ||
                String.Equals(NPCPage.Key, NPCScript.PearlBuyKey, StringComparison.CurrentCultureIgnoreCase) ||
                String.Equals(NPCPage.Key, NPCScript.HuntBuyKey, StringComparison.CurrentCultureIgnoreCase))) return;

            for (int i = 0; i < CurrentMap.NPCs.Count; i++)
            {
                NPCObject ob = CurrentMap.NPCs[i];
                if (ob.ObjectID != NPCObjectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                if (type == PanelType.Buy)
                {
                    NPCScript script = NPCScript.Get(NPCScriptID);
                    script.Buy(this, index, count);
                }
            }
        }
        public void CraftItem(ulong index, ushort count, int[] slots)
        {
            if (Dead || count < 1) return;

            if (NPCPage == null) return;

            for (int i = 0; i < CurrentMap.NPCs.Count; i++)
            {
                NPCObject ob = CurrentMap.NPCs[i];
                if (ob.ObjectID != NPCObjectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                NPCScript script = NPCScript.Get(NPCScriptID);
                script.Craft(this, index, count, slots);
            }
        }


        public void SellItem(ulong uniqueID, ushort count)
        {
            S.SellItem p = new S.SellItem { UniqueID = uniqueID, Count = count };
            if (Dead || count == 0)
            {
                Enqueue(p);
                return;
            }

            if (NPCPage == null || !(String.Equals(NPCPage.Key, NPCScript.BuySellKey, StringComparison.CurrentCultureIgnoreCase) || String.Equals(NPCPage.Key, NPCScript.SellKey, StringComparison.CurrentCultureIgnoreCase)))
            {
                Enqueue(p);
                return;
            }

            for (int n = 0; n < CurrentMap.NPCs.Count; n++)
            {
                NPCObject ob = CurrentMap.NPCs[n];
                if (ob.ObjectID != NPCObjectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                UserItem temp = null;
                int index = -1;

                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    temp = Info.Inventory[i];
                    if (temp == null || temp.UniqueID != uniqueID) continue;
                    index = i;
                    break;
                }

                if (temp == null || index == -1 || count > temp.Count)
                {
                    Enqueue(p);
                    return;
                }

                if (temp.Info.Bind.HasFlag(BindMode.DontSell))
                {
                    Enqueue(p);
                    return;
                }

                if (temp.RentalInformation != null && temp.RentalInformation.BindingFlags.HasFlag(BindMode.DontSell))
                {
                    Enqueue(p);
                    return;
                }

                NPCScript script = NPCScript.Get(NPCScriptID);

                if (script.Types.Count != 0 && !script.Types.Contains(temp.Info.Type))
                {
                    ReceiveChat("You cannot sell this item here.", ChatType.System);
                    Enqueue(p);
                    return;
                }

                if (temp.Info.StackSize > 1 && count != temp.Count)
                {
                    UserItem item = Envir.CreateFreshItem(temp.Info);
                    item.Count = count;

                    if (item.Price() / 2 + Account.Gold > uint.MaxValue)
                    {
                        Enqueue(p);
                        return;
                    }

                    temp.Count -= count;
                    temp = item;
                }
                else Info.Inventory[index] = null;

                script.Sell(this, temp);

                if (Settings.GoodsOn)
                {
                    var callingNPC = NPCObject.Get(NPCObjectID);

                    if (callingNPC != null)
                    {
                        if (!callingNPC.BuyBack.ContainsKey(Name)) callingNPC.BuyBack[Name] = new List<UserItem>();

                        if (Settings.GoodsBuyBackMaxStored > 0 && callingNPC.BuyBack[Name].Count >= Settings.GoodsBuyBackMaxStored)
                            callingNPC.BuyBack[Name].RemoveAt(0);

                        temp.BuybackExpiryDate = Envir.Now;
                        callingNPC.BuyBack[Name].Add(temp);
                    }
                }

                p.Success = true;
                Enqueue(p);
                GainGold(temp.Price() / 2);
                RefreshBagWeight();

                return;
            }

            Enqueue(p);
        }
        public void RepairItem(ulong uniqueID, bool special = false)
        {
            Enqueue(new S.RepairItem { UniqueID = uniqueID });

            if (Dead) return;

            if (NPCPage == null || (!String.Equals(NPCPage.Key, NPCScript.RepairKey, StringComparison.CurrentCultureIgnoreCase) && !special) || (!String.Equals(NPCPage.Key, NPCScript.SRepairKey, StringComparison.CurrentCultureIgnoreCase) && special)) return;

            for (int n = 0; n < CurrentMap.NPCs.Count; n++)
            {
                NPCObject ob = CurrentMap.NPCs[n];
                if (ob.ObjectID != NPCObjectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                UserItem temp = null;
                int index = -1;

                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    temp = Info.Inventory[i];
                    if (temp == null || temp.UniqueID != uniqueID) continue;
                    index = i;
                    break;
                }

                if (temp == null || index == -1) return;

                if ((temp.Info.Bind.HasFlag(BindMode.DontRepair)) || (temp.Info.Bind.HasFlag(BindMode.NoSRepair) && special))
                {
                    ReceiveChat("You cannot Repair this item.", ChatType.System);
                    return;
                }

                NPCScript script = NPCScript.Get(NPCScriptID);

                if (script.Types.Count != 0 && !script.Types.Contains(temp.Info.Type))
                {
                    ReceiveChat("You cannot Repair this item here.", ChatType.System);
                    return;
                }

                uint cost;
                uint baseCost;
                if (!special)
                {
                    cost = (uint)(temp.RepairPrice() * script.PriceRate(this));
                    baseCost = (uint)(temp.RepairPrice() * script.PriceRate(this, true));
                }
                else
                {
                    cost = (uint)(temp.RepairPrice() * 3 * script.PriceRate(this));
                    baseCost = (uint)(temp.RepairPrice() * 3 * script.PriceRate(this, true));
                }

                if (cost > Account.Gold) return;

                Account.Gold -= cost;
                Enqueue(new S.LoseGold { Gold = cost });
                if (ob.Conq != null) ob.Conq.GoldStorage += (cost - baseCost);

                if (!special) temp.MaxDura = (ushort)Math.Max(0, temp.MaxDura - (temp.MaxDura - temp.CurrentDura) / 30);

                temp.CurrentDura = temp.MaxDura;
                temp.DuraChanged = false;

                Enqueue(new S.ItemRepaired { UniqueID = uniqueID, MaxDura = temp.MaxDura, CurrentDura = temp.CurrentDura });
                return;
            }
        }
        public void SendStorage()
        {
            if (Connection.StorageSent) return;
            Connection.StorageSent = true;

            for (int i = 0; i < Account.Storage.Length; i++)
            {
                UserItem item = Account.Storage[i];
                if (item == null) continue;
                //CheckItemInfo(item.Info);
                CheckItem(item);
            }

            Enqueue(new S.UserStorage { Storage = Account.Storage }); // Should be no alter before being sent.
        }

        #endregion

        public void GetGuildTerritories(int page)
        {
            if (Dead) return;

            List<GTMap> tempList = new List<GTMap>();

            if (page < 0) return;

            var max = Math.Min(Envir.GTMapList.Count, (page + 1) * 7);
            for (int i = page * 7; i < max; i++)
            {
                tempList.Add(Envir.GTMapList[i]);
            }

            Enqueue(new S.GuildTerritoryPage { Listings = tempList, lenght = Envir.GTMapList.Count });
        }

        #region Consignment
        public void ConsignItem(ulong uniqueID, uint price, MarketPanelType panelType)
        {
            S.ConsignItem p = new S.ConsignItem { UniqueID = uniqueID };

            if (Dead || NPCPage == null)
            {
                Enqueue(p);
                return;
            }

            switch (panelType)
            {
                case MarketPanelType.Consign:
                    {
                        if (price < Globals.MinConsignment || price > Globals.MaxConsignment)
                        {
                            Enqueue(p);
                            return;
                        }

                        if (Account.Gold < Globals.ConsignmentCost)
                        {
                            Enqueue(p);
                            return;
                        }
                    }
                    break;
                case MarketPanelType.Auction:
                    {
                        if (price < Globals.MinStartingBid || price > Globals.MaxStartingBid)
                        {
                            Enqueue(p);
                            return;
                        }

                        if (Account.Gold < Globals.AuctionCost)
                        {
                            Enqueue(p);
                            return;
                        }
                    }
                    break;
                default:
                    Enqueue(p);
                    return;
            }

            for (int n = 0; n < CurrentMap.NPCs.Count; n++)
            {
                NPCObject ob = CurrentMap.NPCs[n];
                if (ob.ObjectID != NPCObjectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                UserItem temp = null;
                int index = -1;

                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    temp = Info.Inventory[i];
                    if (temp == null || temp.UniqueID != uniqueID) continue;
                    index = i;
                    break;
                }

                if (temp == null || index == -1)
                {
                    Enqueue(p);
                    return;
                }

                if (temp.Info.Bind.HasFlag(BindMode.DontSell))
                {
                    Enqueue(p);
                    return;
                }

                MarketItemType type = MarketPanelType == MarketPanelType.Consign ? MarketItemType.Consign : MarketItemType.Auction;
                uint cost = MarketPanelType == MarketPanelType.Consign ? Globals.ConsignmentCost : Globals.AuctionCost;

                //TODO Check Max Consignment.

                AuctionInfo auction = new AuctionInfo(Info, temp, price, type);

                Account.Auctions.AddLast(auction);
                Envir.Auctions.AddFirst(auction);

                p.Success = true;
                Enqueue(p);

                Info.Inventory[index] = null;

                Account.Gold -= cost;

                Enqueue(new S.LoseGold { Gold = cost });
                RefreshBagWeight();
            }

            Enqueue(p);
        }

        private bool Match(AuctionInfo info)
        {
            return (UserMatch || !info.Expired && !info.Sold)
                && (!UserMatch || ((MarketPanelType == MarketPanelType.Auction && info.ItemType == MarketItemType.Auction) || (MarketPanelType != MarketPanelType.Auction && info.ItemType == MarketItemType.Consign)))
                && ((MatchType == ItemType.Nothing || info.Item.Info.Type == MatchType)
                && (info.Item.Info.Shape >= MinShapes && info.Item.Info.Shape <= MaxShapes)
                && (string.IsNullOrWhiteSpace(MatchName) || info.Item.Info.Name.Replace(" ", "").IndexOf(MatchName, StringComparison.OrdinalIgnoreCase) >= 0));
        }

        public void MarketPage(int page)
        {
            if (Dead || Envir.Time < SearchTime) return;

            if (MarketPanelType != MarketPanelType.GameShop)
            {
                bool failed = true;

                if (NPCPage == null || (!String.Equals(NPCPage.Key, NPCScript.MarketKey, StringComparison.CurrentCultureIgnoreCase)) || page <= PageSent) return;

                SearchTime = Envir.Time + Globals.SearchDelay;

                for (int n = 0; n < CurrentMap.NPCs.Count; n++)
                {
                    NPCObject ob = CurrentMap.NPCs[n];
                    if (ob.ObjectID != NPCObjectID) continue;
                    if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;
                    failed = false;
                }

                if (failed)
                {
                    return;
                }
            }

            List<AuctionInfo> listings = new List<AuctionInfo>();
            List<ClientAuction> clientListings = new List<ClientAuction>();

            for (int i = 0; i < 10; i++)
            {
                if (i + page * 10 >= Search.Count) break;
                listings.Add(Search[i + page * 10]);
            }

            foreach (var listing in listings)
            {
                clientListings.Add(listing.CreateClientAuction(UserMatch));
            }

            for (int i = 0; i < listings.Count; i++)
            {
                CheckItem(listings[i].Item);
            }

            PageSent = page;
            Enqueue(new S.NPCMarketPage { Listings = clientListings });
        }

        public void GetMarket(string name, ItemType type)
        {
            Search.Clear();
            MatchName = name.Replace(" ", "");
            MatchType = type;
            PageSent = 0;

            long start = Envir.Stopwatch.ElapsedMilliseconds;

            if (MarketPanelType == MarketPanelType.GameShop)
            {
                //Search = Envir.GameShopList.Where(x => (MatchType == ItemType.Nothing || x.Info.Type == MatchType)
                //&& (x.Info.Shape >= MinShapes && x.Info.Shape <= MaxShapes)
                //&& (string.IsNullOrWhiteSpace(MatchName) || x.Info.Name.Replace(" ", "").IndexOf(MatchName, StringComparison.OrdinalIgnoreCase) >= 0)).ToList();
            }
            else
            {
                LinkedListNode<AuctionInfo> current = UserMatch ? Account.Auctions.First : Envir.Auctions.First;

                while (current != null)
                {
                    if (Match(current.Value)) Search.Add(current.Value);
                    current = current.Next;
                }
            }

            List<AuctionInfo> listings = new List<AuctionInfo>();
            List<ClientAuction> clientListings = new List<ClientAuction>();

            for (int i = 0; i < 10; i++)
            {
                if (i >= Search.Count) break;
                listings.Add(Search[i]);
            }

            foreach (var listing in listings)
            {
                clientListings.Add(listing.CreateClientAuction(UserMatch));
            }

            for (int i = 0; i < listings.Count; i++)
                CheckItem(listings[i].Item);

            Enqueue(new S.NPCMarket { Listings = clientListings, Pages = (Search.Count - 1) / 10 + 1, UserMode = UserMatch });

            MessageQueue.EnqueueDebugging(string.Format("{0}ms to match {1} items", Envir.Stopwatch.ElapsedMilliseconds - start, MarketPanelType == MarketPanelType.GameShop ? Envir.GameShopList.Count : (UserMatch ? Account.Auctions.Count : Envir.Auctions.Count)));
        }

        public void MarketSearch(string match, ItemType type)
        {
            if (Dead || Envir.Time < SearchTime) return;

            SearchTime = Envir.Time + Globals.SearchDelay;

            if (MarketPanelType == MarketPanelType.GameShop)
            {
                GetMarket(match, type);
            }
            else
            {
                if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.MarketKey, StringComparison.CurrentCultureIgnoreCase)) return;

                for (int n = 0; n < CurrentMap.NPCs.Count; n++)
                {
                    NPCObject ob = CurrentMap.NPCs[n];
                    if (ob.ObjectID != NPCObjectID) continue;

                    if (!Functions.InRange(CurrentLocation, ob.CurrentLocation, Globals.DataRange)) return;

                    GetMarket(match, type);
                }
            }
        }

        public void MarketBuy(ulong auctionID, uint bidPrice = 0)
        {
            if (Dead)
            {
                Enqueue(new S.MarketFail { Reason = 0 });
                return;
            }

            if (MarketPanelType == MarketPanelType.GameShop)
            {
                foreach (AuctionInfo auction in Search)
                {
                    if (auction.AuctionID != auctionID) continue;
                    if (auction.ItemType != MarketItemType.GameShop) continue;

                    if (auction.Price > Account.Credit)
                    {
                        Enqueue(new S.MarketFail { Reason = 4 });
                        return;
                    }

                    if (!CanGainItem(auction.Item))
                    {
                        Enqueue(new S.MarketFail { Reason = 5 });
                        return;
                    }

                    UserItem item = Envir.CreateFreshItem(auction.Item.Info);

                    Account.Credit -= auction.Price;
                    GainItem(item);
                    Enqueue(new S.MarketSuccess { Message = string.Format("You bought {0} for {1:#,##0} Credit", auction.Item.FriendlyName, auction.Price) });
                    MarketSearch(MatchName, MatchType);

                    return;
                }
            }
            else
            {
                if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.MarketKey, StringComparison.CurrentCultureIgnoreCase))
                {
                    Enqueue(new S.MarketFail { Reason = 1 });
                    return;
                }

                for (int n = 0; n < CurrentMap.NPCs.Count; n++)
                {
                    NPCObject ob = CurrentMap.NPCs[n];
                    if (ob.ObjectID != NPCObjectID) continue;

                    if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                    foreach (AuctionInfo auction in Search)
                    {
                        if (auction.AuctionID != auctionID) continue;
                        if (auction.ItemType != MarketItemType.Consign && auction.ItemType != MarketItemType.Auction) continue;

                        if (auction.Sold)
                        {
                            Enqueue(new S.MarketFail { Reason = 2 });
                            return;
                        }

                        if (auction.Expired)
                        {
                            Enqueue(new S.MarketFail { Reason = 3 });
                            return;
                        }

                        if (!Envir.Auctions.Contains(auction))
                        {
                            Enqueue(new S.MarketFail { Reason = 3 });
                            return;
                        }

                        if (!CanGainItem(auction.Item))
                        {
                            Enqueue(new S.MarketFail { Reason = 5 });
                            return;
                        }

                        if (Account.Auctions.Contains(auction))
                        {
                            Enqueue(new S.MarketFail { Reason = 6 });
                            return;
                        }

                        if (auction.Price > Account.Gold)
                        {
                            Enqueue(new S.MarketFail { Reason = 4 });
                            return;
                        }

                        if (auction.ItemType == MarketItemType.Consign)
                        {
                            auction.Sold = true;

                            Account.Gold -= auction.Price;

                            Enqueue(new S.LoseGold { Gold = auction.Price });
                            GainItem(auction.Item);

                            Envir.MessageAccount(auction.SellerInfo.AccountInfo, string.Format("You sold {0} for {1:#,##0} Gold", auction.Item.FriendlyName, auction.Price), ChatType.Hint);
                            Enqueue(new S.MarketSuccess { Message = string.Format("You bought {0} for {1:#,##0} Gold", auction.Item.FriendlyName, auction.Price) });
                            MarketSearch(MatchName, MatchType);
                        }
                        else
                        {
                            if (auction.CurrentBid > bidPrice)
                            {
                                Enqueue(new S.MarketFail { Reason = 9 });
                                return;
                            }

                            if (auction.CurrentBuyerInfo != null)
                            {
                                string message = string.Format("You have been outbid on {0}. Refunded {1:#,##0} Gold.", auction.Item.FriendlyName, auction.CurrentBid);

                                Envir.MailCharacter(auction.CurrentBuyerInfo, gold: auction.CurrentBid, customMessage: message);
                            }

                            auction.CurrentBid = bidPrice;
                            auction.CurrentBuyerIndex = Info.Index;
                            auction.CurrentBuyerInfo = Info;

                            Account.Gold -= bidPrice;
                            Enqueue(new S.LoseGold { Gold = bidPrice });

                            Envir.MessageAccount(auction.SellerInfo.AccountInfo, string.Format("Someone has bid {1:#,##0} Gold for {0}", auction.Item.FriendlyName, auction.CurrentBid), ChatType.Hint);
                            Enqueue(new S.MarketSuccess { Message = string.Format("You bid {1:#,##0} Gold for {0}", auction.Item.FriendlyName, auction.CurrentBid) });
                            MarketSearch(MatchName, MatchType);
                        }

                        return;
                    }
                }
            }

            Enqueue(new S.MarketFail { Reason = 7 });
        }

        public void MarketSellNow(ulong auctionID)
        {
            if (Dead)
            {
                Enqueue(new S.MarketFail { Reason = 0 });
                return;
            }

            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.MarketKey, StringComparison.CurrentCultureIgnoreCase))
            {
                Enqueue(new S.MarketFail { Reason = 1 });
                return;
            }

            for (int n = 0; n < CurrentMap.NPCs.Count; n++)
            {
                NPCObject ob = CurrentMap.NPCs[n];
                if (ob.ObjectID != NPCObjectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                foreach (AuctionInfo auction in Account.Auctions)
                {
                    if (auction.AuctionID != auctionID) continue;

                    if (auction.ItemType != MarketItemType.Auction)
                    {
                        return;
                    }

                    if (auction.CurrentBid <= auction.Price || auction.CurrentBuyerInfo == null)
                    {
                        Enqueue(new S.MarketFail { Reason = 9 });
                        return;
                    }

                    if (auction.Sold && auction.Expired)
                    {
                        MessageQueue.Enqueue(string.Format("Auction both sold and Expired {0}", Account.AccountID));
                        return;
                    }

                    if (auction.Expired || auction.Sold || Envir.Now >= auction.ConsignmentDate.AddDays(Globals.ConsignmentLength))
                    {
                        Enqueue(new S.MarketFail { Reason = 10 });
                        return;
                    }

                    uint cost = auction.CurrentBid;

                    uint gold = (uint)Math.Max(0, cost - cost * Globals.Commission);

                    if (!CanGainGold(auction.CurrentBid))
                    {
                        Enqueue(new S.MarketFail { Reason = 8 });
                        return;
                    }

                    auction.Sold = true;

                    string message = string.Format("You won {0} for {1:#,##0} Gold.", auction.Item.FriendlyName, auction.CurrentBid);

                    Envir.MailCharacter(auction.CurrentBuyerInfo, item: auction.Item, customMessage: message);
                    Envir.MessageAccount(auction.CurrentBuyerInfo.AccountInfo, string.Format("You bought {0} for {1:#,##0} Gold", auction.Item.FriendlyName, auction.CurrentBid), ChatType.Hint);

                    Account.Auctions.Remove(auction);
                    Envir.Auctions.Remove(auction);
                    GainGold(gold);
                    Enqueue(new S.MarketSuccess { Message = string.Format("You sold {0} for {1:#,##0} Gold. \nEarnings: {2:#,##0} Gold.\nCommision: {3:#,##0} Gold.‎", auction.Item.FriendlyName, cost, gold, cost - gold) });
                    MarketSearch(MatchName, MatchType);
                    return;
                }

            }

            Enqueue(new S.MarketFail { Reason = 7 });
        }

        public void MarketGetBack(ulong auctionID)
        {
            if (Dead)
            {
                Enqueue(new S.MarketFail { Reason = 0 });
                return;
            }

            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.MarketKey, StringComparison.CurrentCultureIgnoreCase))
            {
                Enqueue(new S.MarketFail { Reason = 1 });
                return;
            }

            for (int n = 0; n < CurrentMap.NPCs.Count; n++)
            {
                NPCObject ob = CurrentMap.NPCs[n];
                if (ob.ObjectID != NPCObjectID) continue;
                if (!Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange)) return;

                foreach (AuctionInfo auction in Account.Auctions)
                {
                    if (auction.AuctionID != auctionID) continue;

                    if (auction.Sold && auction.Expired)
                    {
                        MessageQueue.Enqueue(string.Format("Auction both sold and Expired {0}", Account.AccountID));
                        return;
                    }

                    if (!auction.Sold || auction.Expired)
                    {
                        if (!CanGainItem(auction.Item))
                        {
                            Enqueue(new S.MarketFail { Reason = 5 });
                            return;
                        }

                        if (auction.CurrentBuyerInfo != null)
                        {
                            string message = string.Format("You have been outbid on {0}. Refunded {1:#,##0} Gold.", auction.Item.FriendlyName, auction.CurrentBid);

                            Envir.MailCharacter(auction.CurrentBuyerInfo, gold: auction.CurrentBid, customMessage: message);
                        }

                        Account.Auctions.Remove(auction);
                        Envir.Auctions.Remove(auction);
                        GainItem(auction.Item);
                        MarketSearch(MatchName, MatchType);
                        return;
                    }

                    uint cost = auction.ItemType == MarketItemType.Consign ? auction.Price : auction.CurrentBid;

                    if (!CanGainGold(cost))
                    {
                        Enqueue(new S.MarketFail { Reason = 8 });
                        return;
                    }

                    uint gold = (uint)Math.Max(0, cost - cost * Globals.Commission);

                    Account.Auctions.Remove(auction);
                    Envir.Auctions.Remove(auction);
                    GainGold(gold);
                    Enqueue(new S.MarketSuccess { Message = string.Format("You sold {0} for {1:#,##0} Gold. \nEarnings: {2:#,##0} Gold.\nCommision: {3:#,##0} Gold.‎", auction.Item.FriendlyName, cost, gold, cost - gold) });
                    MarketSearch(MatchName, MatchType);
                    return;
                }

            }

            Enqueue(new S.MarketFail { Reason = 7 });
        }

        public void RequestUserName(uint id)
        {
            CharacterInfo Character = Envir.GetCharacterInfo((int)id);
            if (Character != null)
                Enqueue(new S.UserName { Id = (uint)Character.Index, Name = Character.Name });
        }

        #endregion

        #region Awakening

        public void Awakening(ulong UniqueID, AwakeType type)
        {
            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.AwakeningKey, StringComparison.CurrentCultureIgnoreCase))
                return;

            if (type == AwakeType.None) return;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                UserItem item = Info.Inventory[i];
                if (item == null || item.UniqueID != UniqueID) continue;

                Awake awake = item.Awake;

                if (item.Info.Bind.HasFlag(BindMode.DontUpgrade))
                {
                    Enqueue(new S.Awakening { result = -1, removeID = -1 });
                    return;
                }

                if (item.RentalInformation != null && item.RentalInformation.BindingFlags.HasFlag(BindMode.DontUpgrade))
                {
                    Enqueue(new S.Awakening { result = -1, removeID = -1 });
                    return;
                }

                if (!item.Info.CanAwakening)
                {
                    Enqueue(new S.Awakening { result = -1, removeID = -1 });
                    return;
                }

                if (awake.IsMaxLevel())
                {
                    Enqueue(new S.Awakening { result = -2, removeID = -1 });
                    return;
                }

                if (Info.AccountInfo.Gold < item.AwakeningPrice())
                {
                    Enqueue(new S.Awakening { result = -3, removeID = -1 });
                    return;
                }

                if (HasAwakeningNeedMaterials(item, type))
                {
                    Info.AccountInfo.Gold -= item.AwakeningPrice();
                    Enqueue(new S.LoseGold { Gold = item.AwakeningPrice() });

                    bool[] isHit;

                    switch (awake.UpgradeAwake(item, type, out isHit))
                    {
                        case -1:
                            Enqueue(new S.Awakening { result = -1, removeID = -1 });
                            break;
                        case 0:
                            AwakeningEffect(false, isHit);
                            Info.Inventory[i] = null;
                            Enqueue(new S.Awakening { result = 0, removeID = (long)item.UniqueID });
                            break;
                        case 1:
                            Enqueue(new S.RefreshItem { Item = item });
                            AwakeningEffect(true, isHit);
                            Enqueue(new S.Awakening { result = 1, removeID = -1 });
                            break;
                        default:
                            break;
                    }
                }
            }
        }

        public void DowngradeAwakening(ulong UniqueID)
        {
            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.DowngradeKey, StringComparison.CurrentCultureIgnoreCase))
                return;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                UserItem item = Info.Inventory[i];
                if (item != null)
                {
                    if (item.UniqueID == UniqueID)
                    {
                        if (item.RentalInformation != null)
                        {
                            ReceiveChat($"Unable to downgrade {item.FriendlyName} as it belongs to {item.RentalInformation.OwnerName}", ChatType.System);
                            return;
                        }

                        if (Info.AccountInfo.Gold >= item.DowngradePrice())
                        {
                            Info.AccountInfo.Gold -= item.DowngradePrice();
                            Enqueue(new S.LoseGold { Gold = item.DowngradePrice() });

                            Awake awake = item.Awake;
                            int result = awake.RemoveAwake();
                            switch (result)
                            {
                                case 0:
                                    ReceiveChat(string.Format("{0} : Remove failed Level 0", item.FriendlyName), ChatType.System);
                                    break;
                                case 1:
                                    ushort maxDura = (Envir.Random.Next(20) == 0) ? (ushort)(item.MaxDura - 1000) : item.MaxDura;
                                    if (maxDura < 1000) maxDura = 1000;

                                    Info.Inventory[i].CurrentDura = (Info.Inventory[i].CurrentDura >= maxDura) ? maxDura : Info.Inventory[i].CurrentDura;
                                    Info.Inventory[i].MaxDura = maxDura;
                                    ReceiveChat(string.Format("{0} : Remove success. Level {1}", item.FriendlyName, item.Awake.GetAwakeLevel()), ChatType.System);
                                    Enqueue(new S.RefreshItem { Item = item });
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                }
            }
        }

        public void DisassembleItem(ulong UniqueID)
        {
            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.DisassembleKey, StringComparison.CurrentCultureIgnoreCase))
                return;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                UserItem item = Info.Inventory[i];

                if (item == null || item.UniqueID != UniqueID)
                    continue;

                if (item.Info.Bind.HasFlag(BindMode.UnableToDisassemble))
                {
                    ReceiveChat($"Unable to disassemble {item.FriendlyName}", ChatType.System);
                    return;
                }

                if (item.RentalInformation != null && item.RentalInformation.BindingFlags.HasFlag(BindMode.UnableToDisassemble))
                {
                    ReceiveChat($"Unable to disassemble {item.FriendlyName} as it belongs to {item.RentalInformation.OwnerName}", ChatType.System);
                    return;
                }

                if (Info.AccountInfo.Gold >= item.DisassemblePrice())
                {
                    List<ItemInfo> dropList = new List<ItemInfo>();
                    foreach (DropInfo drop in Envir.AwakeningDrops)
                    {
                        if (drop.Item.Grade == item.Info.Grade - 1 ||
                            drop.Item.Grade == item.Info.Grade + 1)
                        {
                            if (Envir.Random.Next((drop.Chance <= 0) ? 1 : drop.Chance) == 0)
                            {
                                dropList.Add(drop.Item);
                            }
                        }

                        if (drop.Item.Grade == item.Info.Grade)
                        {
                            dropList.Add(drop.Item);
                        }
                    }

                    if (dropList.Count == 0) continue;

                    UserItem gainItem = Envir.CreateDropItem(dropList[Envir.Random.Next(dropList.Count)]);
                    if (gainItem == null) continue;
                    gainItem.Count = (ushort)Envir.Random.Next(Math.Min(ushort.MaxValue, (int)((((byte)item.Info.Grade * item.Info.RequiredAmount) / 10) + item.Quality())));
                    if (gainItem.Count < 1) gainItem.Count = 1;

                    GainItem(gainItem);

                    Enqueue(new S.LoseGold { Gold = item.DisassemblePrice() });
                    Info.AccountInfo.Gold -= item.DisassemblePrice();

                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                    Info.Inventory[i] = null;
                }
            }
        }

        public void ResetAddedItem(ulong UniqueID)
        {
            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.ResetKey, StringComparison.CurrentCultureIgnoreCase))
                return;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                UserItem item = Info.Inventory[i];
                if (item != null)
                {
                    if (item.UniqueID == UniqueID)
                    {
                        if (item.RentalInformation != null)
                        {
                            ReceiveChat($"Unable to reset {item.FriendlyName} as it belongs to {item.RentalInformation.OwnerName}", ChatType.System);
                            return;
                        }

                        if (Info.AccountInfo.Gold >= item.ResetPrice())
                        {
                            Info.AccountInfo.Gold -= item.ResetPrice();
                            Enqueue(new S.LoseGold { Gold = item.ResetPrice() });

                            UserItem newItem = new UserItem(item.Info);

                            ushort maxDura = (Envir.Random.Next(20) == 0) ? (ushort)(item.MaxDura - 1000) : item.MaxDura;
                            if (maxDura < 1000) maxDura = 1000;

                            newItem.UniqueID = item.UniqueID;
                            newItem.ItemIndex = item.ItemIndex;
                            newItem.CurrentDura = (item.CurrentDura >= maxDura) ? maxDura : item.CurrentDura;
                            newItem.MaxDura = maxDura;
                            newItem.Count = item.Count;
                            newItem.Slots = item.Slots;
                            newItem.Awake = item.Awake;
                            newItem.ExpireInfo = item.ExpireInfo;

                            Info.Inventory[i] = newItem;

                            Enqueue(new S.RefreshItem { Item = Info.Inventory[i] });
                        }
                    }
                }
            }
        }

        public void AwakeningNeedMaterials(ulong UniqueID, AwakeType type)
        {
            if (type == AwakeType.None) return;

            foreach (UserItem item in Info.Inventory)
            {
                if (item != null)
                {
                    if (item.UniqueID == UniqueID)
                    {
                        Awake awake = item.Awake;

                        byte[] materialCount = new byte[2];
                        int idx = 0;
                        foreach (List<byte> material in Awake.AwakeMaterials[(int)type - 1])
                        {
                            byte materialRate = (byte)(Awake.AwakeMaterialRate[(int)item.Info.Grade - 1] * (float)awake.GetAwakeLevel());
                            materialCount[idx] = material[(int)item.Info.Grade - 1];
                            materialCount[idx] += materialRate;
                            idx++;
                        }

                        ItemInfo[] materials = new ItemInfo[2];

                        foreach (ItemInfo info in Envir.ItemInfoList)
                        {
                            if (item.Info.Grade == info.Grade &&
                                info.Type == ItemType.Awakening)
                            {
                                if (info.Shape == (short)type - 1)
                                {
                                    materials[0] = info;
                                }
                                else if (info.Shape == 100)
                                {
                                    materials[1] = info;
                                }
                            }
                        }

                        Enqueue(new S.AwakeningNeedMaterials { Materials = materials, MaterialsCount = materialCount });
                        break;
                    }
                }
            }
        }

        public void AwakeningEffect(bool isSuccess, bool[] isHit)
        {
            for (int i = 0; i < 5; i++)
            {
                Enqueue(new S.ObjectEffect { ObjectID = ObjectID, Effect = isHit[i] ? SpellEffect.AwakeningHit : SpellEffect.AwakeningMiss, EffectType = 0, DelayTime = (uint)(i * 500) });
                Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = isHit[i] ? SpellEffect.AwakeningHit : SpellEffect.AwakeningMiss, EffectType = 0, DelayTime = (uint)(i * 500) });
            }

            Enqueue(new S.ObjectEffect { ObjectID = ObjectID, Effect = isSuccess ? SpellEffect.AwakeningSuccess : SpellEffect.AwakeningFail, EffectType = 0, DelayTime = 2500 });
            Broadcast(new S.ObjectEffect { ObjectID = ObjectID, Effect = isSuccess ? SpellEffect.AwakeningSuccess : SpellEffect.AwakeningFail, EffectType = 0, DelayTime = 2500 });
        }

        public bool HasAwakeningNeedMaterials(UserItem item, AwakeType type)
        {
            Awake awake = item.Awake;

            byte[] materialCount = new byte[2];

            int idx = 0;
            foreach (List<byte> material in Awake.AwakeMaterials[(int)type - 1])
            {
                byte materialRate = (byte)(Awake.AwakeMaterialRate[(int)item.Info.Grade - 1] * (float)awake.GetAwakeLevel());
                materialCount[idx] = material[(int)item.Info.Grade - 1];
                materialCount[idx] += materialRate;
                idx++;
            }

            byte[] currentCount = new byte[2] { 0, 0 };

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                UserItem materialItem = Info.Inventory[i];
                if (materialItem != null)
                {
                    if (materialItem.Info.Grade == item.Info.Grade &&
                        materialItem.Info.Type == ItemType.Awakening)
                    {
                        if (materialItem.Info.Shape == ((int)type - 1) &&
                            materialCount[0] - currentCount[0] != 0)
                        {
                            if (materialItem.Count <= materialCount[0] - currentCount[0])
                            {
                                currentCount[0] += (byte)materialItem.Count;
                            }
                            else if (materialItem.Count > materialCount[0] - currentCount[0])
                            {
                                currentCount[0] = (byte)(materialCount[0] - currentCount[0]);
                            }
                        }
                        else if (materialItem.Info.Shape == 100 &&
                            materialCount[1] - currentCount[1] != 0)
                        {
                            if (materialItem.Count <= materialCount[1] - currentCount[1])
                            {
                                currentCount[1] += (byte)materialItem.Count;
                            }
                            else if (materialItem.Count > materialCount[1] - currentCount[1])
                            {
                                currentCount[1] = (byte)(materialCount[1] - currentCount[1]);
                            }
                        }
                    }
                }
            }

            for (int i = 0; i < materialCount.Length; i++)
            {
                if (materialCount[i] != currentCount[i])
                {
                    Enqueue(new S.Awakening { result = -4, removeID = -1 });
                    return false;
                }
            }

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                if (Info.Inventory[i] != null)
                {
                    if (Info.Inventory[i].Info.Grade == item.Info.Grade &&
                        Info.Inventory[i].Info.Type == ItemType.Awakening)
                    {
                        if (Info.Inventory[i].Info.Shape == ((int)type - 1) &&
                            currentCount[0] > 0)
                        {
                            if (Info.Inventory[i].Count <= currentCount[0])
                            {
                                Enqueue(new S.DeleteItem { UniqueID = Info.Inventory[i].UniqueID, Count = Info.Inventory[i].Count });
                                currentCount[0] -= (byte)Info.Inventory[i].Count;
                                Info.Inventory[i] = null;
                            }
                            else if (Info.Inventory[i].Count > currentCount[0])
                            {
                                Enqueue(new S.DeleteItem { UniqueID = Info.Inventory[i].UniqueID, Count = currentCount[0] });
                                Info.Inventory[i].Count -= currentCount[0];
                                currentCount[0] = 0;
                            }
                        }
                        else if (Info.Inventory[i].Info.Shape == 100 &&
                            currentCount[1] > 0)
                        {
                            if (Info.Inventory[i].Count <= currentCount[1])
                            {
                                Enqueue(new S.DeleteItem { UniqueID = Info.Inventory[i].UniqueID, Count = Info.Inventory[i].Count });
                                currentCount[1] -= (byte)Info.Inventory[i].Count;
                                Info.Inventory[i] = null;
                            }
                            else if (Info.Inventory[i].Count > currentCount[1])
                            {
                                Enqueue(new S.DeleteItem { UniqueID = Info.Inventory[i].UniqueID, Count = currentCount[1] });
                                Info.Inventory[i].Count -= currentCount[1];
                                currentCount[1] = 0;
                            }
                        }
                    }
                }
            }
            return true;
        }

        #endregion

        #region Groups

        public void SwitchGroup(bool allow)
        {
            Enqueue(new S.SwitchGroup { AllowGroup = allow });

            if (AllowGroup == allow) return;
            AllowGroup = allow;

            if (AllowGroup || GroupMembers == null) return;

            RemoveGroupBuff();

            GroupMembers.Remove(this);
            Enqueue(new S.DeleteGroup());

            if (GroupMembers.Count > 1)
            {
                Packet p = new S.DeleteMember { Name = Name };

                for (int i = 0; i < GroupMembers.Count; i++)
                    GroupMembers[i].Enqueue(p);
            }
            else
            {
                GroupMembers[0].Enqueue(new S.DeleteGroup());
                GroupMembers[0].GroupMembers = null;
            }
            GroupMembers = null;
        }

        public void RemoveGroupBuff()
        {
            for (int i = 0; i < Buffs.Count; i++)
            {
                Buff buff = Buffs[i];

                if (buff.Type == BuffType.RelationshipEXP)
                {
                    CharacterInfo lover = Envir.GetCharacterInfo(Info.Married);

                    if (lover == null) continue;

                    PlayerObject loverPlayer = Envir.GetPlayer(lover.Name);

                    RemoveBuff(BuffType.RelationshipEXP);

                    if (loverPlayer != null)
                    {
                        loverPlayer.RemoveBuff(BuffType.RelationshipEXP);
                    }
                }
                else if (buff.Type == BuffType.Mentee || buff.Type == BuffType.Mentor)
                {
                    CharacterInfo mentor = Envir.GetCharacterInfo(Info.Mentor);

                    if (mentor == null) continue;

                    PlayerObject MentorP = Envir.GetPlayer(mentor.Name);

                    RemoveBuff(buff.Type);

                    if (MentorP != null)
                    {
                        MentorP.RemoveBuff(buff.Type == BuffType.Mentee ? BuffType.Mentor : BuffType.Mentee);
                    }
                }
            }
        }
        public void AddMember(string name)
        {
            if (Envir.Time < NextGroupInviteTime) return;
            NextGroupInviteTime = Envir.Time + Settings.GroupInviteDelay;
            if (GroupMembers != null && GroupMembers[0] != this)
            {
                ReceiveChat("You are not the group leader.", ChatType.System);
                return;
            }

            if (GroupMembers != null && GroupMembers.Count >= Globals.MaxGroup)
            {
                ReceiveChat("Your group already has the maximum number of members.", ChatType.System);
                return;
            }

            PlayerObject player = Envir.GetPlayer(name);

            if (player == null)
            {
                ReceiveChat(name + " could not be found.", ChatType.System);
                return;
            }
            if (player == this)
            {
                ReceiveChat("You cannot group yourself.", ChatType.System);
                return;
            }

            if (!player.AllowGroup)
            {
                ReceiveChat(name + " is not allowing group.", ChatType.System);
                return;
            }
            if (player.CurrentMap.Info.NoGroup)
            {
                ReceiveChat(player.Name + " cannot accept invites on solo maps.", ChatType.System);
                player.ReceiveChat(player.Name + " cannot accept invites on solo maps.", ChatType.System);
                return;
            }

            if (player.GroupMembers != null)
            {
                ReceiveChat(name + " is already in another group.", ChatType.System);
                return;
            }

            if (player.GroupInvitation != null)
            {
                ReceiveChat(name + " is already receiving an invite from another player.", ChatType.System);
                return;
            }

            SwitchGroup(true);
            player.Enqueue(new S.GroupInvite { Name = Name });
            player.GroupInvitation = this;

        }
        public void DelMember(string name)
        {
            if (GroupMembers == null)
            {
                ReceiveChat("You are not in a group.", ChatType.System);
                return;
            }
            if (GroupMembers[0] != this)
            {
                ReceiveChat("You are not the group leader.", ChatType.System);
                return;
            }

            PlayerObject player = null;

            for (int i = 0; i < GroupMembers.Count; i++)
            {
                if (String.Compare(GroupMembers[i].Name, name, StringComparison.OrdinalIgnoreCase) != 0) continue;
                player = GroupMembers[i];
                break;
            }


            if (player == null)
            {
                ReceiveChat(name + " is not in your group.", ChatType.System);
                return;
            }

            player.RemoveGroupBuff();

            GroupMembers.Remove(player);
            player.Enqueue(new S.DeleteGroup());

            if (GroupMembers.Count > 1)
            {
                Packet p = new S.DeleteMember { Name = player.Name };

                for (int i = 0; i < GroupMembers.Count; i++)
                    GroupMembers[i].Enqueue(p);
            }
            else
            {
                GroupMembers[0].Enqueue(new S.DeleteGroup());
                GroupMembers[0].GroupMembers = null;
            }
            player.GroupMembers = null;
        }
        public void GroupInvite(bool accept)
        {
            if (GroupInvitation == null)
            {
                ReceiveChat("You have not been invited to a group.", ChatType.System);
                return;
            }

            if (!accept)
            {
                GroupInvitation.ReceiveChat(Name + " has declined your group invite.", ChatType.System);
                GroupInvitation = null;
                return;
            }

            if (GroupMembers != null)
            {
                ReceiveChat(string.Format("You can no longer join {0}'s group", GroupInvitation.Name), ChatType.System);
                GroupInvitation = null;
                return;
            }

            if (GroupInvitation.GroupMembers != null && GroupInvitation.GroupMembers[0] != GroupInvitation)
            {
                ReceiveChat(GroupInvitation.Name + " is no longer the group leader.", ChatType.System);
                GroupInvitation = null;
                return;
            }

            if (GroupInvitation.GroupMembers != null && GroupInvitation.GroupMembers.Count >= Globals.MaxGroup)
            {
                ReceiveChat(GroupInvitation.Name + "'s group already has the maximum number of members.", ChatType.System);
                GroupInvitation = null;
                return;
            }
            if (!GroupInvitation.AllowGroup)
            {
                ReceiveChat(GroupInvitation.Name + " is not on allow group.", ChatType.System);
                GroupInvitation = null;
                return;
            }
            if (GroupInvitation.CurrentMap.Info.NoGroup)
            {
                ReceiveChat(GroupInvitation.Name + " cannot accept invites on solo maps.", ChatType.System);
                GroupInvitation.ReceiveChat(GroupInvitation.Name + " cannot accept invites on solo maps.", ChatType.System);
                GroupInvitation = null;
                return;
            }
            if (GroupInvitation.Node == null)
            {
                ReceiveChat(GroupInvitation.Name + " no longer online.", ChatType.System);
                GroupInvitation = null;
                return;
            }

            if (GroupInvitation.GroupMembers == null)
            {
                GroupInvitation.GroupMembers = new List<PlayerObject> { GroupInvitation };
                GroupInvitation.Enqueue(new S.AddMember { Name = GroupInvitation.Name });
            }

            Packet p = new S.AddMember { Name = Name };
            GroupMembers = GroupInvitation.GroupMembers;
            GroupInvitation = null;

            for (int i = 0; i < GroupMembers.Count; i++)
            {
                PlayerObject member = GroupMembers[i];

                member.Enqueue(p);
                Enqueue(new S.AddMember { Name = member.Name });

                if (CurrentMap != member.CurrentMap || !Functions.InRange(CurrentLocation, member.CurrentLocation, Globals.DataRange)) continue;

                byte time = Math.Min(byte.MaxValue, (byte)Math.Max(5, (RevTime - Envir.Time) / 1000));

                member.Enqueue(new S.ObjectHealth { ObjectID = ObjectID, Percent = PercentHealth, Expire = time });
                Enqueue(new S.ObjectHealth { ObjectID = member.ObjectID, Percent = member.PercentHealth, Expire = time });

                for (int j = 0; j < member.Pets.Count; j++)
                {
                    MonsterObject pet = member.Pets[j];

                    Enqueue(new S.ObjectHealth { ObjectID = pet.ObjectID, Percent = pet.PercentHealth, Expire = time });
                }
            }

            GroupMembers.Add(this);

            if (GroupMembers != null)
            {
                for (int i = 0; i < GroupMembers.Count; i++)
                {
                    PlayerObject player = GroupMembers[i];

                    if (Info.Married == player.Info.Index)
                    {
                        AddBuff(BuffType.RelationshipEXP, player, 0, new Stats { [Stat.LoverExpRatePercent] = Settings.LoverEXPBonus });
                        player.AddBuff(BuffType.RelationshipEXP, this, 0, new Stats { [Stat.LoverExpRatePercent] = Settings.LoverEXPBonus });
                    }

                    if (Info.Mentor == player.Info.Index)
                    {
                        if (Info.isMentor)
                        {
                            AddBuff(BuffType.Mentor, player, 0, new Stats { [Stat.MentorDamageRatePercent] = Settings.MentorDamageBoost });
                            player.AddBuff(BuffType.Mentee, this, 0, new Stats { [Stat.MentorExpRatePercent] = Settings.MentorExpBoost });
                        }
                        else
                        {
                            AddBuff(BuffType.Mentee, player, 0, new Stats { [Stat.MentorExpRatePercent] = Settings.MentorExpBoost });
                            player.AddBuff(BuffType.Mentor, this, 0, new Stats { [Stat.MentorDamageRatePercent] = Settings.MentorDamageBoost });
                        }
                    }
                }
            }

            

            for (int j = 0; j < Pets.Count; j++)
                Pets[j].BroadcastHealthChange();

            Enqueue(p);
        }

        #endregion

        #region Guilds

        public void CreateNewbieGuild(string GuildName)
        {
            if (Envir.GetGuild(GuildName) != null) return;
            //make the guild
            GuildObject guild = new GuildObject(this, GuildName) { Guildindex = ++Envir.NextGuildID };
            guild.Ranks[0].Members.Clear();
            guild.Membercount--;
            Envir.GuildList.Add(guild);
        }
        public bool CreateGuild(string GuildName)
        {
            if ((MyGuild != null) || (Info.GuildIndex != -1)) return false;
            if (Envir.GetGuild(GuildName) != null) return false;
            if (Info.Level < Settings.Guild_RequiredLevel)
            {
                ReceiveChat(String.Format("Your level is not high enough to create a guild, required: {0}", Settings.Guild_RequiredLevel), ChatType.System);
                return false;
            }
            //check if we have the required items
            for (int i = 0; i < Settings.Guild_CreationCostList.Count; i++)
            {
                GuildItemVolume Required = Settings.Guild_CreationCostList[i];
                if (Required.Item == null)
                {
                    if (Info.AccountInfo.Gold < Required.Amount)
                    {
                        ReceiveChat(String.Format("Insufficient gold. Creating a guild requires {0} gold.", Required.Amount), ChatType.System);
                        return false;
                    }
                }
                else
                {
                    ushort count = (ushort)Math.Min(Required.Amount, ushort.MaxValue);

                    foreach (var item in Info.Inventory.Where(item => item != null && item.Info == Required.Item))
                    {
                        if ((Required.Item.Type == ItemType.Ore) && (item.CurrentDura / 1000 > Required.Amount))
                        {
                            count = 0;
                            break;
                        }
                        if (item.Count > count)
                            count = 0;
                        else
                            count = (ushort)(count - item.Count);
                        if (count == 0) break;
                    }
                    if (count != 0)
                    {
                        if (Required.Amount == 1)
                            ReceiveChat(String.Format("{0} is required to create a guild.", Required.Item.FriendlyName), ChatType.System);
                        else
                        {
                            if (Required.Item.Type == ItemType.Ore)
                                ReceiveChat(string.Format("{0} with purity {1} is recuired to create a guild.", Required.Item.FriendlyName, Required.Amount / 1000), ChatType.System);
                            else
                                ReceiveChat(string.Format("Insufficient {0}, you need {1} to create a guild.", Required.Item.FriendlyName, Required.Amount), ChatType.System);
                        }
                        return false;
                    }
                }
            }
            //take the required items
            for (int i = 0; i < Settings.Guild_CreationCostList.Count; i++)
            {
                GuildItemVolume Required = Settings.Guild_CreationCostList[i];
                if (Required.Item == null)
                {
                    if (Info.AccountInfo.Gold >= Required.Amount)
                    {
                        Info.AccountInfo.Gold -= Required.Amount;
                        Enqueue(new S.LoseGold { Gold = Required.Amount });
                    }
                }
                else
                {
                    ushort count = (ushort)Math.Min(Required.Amount, ushort.MaxValue);

                    for (int o = 0; o < Info.Inventory.Length; o++)
                    {
                        UserItem item = Info.Inventory[o];
                        if (item == null) continue;
                        if (item.Info != Required.Item) continue;

                        if ((Required.Item.Type == ItemType.Ore) && (item.CurrentDura / 1000 > Required.Amount))
                        {
                            Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                            Info.Inventory[o] = null;
                            break;
                        }
                        if (count > item.Count)
                        {
                            Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                            Info.Inventory[o] = null;
                            count -= item.Count;
                            continue;
                        }

                        Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = (ushort)count });
                        if (count == item.Count)
                            Info.Inventory[o] = null;
                        else
                            item.Count -= (ushort)count;
                        break;
                    }
                }
            }
            RefreshStats();
            //make the guild
            GuildObject guild = new GuildObject(this, GuildName) { Guildindex = ++Envir.NextGuildID };
            Envir.GuildList.Add(guild);
            Info.GuildIndex = guild.Guildindex;
            MyGuild = guild;
            MyGuildRank = guild.FindRank(Name);
            GuildMembersChanged = true;
            GuildNoticeChanged = true;
            GuildCanRequestItems = true;
            //tell us we now have a guild
            BroadcastInfo();
            MyGuild.SendGuildStatus(this);
            return true;
        }
        public void EditGuildMember(string Name, string RankName, byte RankIndex, byte ChangeType)
        {
            if ((MyGuild == null) || (MyGuildRank == null))
            {
                ReceiveChat(GameLanguage.NotInGuild, ChatType.System);
                return;
            }
            switch (ChangeType)
            {
                case 0: //add member
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanRecruit))
                    {
                        ReceiveChat("You are not allowed to recruit new members!", ChatType.System);
                        return;
                    }
                    if (Name == "") return;
                    PlayerObject player = Envir.GetPlayer(Name);
                    if (player == null)
                    {
                        ReceiveChat(String.Format("{0} is not online!", Name), ChatType.System);
                        return;
                    }
                    if ((player.MyGuild != null) || (player.MyGuildRank != null) || (player.Info.GuildIndex != -1))
                    {
                        ReceiveChat(String.Format("{0} is already in a guild!", Name), ChatType.System);
                        return;
                    }
                    if (!player.EnableGuildInvite)
                    {
                        ReceiveChat(String.Format("{0} is disabling guild invites!", Name), ChatType.System);
                        return;
                    }
                    if (player.PendingGuildInvite != null)
                    {
                        ReceiveChat(string.Format("{0} already has a guild invite pending.", Name), ChatType.System);
                        return;
                    }

                    if (MyGuild.IsAtWar())
                    {
                        ReceiveChat("Cannot recuit members whilst at war.", ChatType.System);
                        return;
                    }

                    player.Enqueue(new S.GuildInvite { Name = MyGuild.Name });
                    player.PendingGuildInvite = MyGuild;
                    break;
                case 1: //delete member
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanKick))
                    {
                        ReceiveChat("You are not allowed to remove members!", ChatType.System);
                        return;
                    }
                    if (Name == "") return;

                    if (!MyGuild.DeleteMember(this, Name))
                    {
                        return;
                    }
                    break;
                case 2: //promote member (and it'll auto create a new rank at bottom if the index > total ranks!)
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeRank))
                    {
                        ReceiveChat("You are not allowed to change other members rank!", ChatType.System);
                        return;
                    }
                    if (Name == "") return;
                    MyGuild.ChangeRank(this, Name, RankIndex, RankName);
                    break;
                case 3: //change rank name
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeRank))
                    {
                        ReceiveChat("You are not allowed to change ranks!", ChatType.System);
                        return;
                    }
                    if ((RankName == "") || (RankName.Length < 3))
                    {
                        ReceiveChat("Rank name to short!", ChatType.System);
                        return;
                    }
                    if (RankName.Contains("\\") || RankName.Length > 20)
                    {
                        return;
                    }
                    if (!MyGuild.ChangeRankName(this, RankName, RankIndex))
                        return;
                    break;
                case 4: //new rank
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeRank))
                    {
                        ReceiveChat("You are not allowed to change ranks!", ChatType.System);
                        return;
                    }
                    if (MyGuild.Ranks.Count > 254)
                    {
                        ReceiveChat("No more rank slots available.", ChatType.System);
                        return;
                    }
                    MyGuild.NewRank(this);
                    break;
                case 5: //change rank setting
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeRank))
                    {
                        ReceiveChat("You are not allowed to change ranks!", ChatType.System);
                        return;
                    }
                    int temp;

                    if (!int.TryParse(RankName, out temp))
                    {
                        return;
                    }
                    MyGuild.ChangeRankOption(this, RankIndex, temp, Name);
                    break;
            }
        }
        public void EditGuildNotice(List<string> notice)
        {
            if ((MyGuild == null) || (MyGuildRank == null))
            {
                ReceiveChat(GameLanguage.NotInGuild, ChatType.System);
                return;
            }
            if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanChangeNotice))
            {

                ReceiveChat("You are not allowed to change the guild notice!", ChatType.System);
                return;
            }
            if (notice.Count > 200)
            {
                ReceiveChat("Guild notice can not be longer then 200 lines!", ChatType.System);
                return;
            }
            MyGuild.NewNotice(notice);
        }
        public void GuildInvite(bool accept)
        {
            if (PendingGuildInvite == null)
            {
                ReceiveChat("You have not been invited to a guild.", ChatType.System);
                return;
            }
            if (!accept) return;
            if (!PendingGuildInvite.HasRoom())
            {
                ReceiveChat(String.Format("{0} is full.", PendingGuildInvite.Name), ChatType.System);
                return;
            }
            PendingGuildInvite.NewMember(this);
            Info.GuildIndex = PendingGuildInvite.Guildindex;
            MyGuild = PendingGuildInvite;
            MyGuildRank = PendingGuildInvite.FindRank(Name);
            GuildMembersChanged = true;
            GuildNoticeChanged = true;
            //tell us we now have a guild
            BroadcastInfo();
            MyGuild.SendGuildStatus(this);
            PendingGuildInvite = null;
            EnableGuildInvite = false;
            GuildCanRequestItems = true;
            //refresh guildbuffs
            RefreshStats();
            if (MyGuild.BuffList.Count > 0)
                Enqueue(new S.GuildBuffList() { ActiveBuffs = MyGuild.BuffList});
        }
        public void RequestGuildInfo(byte Type)
        {
            if (MyGuild == null) return;
            if (MyGuildRank == null) return;
            switch (Type)
            {
                case 0://notice
                    if (GuildNoticeChanged)
                        Enqueue(new S.GuildNoticeChange() { notice = MyGuild.Notice });
                    GuildNoticeChanged = false;
                    break;
                case 1://memberlist
                    if (GuildMembersChanged)
                        Enqueue(new S.GuildMemberChange() { Status = 255, Ranks = MyGuild.Ranks });
                    break;
            }
        }
        public void GuildNameReturn(string Name)
        {
            if (Name == "") CanCreateGuild = false;
            if (!CanCreateGuild) return;
            if ((Name.Length < 3) || (Name.Length > 20))
            {
                ReceiveChat("Guild name too long.", ChatType.System);
                CanCreateGuild = false;
                return;
            }
            if (Name.Contains('\\'))
            {
                CanCreateGuild = false;
                return;
            }
            if (MyGuild != null)
            {
                ReceiveChat("You are already part of a guild.", ChatType.System);
                CanCreateGuild = false;
                return;
            }
            GuildObject guild = Envir.GetGuild(Name);
            if (guild != null)
            {
                ReceiveChat(string.Format("Guild {0} already exists.", Name), ChatType.System);
                CanCreateGuild = false;
                return;
            }

            CreateGuild(Name);
            CanCreateGuild = false;
        }
        public void GuildStorageGoldChange(byte type, uint amount)
        {
            if ((MyGuild == null) || (MyGuildRank == null))
            {
                ReceiveChat("You are not part of a guild.", ChatType.System);
                return;
            }

            if (!InSafeZone)
            {
                ReceiveChat("You cannot use guild storage outside safezones.", ChatType.System);
                return;
            }

            if (type == 0)//donate
            {
                if (Account.Gold < amount)
                {
                    ReceiveChat("Insufficient gold.", ChatType.System);
                    return;
                }
                if ((MyGuild.Gold + (ulong)amount) > uint.MaxValue)
                {
                    ReceiveChat("Guild gold limit reached.", ChatType.System);
                    return;
                }

                Account.Gold -= amount;
                MyGuild.Gold += amount;
                Enqueue(new S.LoseGold { Gold = amount });
                MyGuild.SendServerPacket(new S.GuildStorageGoldChange() { Type = 0, Name = Info.Name, Amount = amount });
                MyGuild.NeedSave = true;
            }
            else
            {
                if (MyGuild.Gold < amount)
                {
                    ReceiveChat("Insufficient gold.", ChatType.System);
                    return;
                }
                if (!CanGainGold(amount))
                {
                    ReceiveChat("Gold limit reached.", ChatType.System);
                    return;
                }
                if (MyGuildRank.Index != 0)
                {
                    ReceiveChat("Insufficient rank.", ChatType.System);
                    return;
                }

                MyGuild.Gold -= amount;
                GainGold(amount);
                MyGuild.SendServerPacket(new S.GuildStorageGoldChange() { Type = 1, Name = Info.Name, Amount = amount });
                MyGuild.NeedSave = true;
            }
        }
        public void GuildStorageItemChange(byte type, int from, int to)
        {
            S.GuildStorageItemChange p = new S.GuildStorageItemChange { Type = (byte)(3 + type), From = from, To = to };
            if ((MyGuild == null) || (MyGuildRank == null))
            {
                Enqueue(p);
                ReceiveChat("You are not part of a guild.", ChatType.System);
                return;
            }

            if (!InSafeZone && type != 3)
            {
                Enqueue(p);
                ReceiveChat("You cannot use guild storage outside safezones.", ChatType.System);
                return;
            }

            switch (type)
            {
                case 0://store
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanStoreItem))
                    {
                        Enqueue(p);
                        ReceiveChat("You do not have permission to store items in guild storage.", ChatType.System);
                        return;
                    }
                    if (from < 0 || from >= Info.Inventory.Length)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (to < 0 || to >= MyGuild.StoredItems.Length)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (Info.Inventory[from] == null)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (Info.Inventory[from].Info.Bind.HasFlag(BindMode.DontStore))
                    {
                        Enqueue(p);
                        return;
                    }
                    if (Info.Inventory[from].RentalInformation != null && Info.Inventory[from].RentalInformation.BindingFlags.HasFlag(BindMode.DontStore))
                    {
                        Enqueue(p);
                        return;
                    }
                    if (MyGuild.StoredItems[to] != null)
                    {
                        ReceiveChat("Target slot not empty.", ChatType.System);
                        Enqueue(p);
                        return;
                    }
                    MyGuild.StoredItems[to] = new GuildStorageItem() { Item = Info.Inventory[from], UserId = Info.Index };
                    Info.Inventory[from] = null;
                    RefreshBagWeight();
                    MyGuild.SendItemInfo(MyGuild.StoredItems[to].Item);
                    MyGuild.SendServerPacket(new S.GuildStorageItemChange() { Type = 0, User = Info.Index, Item = MyGuild.StoredItems[to], To = to, From = from });
                    MyGuild.NeedSave = true;
                    break;
                case 1://retrieve
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanRetrieveItem))
                    {

                        ReceiveChat("You do not have permission to retrieve items from guild storage.", ChatType.System);
                        return;
                    }
                    if (from < 0 || from >= MyGuild.StoredItems.Length)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (to < 0 || to >= Info.Inventory.Length)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (Info.Inventory[to] != null)
                    {
                        ReceiveChat("Target slot not empty.", ChatType.System);
                        Enqueue(p);
                        return;
                    }
                    if (MyGuild.StoredItems[from] == null)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (Stats[Stat.BagWeight] < CurrentBagWeight + MyGuild.StoredItems[from].Item.Weight)
                    {
                        ReceiveChat("Too overweight to retrieve item.", ChatType.System);
                        Enqueue(p);
                        return;
                    }
                    if (MyGuild.StoredItems[from].Item.Info.Bind.HasFlag(BindMode.DontStore))
                    {
                        Enqueue(p);
                        return;
                    }
                    Info.Inventory[to] = MyGuild.StoredItems[from].Item;
                    MyGuild.StoredItems[from] = null;
                    MyGuild.SendServerPacket(new S.GuildStorageItemChange() { Type = 1, User = Info.Index, To = to, From = from });
                    RefreshBagWeight();
                    MyGuild.NeedSave = true;
                    break;
                case 2: // Move Item
                    GuildStorageItem q = null;
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanStoreItem))
                    {
                        Enqueue(p);
                        ReceiveChat("You do not have permission to move items in guild storage.", ChatType.System);
                        return;
                    }
                    if (from < 0 || from >= MyGuild.StoredItems.Length)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (to < 0 || to >= MyGuild.StoredItems.Length)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (MyGuild.StoredItems[from] == null)
                    {
                        Enqueue(p);
                        return;
                    }
                    if (MyGuild.StoredItems[from].Item.Info.Bind.HasFlag(BindMode.DontStore))
                    {
                        Enqueue(p);
                        return;
                    }
                    if (MyGuild.StoredItems[to] != null)
                    {
                        q = MyGuild.StoredItems[to];
                    }
                    MyGuild.StoredItems[to] = MyGuild.StoredItems[from];
                    if (q != null) MyGuild.StoredItems[from] = q;
                    else MyGuild.StoredItems[from] = null;

                    MyGuild.SendItemInfo(MyGuild.StoredItems[to].Item);

                    if (MyGuild.StoredItems[from] != null) MyGuild.SendItemInfo(MyGuild.StoredItems[from].Item);

                    MyGuild.SendServerPacket(new S.GuildStorageItemChange() { Type = 2, User = Info.Index, Item = MyGuild.StoredItems[to], To = to, From = from });
                    MyGuild.NeedSave = true;
                    break;
                case 3://request list
                    if (!GuildCanRequestItems) return;
                    GuildCanRequestItems = false;
                    for (int i = 0; i < MyGuild.StoredItems.Length; i++)
                    {
                        if (MyGuild.StoredItems[i] == null) continue;
                        UserItem item = MyGuild.StoredItems[i].Item;
                        if (item == null) continue;
                        //CheckItemInfo(item.Info);
                        CheckItem(item);
                    }
                    Enqueue(new S.GuildStorageList() { Items = MyGuild.StoredItems });
                    break;
            }

        }
        public void GuildWarReturn(string Name)
        {
            if (MyGuild == null || MyGuildRank != MyGuild.Ranks[0]) return;

            GuildObject enemyGuild = Envir.GetGuild(Name);

            if (enemyGuild == null)
            {
                ReceiveChat(string.Format("Could not find guild {0}.", Name), ChatType.System);
                return;
            }

            if (MyGuild == enemyGuild)
            {
                ReceiveChat("Cannot go to war with your own guild.", ChatType.System);
                return;
            }

            if (MyGuild.WarringGuilds.Contains(enemyGuild))
            {
                ReceiveChat("Already at war with this guild.", ChatType.System);
                return;
            }

            if (MyGuild.Gold < Settings.Guild_WarCost)
            {
                ReceiveChat("Not enough funds in guild bank.", ChatType.System);
                return;
            }

            if (MyGuild.GoToWar(enemyGuild))
            {
                ReceiveChat(string.Format("You started a war with {0}.", Name), ChatType.System);
                enemyGuild.SendMessage(string.Format("{0} has started a war", MyGuild.Name), ChatType.System);

                MyGuild.Gold -= Settings.Guild_WarCost;
                MyGuild.SendServerPacket(new S.GuildStorageGoldChange() { Type = 2, Name = Info.Name, Amount = Settings.Guild_WarCost });
            }
        }

        public bool AtWar(PlayerObject attacker)
        {
            if (CurrentMap.Info.Fight) return true;

            if (MyGuild == null) return false;

            if (attacker == null || attacker.MyGuild == null) return false;

            if (!MyGuild.WarringGuilds.Contains(attacker.MyGuild)) return false;

            return true;
        }

        public void GuildBuffUpdate(byte type, int id)
        {
            if (MyGuild == null) return;
            if (MyGuildRank == null) return;
            if (id < 0) return;
            switch (type)
            {
                case 0://request info list
                    if (RequestedGuildBuffInfo) return;
                    Enqueue(new S.GuildBuffList() { GuildBuffs = Settings.Guild_BuffList });
                    break;
                case 1://buy the buff
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanActivateBuff))
                    {
                        ReceiveChat("You do not have the correct guild rank.", ChatType.System);
                        return;
                    }
                    GuildBuffInfo BuffInfo = Envir.FindGuildBuffInfo(id);
                    if (BuffInfo == null)
                    {
                        ReceiveChat("Buff does not excist.", ChatType.System);
                        return;
                    }
                    if (MyGuild.GetBuff(id) != null)
                    {
                        ReceiveChat("Buff already obtained.", ChatType.System);
                        return;
                    }
                    if ((MyGuild.Level < BuffInfo.LevelRequirement) || (MyGuild.SparePoints < BuffInfo.PointsRequirement)) return;//client checks this so it shouldnt be possible without a moded client :p
                    MyGuild.NewBuff(id);
                    break;
                case 2://activate the buff
                    if (!MyGuildRank.Options.HasFlag(GuildRankOptions.CanActivateBuff))
                    {
                        ReceiveChat("You do not have the correct guild rank.", ChatType.System);
                        return;
                    }
                    GuildBuff Buff = MyGuild.GetBuff(id);
                    if (Buff == null)
                    {
                        ReceiveChat("Buff not obtained.", ChatType.System);
                        return;
                    }
                    if ((MyGuild.Gold < Buff.Info.ActivationCost) || (Buff.Active)) return;
                    MyGuild.ActivateBuff(id);
                    break;
            }
        }

        #endregion

        #region Trading

        public void DepositTradeItem(int from, int to)
        {
            S.DepositTradeItem p = new S.DepositTradeItem { From = from, To = to, Success = false };

            if (from < 0 || from >= Info.Inventory.Length)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Info.Trade.Length)
            {
                Enqueue(p);
                return;
            }

            UserItem temp = Info.Inventory[from];

            if (temp == null)
            {
                Enqueue(p);
                return;
            }

            if (temp.Info.Bind.HasFlag(BindMode.DontTrade))
            {
                Enqueue(p);
                return;
            }

            if (temp.RentalInformation != null && temp.RentalInformation.BindingFlags.HasFlag(BindMode.DontTrade))
            {
                Enqueue(p);
                return;
            }

            if (Info.Trade[to] == null)
            {
                Info.Trade[to] = temp;
                Info.Inventory[from] = null;
                RefreshBagWeight();
                TradeItem();

                Report.ItemMoved(temp, MirGridType.Inventory, MirGridType.Trade, from, to);
                
                p.Success = true;
                Enqueue(p);
                return;
            }
            Enqueue(p);

        }
        public void RetrieveTradeItem(int from, int to)
        {
            S.RetrieveTradeItem p = new S.RetrieveTradeItem { From = from, To = to, Success = false };

            if (from < 0 || from >= Info.Trade.Length)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Info.Inventory.Length)
            {
                Enqueue(p);
                return;
            }

            UserItem temp = Info.Trade[from];

            if (temp == null)
            {
                Enqueue(p);
                return;
            }

            if (temp.Weight + CurrentBagWeight > Stats[Stat.BagWeight])
            {
                ReceiveChat("Too heavy to get back.", ChatType.System);
                Enqueue(p);
                return;
            }

            if (Info.Inventory[to] == null)
            {
                Info.Inventory[to] = temp;
                Info.Trade[from] = null;

                p.Success = true;
                RefreshBagWeight();
                TradeItem();

                Report.ItemMoved(temp, MirGridType.Trade, MirGridType.Inventory, from, to);
            }

            Enqueue(p);
        }

        

        public void TradeRequest()
        {
            if (Envir.Time < NextTradeTime) return;
            NextTradeTime = Envir.Time + Settings.TradeDelay;

            if (TradePartner != null)
            {
                ReceiveChat("You are already trading.", ChatType.System);
                return;
            }

            Point target = Functions.PointMove(CurrentLocation, Direction, 1);
            Cell cell = CurrentMap.GetCell(target);
            PlayerObject player = null;

            if (cell.Objects == null || cell.Objects.Count == 0) 
            {
                ReceiveChat(GameLanguage.FaceToTrade, ChatType.System);
                return;
            } 

            for (int i = 0; i < cell.Objects.Count; i++)
            {
                MapObject ob = cell.Objects[i];
                if (ob.Race != ObjectType.Player) continue;

                player = Envir.GetPlayer(ob.Name);
            }

            if (player == null)
            {
                ReceiveChat(GameLanguage.FaceToTrade, ChatType.System);
                return;
            }

            if (player != null)
            {
                if (!Functions.FacingEachOther(Direction, CurrentLocation, player.Direction, player.CurrentLocation))
                {
                    ReceiveChat(GameLanguage.FaceToTrade, ChatType.System);
                    return;
                }

                if (player == this)
                {
                    ReceiveChat("You cannot trade with your self.", ChatType.System);
                    return;
                }

                if (player.Dead || Dead)
                {
                    ReceiveChat("Cannot trade when dead", ChatType.System);
                    return;
                }

                if (player.TradeInvitation != null)
                {
                    ReceiveChat(string.Format("Player {0} already has a trade invitation.", player.Info.Name), ChatType.System);
                    return;
                }

                if (!player.AllowTrade)
                {
                    ReceiveChat(string.Format("Player {0} is not allowing trade at the moment.", player.Info.Name), ChatType.System);
                    return;
                }

                if (!Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) || player.CurrentMap != CurrentMap)
                {
                    ReceiveChat(string.Format("Player {0} is not within trading range.", player.Info.Name), ChatType.System);
                    return;
                }

                if (player.TradePartner != null)
                {
                    ReceiveChat(string.Format("Player {0} is already trading.", player.Info.Name), ChatType.System);
                    return;
                }

                player.TradeInvitation = this;
                player.Enqueue(new S.TradeRequest { Name = Info.Name });
            }
        }
        public void TradeReply(bool accept)
        {
            if (TradeInvitation == null || TradeInvitation.Info == null)
            {
                TradeInvitation = null;
                return;
            }

            if (!accept)
            {
                TradeInvitation.ReceiveChat(string.Format("Player {0} has refused to trade.", Info.Name), ChatType.System);
                TradeInvitation = null;
                return;
            }

            if (TradePartner != null)
            {
                ReceiveChat("You are already trading.", ChatType.System);
                TradeInvitation = null;
                return;
            }

            if (TradeInvitation.TradePartner != null)
            {
                ReceiveChat(string.Format("Player {0} is already trading.", TradeInvitation.Info.Name), ChatType.System);
                TradeInvitation = null;
                return;
            }

            TradePartner = TradeInvitation;
            TradeInvitation.TradePartner = this;
            TradeInvitation = null;

            Enqueue(new S.TradeAccept { Name = TradePartner.Info.Name });
            TradePartner.Enqueue(new S.TradeAccept { Name = Info.Name });
        }
        public void TradeGold(uint amount)
        {
            TradeUnlock();

            if (TradePartner == null) return;

            if (Account.Gold < amount)
            {
                return;
            }

            TradeGoldAmount += amount;
            Account.Gold -= amount;

            Enqueue(new S.LoseGold { Gold = amount });
            TradePartner.Enqueue(new S.TradeGold { Amount = TradeGoldAmount });
        }
        public void TradeItem()
        {
            TradeUnlock();

            if (TradePartner == null) return;

            for (int i = 0; i < Info.Trade.Length; i++)
            {
                UserItem u = Info.Trade[i];
                if (u == null) continue;

                //TradePartner.CheckItemInfo(u.Info);
                TradePartner.CheckItem(u);
            }

            TradePartner.Enqueue(new S.TradeItem { TradeItems = Info.Trade });
        }

        public void TradeUnlock()
        {
            TradeLocked = false;

            if (TradePartner != null)
            {
                TradePartner.TradeLocked = false;
            }
        }

        public void TradeConfirm(bool confirm)
        {
            if(!confirm)
            {
                TradeLocked = false;
                return;
            }

            if (TradePartner == null)
            {
                TradeCancel();
                return;
            }

            if (!Functions.InRange(TradePartner.CurrentLocation, CurrentLocation, Globals.DataRange) || TradePartner.CurrentMap != CurrentMap ||
                !Functions.FacingEachOther(Direction, CurrentLocation, TradePartner.Direction, TradePartner.CurrentLocation))
            {
                TradeCancel();
                return;
            }

            TradeLocked = true;

            if (TradeLocked && !TradePartner.TradeLocked)
            {
                TradePartner.ReceiveChat(string.Format("Player {0} is waiting for you to confirm trade.", Info.Name), ChatType.System);
            }

            if (!TradeLocked || !TradePartner.TradeLocked) return;

            PlayerObject[] TradePair = new PlayerObject[2] { TradePartner, this };

            bool CanTrade = true;
            UserItem u;

            //check if both people can accept the others items
            for (int p = 0; p < 2; p++)
            {
                int o = p == 0 ? 1 : 0;

                if (!TradePair[o].CanGainItems(TradePair[p].Info.Trade))
                {
                    CanTrade = false;
                    TradePair[p].ReceiveChat("Trading partner cannot accept all items.", ChatType.System);
                    TradePair[p].Enqueue(new S.TradeCancel { Unlock = true });

                    TradePair[o].ReceiveChat("Unable to accept all items.", ChatType.System);
                    TradePair[o].Enqueue(new S.TradeCancel { Unlock = true });

                    return;
                }

                if (!TradePair[o].CanGainGold(TradePair[p].TradeGoldAmount))
                {
                    CanTrade = false;
                    TradePair[p].ReceiveChat("Trading partner cannot accept any more gold.", ChatType.System);
                    TradePair[p].Enqueue(new S.TradeCancel { Unlock = true });

                    TradePair[o].ReceiveChat("Unable to accept any more gold.", ChatType.System);
                    TradePair[o].Enqueue(new S.TradeCancel { Unlock = true });

                    return;
                }
            }

            //swap items
            if (CanTrade)
            {
                for (int p = 0; p < 2; p++)
                {
                    int o = p == 0 ? 1 : 0;

                    for (int i = 0; i < TradePair[p].Info.Trade.Length; i++)
                    {
                        u = TradePair[p].Info.Trade[i];

                        if (u == null) continue;

                        TradePair[o].GainItem(u);
                        TradePair[p].Info.Trade[i] = null;

                        Report.ItemMoved(u, MirGridType.Trade, MirGridType.Inventory, i, -99, string.Format("Trade from {0} to {1}", TradePair[p].Name, TradePair[o].Name));
                    }

                    if (TradePair[p].TradeGoldAmount > 0)
                    {
                        Report.GoldChanged(TradePair[p].TradeGoldAmount, true, string.Format("Trade from {0} to {1}", TradePair[p].Name, TradePair[o].Name));

                        TradePair[o].GainGold(TradePair[p].TradeGoldAmount);
                        TradePair[p].TradeGoldAmount = 0;
                    }

                    TradePair[p].ReceiveChat("Trade successful.", ChatType.System);
                    TradePair[p].Enqueue(new S.TradeConfirm());

                    TradePair[p].TradeLocked = false;
                    TradePair[p].TradePartner = null;
                }
            }
        }
        public void TradeCancel()
        {
            TradeUnlock();

            if (TradePartner == null)
            {
                return;
            }

            PlayerObject[] TradePair = new PlayerObject[2] { TradePartner, this };

            for (int p = 0; p < 2; p++)
            {
                if (TradePair[p] != null)
                {
                    for (int t = 0; t < TradePair[p].Info.Trade.Length; t++)
                    {
                        UserItem temp = TradePair[p].Info.Trade[t];

                        if (temp == null) continue;

                        if(FreeSpace(TradePair[p].Info.Inventory) < 1)
                        {
                            TradePair[p].GainItemMail(temp, 1);
                            Report.ItemMailed(temp, temp.Count, 1);

                            TradePair[p].Enqueue(new S.DeleteItem { UniqueID = temp.UniqueID, Count = temp.Count });
                            TradePair[p].Info.Trade[t] = null;
                            continue;
                        }

                        for (int i = 0; i < TradePair[p].Info.Inventory.Length; i++)
                        {
                            if (TradePair[p].Info.Inventory[i] != null) continue;

                            //Put item back in inventory
                            if (TradePair[p].CanGainItem(temp))
                            {
                                TradePair[p].RetrieveTradeItem(t, i);
                            }
                            else //Send item to mailbox if it can no longer be stored
                            {
                                TradePair[p].GainItemMail(temp, 1);
                                Report.ItemMailed(temp, temp.Count, 1);

                                TradePair[p].Enqueue(new S.DeleteItem { UniqueID = temp.UniqueID, Count = temp.Count });
                            }

                            TradePair[p].Info.Trade[t] = null;

                            break;
                        }
                    }

                    //Put back deposited gold
                    if (TradePair[p].TradeGoldAmount > 0)
                    {
                        Report.GoldChanged(TradePair[p].TradeGoldAmount, false);

                        TradePair[p].GainGold(TradePair[p].TradeGoldAmount);
                        TradePair[p].TradeGoldAmount = 0;
                    }

                    TradePair[p].TradeLocked = false;
                    TradePair[p].TradePartner = null;

                    TradePair[p].Enqueue(new S.TradeCancel { Unlock = false });
                }
            }
        }

        #endregion

        #region Mounts

        public void RefreshMount(bool refreshStats = true)
        {
            if (RidingMount)
            {
                if (MountType < 0)
                {
                    RidingMount = false;
                }
                else if (!Mount.CanRide)
                {
                    RidingMount = false;
                    ReceiveChat("You must have a saddle to ride your mount", ChatType.System);
                }
                else if (!Mount.CanMapRide)
                {
                    RidingMount = false;
                    ReceiveChat("You cannot ride on this map", ChatType.System);
                }
                else if (!Mount.CanDungeonRide)
                {
                    RidingMount = false;
                    ReceiveChat("You cannot ride here without a bridle", ChatType.System);
                }
            }
            else
            {
                RidingMount = false;
            }

            if(refreshStats)
                RefreshStats();

            Broadcast(GetMountInfo());
            Enqueue(GetMountInfo());
        }
        public void IncreaseMountLoyalty(int amount)
        {
            UserItem item = Info.Equipment[(int)EquipmentSlot.Mount];
            if (item != null && item.CurrentDura < item.MaxDura)
            {
                item.CurrentDura = (ushort)Math.Min(item.MaxDura, item.CurrentDura + amount);
                item.DuraChanged = false;
                Enqueue(new S.ItemRepaired { UniqueID = item.UniqueID, MaxDura = item.MaxDura, CurrentDura = item.CurrentDura });
            }
        }
        public void DecreaseMountLoyalty(int amount)
        {
            if (Envir.Time > DecreaseLoyaltyTime)
            {
                DecreaseLoyaltyTime = Envir.Time + (Mount.SlowLoyalty ? (LoyaltyDelay * 2) : LoyaltyDelay);
                UserItem item = Info.Equipment[(int)EquipmentSlot.Mount];
                if (item != null && item.CurrentDura > 0)
                {
                    DamageItem(item, amount);

                    if (item.CurrentDura == 0)
                    {
                        RefreshMount();
                    }
                }
            }
        }

        #endregion

        #region Fishing

        public void FishingCast(bool cast, bool cancel = false)
        {
            UserItem rod = Info.Equipment[(int)EquipmentSlot.Weapon];

            byte flexibilityStat = 0;
            sbyte successStat = 0;
            byte nibbleMin = 0, nibbleMax = 0;
            byte failedAddSuccessMin = 0, failedAddSuccessMax = 0;
            FishingProgressMax = Settings.FishingAttempts;//30;

            if (rod == null || !rod.Info.IsFishingRod || rod.CurrentDura == 0)
            {
                Fishing = false;
                return;
            }

            Point fishingPoint = Functions.PointMove(CurrentLocation, Direction, 3);

            if (fishingPoint.X < 0 || fishingPoint.Y < 0 || CurrentMap.Width < fishingPoint.X || CurrentMap.Height < fishingPoint.Y)
            {
                Fishing = false;
                return;
            }

            Cell fishingCell = CurrentMap.Cells[fishingPoint.X, fishingPoint.Y];

            if (fishingCell.FishingAttribute < 0)
            {
                Fishing = false;
                return;
            }

            flexibilityStat = (byte)Math.Max(byte.MinValue, (Math.Min(byte.MaxValue, flexibilityStat + rod.Info.Stats[Stat.CriticalRate])));
            successStat = (sbyte)Math.Max(sbyte.MinValue, (Math.Min(sbyte.MaxValue, successStat + rod.Info.Stats[Stat.MaxAC])));

            if (cast)
            {
                DamageItem(rod, 1, true);
            }

            UserItem hook = rod.Slots[(int)FishingSlot.Hook];

            if (hook == null)
            {
                ReceiveChat("You need a hook.", ChatType.System);
                return;
            }
            else
            {
                DamagedFishingItem(FishingSlot.Hook, 1);
            }

            foreach (UserItem temp in rod.Slots)
            {
                if (temp == null) continue;

                ItemInfo realItem = Functions.GetRealItem(temp.Info, Info.Level, Info.Class, Envir.ItemInfoList);

                switch (realItem.Type)
                {
                    case ItemType.Hook:
                        {
                            flexibilityStat = (byte)Math.Max(byte.MinValue, (Math.Min(byte.MaxValue, flexibilityStat + temp.AddedStats[Stat.CriticalRate] + realItem.Stats[Stat.CriticalRate])));
                        }
                        break;
                    case ItemType.Float:
                        {
                            nibbleMin = (byte)Math.Max(byte.MinValue, (Math.Min(byte.MaxValue, nibbleMin + realItem.Stats[Stat.MinAC])));
                            nibbleMax = (byte)Math.Max(byte.MinValue, (Math.Min(byte.MaxValue, nibbleMax + realItem.Stats[Stat.MaxAC])));
                        }
                        break;
                    case ItemType.Bait:
                        {
                            successStat = (sbyte)Math.Max(sbyte.MinValue, (Math.Min(sbyte.MaxValue, successStat + realItem.Stats[Stat.MaxAC])));
                        }
                        break;
                    case ItemType.Finder:
                        {
                            failedAddSuccessMin = (byte)Math.Max(byte.MinValue, (Math.Min(byte.MaxValue, failedAddSuccessMin + realItem.Stats[Stat.MinAC])));
                            failedAddSuccessMax = (byte)Math.Max(byte.MinValue, (Math.Min(byte.MaxValue, failedAddSuccessMax + realItem.Stats[Stat.MaxAC])));
                        }
                        break;
                    case ItemType.Reel:
                        {
                            FishingAutoReelChance = (sbyte)Math.Max(sbyte.MinValue, (Math.Min(sbyte.MaxValue, FishingAutoReelChance + realItem.Stats[Stat.MaxMAC])));
                            successStat = (sbyte)Math.Max(sbyte.MinValue, (Math.Min(sbyte.MaxValue, successStat + realItem.Stats[Stat.MaxAC])));
                        }
                        break;
                    default:
                        break;
                }
            }

            FishingNibbleChance = 5 + Envir.Random.Next(nibbleMin, nibbleMax);

            if (cast) FishingChance = Settings.FishingSuccessStart + (int)successStat + (FishingChanceCounter != 0 ? Envir.Random.Next(failedAddSuccessMin, failedAddSuccessMax) : 0) + (FishingChanceCounter * Settings.FishingSuccessMultiplier); //10 //10
            if (FishingChanceCounter != 0) DamagedFishingItem(FishingSlot.Finder, 1);
            FishingChance += Stats[Stat.FishRatePercent];

            FishingChance = Math.Min(100, Math.Max(0, FishingChance));
            FishingNibbleChance = Math.Min(100, Math.Max(0, FishingNibbleChance));
            FishingAutoReelChance = Math.Min(100, Math.Max(0, FishingAutoReelChance));

            FishingTime = Envir.Time + FishingCastDelay + Settings.FishingDelay;

            if (cast)
            {
                if (Fishing) return;

                _fishCounter = 0;
                FishFound = false;

                UserItem item = GetBait(1);

                if (item == null)
                {
                    ReceiveChat("You need bait.", ChatType.System);
                    return;
                }

                ConsumeItem(item, 1);
                Fishing = true;
            }
            else
            {
                if (!Fishing)
                {
                    Enqueue(GetFishInfo());
                    return;
                }

                Fishing = false;

                if (FishingProgress > 99)
                {
                    FishingChanceCounter++;
                }

                if (FishFound)
                {
                    int getChance = FishingChance + Envir.Random.Next(10, 24) + (FishingProgress > 50 ? flexibilityStat / 2 : 0);
                    getChance = Math.Min(100, Math.Max(0, getChance));

                    if (Envir.Random.Next(0, 100) <= getChance)
                    {
                        FishingChanceCounter = 0;

                        UserItem dropItem = null;

                        foreach (DropInfo drop in Envir.FishingDrops.Where(x => x.Type == fishingCell.FishingAttribute))
                        {
                            var reward = drop.AttemptDrop(EXPOwner?.Stats[Stat.ItemDropRatePercent] ?? 0, EXPOwner?.Stats[Stat.GoldDropRatePercent] ?? 0);

                            if (reward != null)
                            {
                                foreach (var dropitems in reward.Items)
                                {
                                    dropItem = Envir.CreateDropItem(drop.Item);
                                    break;
                                }
                            }
                        }

                        if (dropItem == null)
                        {
                            ReceiveChat("Your fish got away!", ChatType.System);
                        }
                        else if (FreeSpace(Info.Inventory) < 1)
                        {
                            ReceiveChat(GameLanguage.NoBagSpace, ChatType.System);
                        }
                        else
                        {
                            GainItem(dropItem);
                            Report.ItemChanged(dropItem, dropItem.Count, 2);
                        }

                        if (Envir.Random.Next(100 - Settings.FishingMobSpawnChance) == 0)
                        {
                            MonsterObject mob = MonsterObject.GetMonster(Envir.GetMonsterInfo(Settings.FishingMonster));

                            if (mob == null) return;

                            mob.Spawn(CurrentMap, Back);
                        }

                        DamagedFishingItem(FishingSlot.Reel, 1);

                        cancel = true;
                    }
                    else
                    {
                        ReceiveChat("Your fish got away!", ChatType.System);
                    }
                }

                FishFound = false;
                FishFirstFound = false;
            }

            Enqueue(GetFishInfo());
            Broadcast(GetFishInfo());

            if (FishingAutocast && !cast && !cancel)
            {
                FishingTime = Envir.Time + (FishingCastDelay * 2);
                FishingFoundTime = Envir.Time;
                FishingAutoReelChance = 0;
                FishingNibbleChance = 0;
                FishFirstFound = false;

                FishingCast(true);
            }
        }
        public void FishingChangeAutocast(bool autoCast)
        {
            UserItem rod = Info.Equipment[(int)EquipmentSlot.Weapon];

            if (rod == null || !rod.Info.IsFishingRod) return;

            UserItem reel = rod.Slots[(int)FishingSlot.Reel];

            if (reel == null)
            {
                FishingAutocast = false;
                return;
            }

            FishingAutocast = autoCast;
        }
        public void UpdateFish()
        {
            if (FishFound != true && FishFirstFound != true)
            {
                FishFound = Envir.Random.Next(0, 100) <= FishingNibbleChance;
                FishingFoundTime = FishFound ? Envir.Time + 3000 : Envir.Time;

                if (FishFound)
                {
                    FishFirstFound = true;
                    DamagedFishingItem(FishingSlot.Float, 1);
                }
            }
            else
            {
                if (FishingAutoReelChance != 0 && Envir.Random.Next(0, 100) <= FishingAutoReelChance)
                {
                    FishingCast(false);
                }
            }

            if (FishingFoundTime < Envir.Time)
                FishFound = false;

            FishingTime = Envir.Time + FishingDelay;

            Enqueue(GetFishInfo());

            if (FishingProgress > 100)
            {
                FishingCast(false);
            }
        }
        Packet GetFishInfo()
        {
            FishingProgress = _fishCounter > 0 ? (int)(((decimal)_fishCounter / FishingProgressMax) * 100) : 0;

            return new S.FishingUpdate
            {
                ObjectID = ObjectID,
                Fishing = Fishing,
                ProgressPercent = FishingProgress,
                FishingPoint = Functions.PointMove(CurrentLocation, Direction, 3),
                ChancePercent = FishingChance,
                FoundFish = FishFound
            };
        }

        #endregion

        #region Quests

        public void AcceptQuest(int index)
        {
            bool canAccept = true;

            if (CurrentQuests.Exists(e => e.Index == index)) return; //e.Info.NpcIndex == npcIndex && 

            QuestInfo info = Envir.QuestInfoList.FirstOrDefault(d => d.Index == index);

            NPCObject npc = null;

            for (int i = CurrentMap.NPCs.Count - 1; i >= 0; i--)
            {
                if (CurrentMap.NPCs[i].ObjectID != info.NpcIndex) continue;

                if (!Functions.InRange(CurrentMap.NPCs[i].CurrentLocation, CurrentLocation, Globals.DataRange)) break;
                npc = CurrentMap.NPCs[i];
                break;
            }
            if (npc == null || !npc.VisibleLog[Info.Index] || !npc.Visible) return;

            if (!info.CanAccept(this))
            {
                canAccept = false;
            }

            if (CurrentQuests.Count >= Globals.MaxConcurrentQuests)
            {
                ReceiveChat("Maximum amount of quests already taken.", ChatType.System);
                return;
            }

            if (CompletedQuests.Contains(index))
            {
                ReceiveChat("Quest has already been completed.", ChatType.System);
                return;
            }

            //check previous chained quests have been completed
            QuestInfo tempInfo = info;
            while (tempInfo != null && tempInfo.RequiredQuest != 0)
            {
                if (!CompletedQuests.Contains(tempInfo.RequiredQuest))
                {
                    canAccept = false;
                    break;
                }

                tempInfo = Envir.QuestInfoList.FirstOrDefault(d => d.Index == tempInfo.RequiredQuest);
            }

            if (!canAccept)
            {
                ReceiveChat("Could not accept quest.", ChatType.System);
                return;
            }

            if (info.CarryItems.Count > 0)
            {
                foreach (QuestItemTask carryItem in info.CarryItems)
                {
                    ushort count = carryItem.Count;

                    while (count > 0)
                    {
                        UserItem item = Envir.CreateFreshItem(carryItem.Item);

                        if (item.Info.StackSize > count)
                        {
                            item.Count = count;
                            count = 0;
                        }
                        else
                        {
                            count -= item.Info.StackSize;
                            item.Count = item.Info.StackSize;
                        }

                        if (!CanGainQuestItem(item))
                        {
                            RecalculateQuestBag();
                            return;
                        }

                        GainQuestItem(item);

                        Report.ItemChanged(item, item.Count, 2);
                    }
                }
            }

            QuestProgressInfo quest = new QuestProgressInfo(index);

            quest.Init(this);
            SendUpdateQuest(quest, QuestState.Add, true);

            CallDefaultNPC(DefaultNPCType.OnAcceptQuest, index);
        }

        public void FinishQuest(int questIndex, int selectedItemIndex = -1, bool autoComplete = false)
        {
            QuestProgressInfo quest = CurrentQuests.FirstOrDefault(e => e.Info.Index == questIndex);

            if (quest == null || !quest.Completed) return;

            if (!autoComplete)
            {
                NPCObject npc = null;

                for (int i = CurrentMap.NPCs.Count - 1; i >= 0; i--)
                {
                    if (CurrentMap.NPCs[i].ObjectID != quest.Info.FinishNpcIndex) continue;

                    if (!Functions.InRange(CurrentMap.NPCs[i].CurrentLocation, CurrentLocation, Globals.DataRange)) break;
                    npc = CurrentMap.NPCs[i];
                    break;
                }
                if (npc == null || !npc.VisibleLog[Info.Index] || !npc.Visible) return;
            }
            List<UserItem> rewardItems = new List<UserItem>();

            foreach (var reward in quest.Info.FixedRewards)
            {
                ushort count = reward.Count;

                UserItem rewardItem;

                while (count > 0)
                {
                    rewardItem = Envir.CreateFreshItem(reward.Item);
                    if (reward.Item.StackSize >= count)
                    {
                        rewardItem.Count = count;
                        count = 0;
                    }
                    else
                    {
                        rewardItem.Count = reward.Item.StackSize;
                        count -= reward.Item.StackSize;
                    }

                    rewardItems.Add(rewardItem);
                }
            }

            if (!autoComplete && selectedItemIndex >= 0)
            {
                for (int i = 0; i < quest.Info.SelectRewards.Count; i++)
                {
                    if (selectedItemIndex != i) continue;

                    ushort count = quest.Info.SelectRewards[i].Count;
                    UserItem rewardItem;

                    while (count > 0)
                    {
                        rewardItem = Envir.CreateFreshItem(quest.Info.SelectRewards[i].Item);
                        if (quest.Info.SelectRewards[i].Item.StackSize >= count)
                        {
                            rewardItem.Count = count;
                            count = 0;
                        }
                        else
                        {
                            rewardItem.Count = quest.Info.SelectRewards[i].Item.StackSize;
                            count -= quest.Info.SelectRewards[i].Item.StackSize;
                        }

                        rewardItems.Add(rewardItem);
                    }
                }
            }

            if (!autoComplete && !CanGainItems(rewardItems.ToArray()))
            {
                ReceiveChat("Cannot hand in quest whilst bag is full.", ChatType.System);
                return;
            }

            if (autoComplete)
            {
                ReceiveChat(string.Format("{0} has been completed.", quest.Info.Name), ChatType.Announcement);
            }

            if (quest.Info.Type != QuestType.Repeatable)
            {
                Info.CompletedQuests.Add(quest.Index);
                GetCompletedQuests();
            }

            CurrentQuests.Remove(quest);
            SendUpdateQuest(quest, QuestState.Remove);

            if (quest.Info.CarryItems.Count > 0)
            {
                foreach (QuestItemTask carryItem in quest.Info.CarryItems)
                {
                    TakeQuestItem(carryItem.Item, carryItem.Count);
                }
            }

            foreach (QuestItemTask iTask in quest.Info.ItemTasks)
            {
                TakeQuestItem(iTask.Item, iTask.Count);
            }

            foreach (UserItem item in rewardItems)
            {
                GainItem(item);
            }

            RecalculateQuestBag();

            if (quest.Info.percentageExp)
                GainExp(((uint)((MaxExperience * quest.Info.ExpReward) / 100)));
            else
                GainExp((uint)(quest.Info.ExpReward * Settings.QuestExpRate));

            GainGold(quest.Info.GoldReward);
            GainCredit(quest.Info.CreditReward);
            GainHuntPoints(quest.Info.HuntPointsReward);

            CallDefaultNPC(DefaultNPCType.OnFinishQuest, questIndex);
        }
        public void AbandonQuest(int questIndex)
        {
            QuestProgressInfo quest = CurrentQuests.FirstOrDefault(e => e.Info.Index == questIndex);

            if (quest == null) return;

            SendUpdateQuest(quest, QuestState.Remove);

            RecalculateQuestBag();
        }
        public void ShareQuest(int questIndex)
        {
            bool shared = false;

            if (GroupMembers != null)
            {
                foreach (PlayerObject player in GroupMembers.
                    Where(player => player.CurrentMap == CurrentMap &&
                        Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) &&
                        !player.Dead && player != this))
                {
                    player.Enqueue(new S.ShareQuest { QuestIndex = questIndex, SharerName = Name });
                    shared = true;
                }
            }

            if (!shared)
            {
                ReceiveChat("Quest could not be shared with anyone.", ChatType.System);
            }
        }

        public void CheckGroupQuestKill(MonsterInfo mInfo)
        {
            if (GroupMembers != null)
            {
                foreach (PlayerObject player in GroupMembers.
                    Where(player => player.CurrentMap == CurrentMap &&
                        Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) &&
                        !player.Dead))
                {
                    player.CheckNeedQuestKill(mInfo);
                }
            }
            else
                CheckNeedQuestKill(mInfo);
        }
        public bool CheckGroupQuestItem(UserItem item, bool gainItem = true)
        {
            bool itemCollected = false;

            if (GroupMembers != null)
            {
                foreach (PlayerObject player in GroupMembers.
                    Where(player => player.CurrentMap == CurrentMap &&
                        Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) &&
                        !player.Dead))
                {
                    if (player.CheckNeedQuestItem(item, gainItem))
                    {
                        itemCollected = true;
                        player.Report.ItemChanged(item, item.Count, 2, "CheckGroupQuestItem (WinQuestItem)");
                    }
                }
            }
            else
            {
                if (CheckNeedQuestItem(item, gainItem))
                {
                    itemCollected = true;
                    Report.ItemChanged(item, item.Count, 2, "CheckGroupQuestItem (WinQuestItem)");
                }
            }

            return itemCollected;
        }

        public bool CheckNeedQuestItem(UserItem item, bool gainItem = true)
        {
            foreach (QuestProgressInfo quest in CurrentQuests.
                Where(e => e.ItemTaskCount.Count > 0).
                Where(e => e.NeedItem(item.Info)).
                Where(e => CanGainQuestItem(item)))
            {
                if (gainItem)
                {
                    GainQuestItem(item);
                    quest.ProcessItem(Info.QuestInventory);

                    Enqueue(new S.SendOutputMessage { Message = string.Format("You found {0}.", item.FriendlyName), Type = OutputMessageType.Quest });

                    SendUpdateQuest(quest, QuestState.Update);

                    Report.ItemChanged(item, item.Count, 2, "CheckNeedQuestItem (WinQuestItem)");
                }
                return true;
            }

            return false;
        }
        public bool CheckNeedQuestFlag(int flagNumber)
        {
            foreach (QuestProgressInfo quest in CurrentQuests.
                Where(e => e.FlagTaskSet.Count > 0).
                Where(e => e.NeedFlag(flagNumber)))
            {
                quest.ProcessFlag(Info.Flags);

                //Enqueue(new S.SendOutputMessage { Message = string.Format("Location visited."), Type = OutputMessageType.Quest });

                SendUpdateQuest(quest, QuestState.Update);
                return true;
            }

            return false;
        }
        public void CheckNeedQuestKill(MonsterInfo mInfo)
        {
            foreach (QuestProgressInfo quest in CurrentQuests.
                    Where(e => e.KillTaskCount.Count > 0).
                    Where(quest => quest.NeedKill(mInfo)))
            {
                quest.ProcessKill(mInfo);

                Enqueue(new S.SendOutputMessage { Message = string.Format("You killed {0}.", mInfo.GameName), Type = OutputMessageType.Quest });

                SendUpdateQuest(quest, QuestState.Update);
            }
        }

        public void RecalculateQuestBag()
        {
            for (int i = Info.QuestInventory.Length - 1; i >= 0; i--)
            {
                UserItem itm = Info.QuestInventory[i];

                if (itm == null) continue;

                bool itemRequired = false;
                bool isCarryItem = false;

                foreach (QuestProgressInfo quest in CurrentQuests)
                {
                    foreach (QuestItemTask carryItem in quest.Info.CarryItems)
                    {
                        if (carryItem.Item == itm.Info)
                        {
                            isCarryItem = true;
                            break;
                        }
                    }

                    foreach (QuestItemTask task in quest.Info.ItemTasks)
                    {
                        if (task.Item == itm.Info)
                        {
                            itemRequired = true;
                            break;
                        }
                    }
                }

                if (!itemRequired && !isCarryItem)
                {
                    Info.QuestInventory[i] = null;
                    Enqueue(new S.DeleteQuestItem { UniqueID = itm.UniqueID, Count = itm.Count });
                }
            }
        }

        public void SendUpdateQuest(QuestProgressInfo quest, QuestState state, bool trackQuest = false)
        {
            quest.CheckCompleted();

            switch (state)
            {
                case QuestState.Add:
                    if (!CurrentQuests.Contains(quest))
                    {
                        CurrentQuests.Add(quest);
                    }
                    quest.SetTimer2();
                    break;
                case QuestState.Remove:
                    if (CurrentQuests.Contains(quest))
                    {
                        CurrentQuests.Remove(quest);
                    }
                    quest.RemoveTimer();
                    break;
            }

            Enqueue(new S.ChangeQuest
            {
                Quest = quest.CreateClientQuestProgress(),
                QuestState = state,
                TrackQuest = trackQuest
            });
        }

        public void GetCompletedQuests()
        {
            Enqueue(new S.CompleteQuest
            {
                CompletedQuests = CompletedQuests
            });
        }

        #endregion

        #region Mail

        public void SendMail(string name, string message)
        {
            CharacterInfo player = Envir.GetCharacterInfo(name);

            if (player == null)
            {
                ReceiveChat(string.Format(GameLanguage.CouldNotFindPlayer, name), ChatType.System);
                return;
            }

            if (player.Friends.Any(e => e.Info == Info && e.Blocked))
            {
                ReceiveChat("Player is not accepting your mail.", ChatType.System);
                return;
            }

            if (Info.Friends.Any(e => e.Info == player && e.Blocked))
            {
                ReceiveChat("Cannot mail player whilst they are on your blacklist.", ChatType.System);
                return;
            }

            //sent from player
            MailInfo mail = new MailInfo(player.Index, true)
            {
                Sender = Info.Name,
                Message = message,
                Gold = 0
            };

            mail.Send();
        }

        public void SendMail(string name, string message, uint gold, ulong[] items, bool stamped)
        {
            CharacterInfo player = Envir.GetCharacterInfo(name);

            if (player == null)
            {
                ReceiveChat(string.Format(GameLanguage.CouldNotFindPlayer, name), ChatType.System);
                return;
            }

            bool hasStamp = false;
            uint totalGold = 0;
            uint parcelCost = GetMailCost(items, gold, stamped);

            totalGold = gold + parcelCost;

            if (Account.Gold < totalGold || Account.Gold < gold || gold > totalGold)
            {
                Enqueue(new S.MailSent { Result = -1 });
                return;
            }

            //Validate user has stamp
            if (stamped)
            {
                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    UserItem item = Info.Inventory[i];

                    if (item == null || item.Info.Type != ItemType.Nothing || item.Info.Shape != 1 || item.Count < 1) continue;

                    hasStamp = true;

                    if (item.Count > 1) item.Count--;
                    else Info.Inventory[i] = null;

                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = 1 });
                    break;
                }
            }

            List<UserItem> giftItems = new List<UserItem>();

            for (int j = 0; j < (hasStamp ? 5 : 1); j++)
            {
                if (items[j] < 1) continue;

                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    UserItem item = Info.Inventory[i];

                    if (item == null || items[j] != item.UniqueID) continue;

                    if(item.Info.Bind.HasFlag(BindMode.DontTrade))
                    {
                        ReceiveChat(string.Format("{0} cannot be mailed", item.FriendlyName), ChatType.System);
                        return;
                    }

                    if (item.Info.Bind.HasFlag(BindMode.NoMail))
                    {
                        ReceiveChat(string.Format("{0} cannot be mailed", item.FriendlyName), ChatType.System);
                        Enqueue(new S.MailSent { Result = -1 });
                        return;
                    }

                    if (item.RentalInformation != null && item.RentalInformation.BindingFlags.HasFlag(BindMode.DontTrade))
                    {
                        ReceiveChat(string.Format("{0} cannot be mailed", item.FriendlyName), ChatType.System);
                        return;
                    }

                    giftItems.Add(item);

                    Info.Inventory[i] = null;
                    Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                }
            }

            if (totalGold > 0)
            {
                Account.Gold -= totalGold;
                Enqueue(new S.LoseGold { Gold = totalGold });
            }

            //Create parcel
            MailInfo mail = new MailInfo(player.Index, true)
            {
                MailID = ++Envir.NextMailID,
                Sender = Info.Name,
                Message = message,
                Gold = gold,
                Items = giftItems
            };

            mail.Send();

            Enqueue(new S.MailSent { Result = 1 });
        }

        public void ReadMail(ulong mailID)
        {
            MailInfo mail = Info.Mail.SingleOrDefault(e => e.MailID == mailID);

            if (mail == null) return;

            mail.DateOpened = DateTime.Now;

            GetMail();
        }

        public void CollectMail(ulong mailID)
        {
            MailInfo mail = Info.Mail.SingleOrDefault(e => e.MailID == mailID);

            if (mail == null) return;

            if (!mail.Collected)
            {
                ReceiveChat("Mail must be collected from the post office.", ChatType.System);
                return;
            }

            if (mail.Items.Count > 0)
            {
                if (!CanGainItems(mail.Items.ToArray()))
                {
                    ReceiveChat("Cannot collect items when bag is full.", ChatType.System);
                    return;
                }

                for (int i = 0; i < mail.Items.Count; i++)
                {
                    GainItem(mail.Items[i]);
                }
            }

            if (mail.Gold > 0)
            {
                uint gold = mail.Gold;

                if (gold + Account.Gold >= uint.MaxValue)
                    gold = uint.MaxValue - Account.Gold;

                GainGold(gold);
            }

            mail.Items = new List<UserItem>();
            mail.Gold = 0;

            mail.Collected = true;

            Enqueue(new S.ParcelCollected { Result = 1 });

            GetMail();
        }

        public void DeleteMail(ulong mailID)
        {
            MailInfo mail = Info.Mail.SingleOrDefault(e => e.MailID == mailID);

            if (mail == null) return;

            Info.Mail.Remove(mail);

            GetMail();
        }

        public void LockMail(ulong mailID, bool lockMail)
        {
            MailInfo mail = Info.Mail.SingleOrDefault(e => e.MailID == mailID);

            if (mail == null) return;

            mail.Locked = lockMail;

            GetMail();
        }

        public uint GetMailCost(ulong[] items, uint gold, bool stamped)
        {
            uint cost = 0;

            if (!Settings.MailFreeWithStamp || !stamped)
            {
                if (gold > 0 && Settings.MailCostPer1KGold > 0)
                {
                    cost += (uint)Math.Floor((decimal)gold / 1000) * Settings.MailCostPer1KGold;
                }

                if (items != null && items.Length > 0 && Settings.MailItemInsurancePercentage > 0)
                {
                    for (int j = 0; j < (stamped ? 5 : 1); j++)
                    {
                        if (items[j] < 1) continue;

                        for (int i = 0; i < Info.Inventory.Length; i++)
                        {
                            UserItem item = Info.Inventory[i];

                            if (item == null || items[j] != item.UniqueID) continue;

                            cost += (uint)Math.Floor((double)item.Price() / 100 * Settings.MailItemInsurancePercentage);
                        }
                    }
                }
            }


            return cost;
        }

        public void GetMail()
        {
            List<ClientMail> mail = new List<ClientMail>();

            int start = (Info.Mail.Count - Settings.MailCapacity) > 0 ? (Info.Mail.Count - (int)Settings.MailCapacity) : 0;

            for (int i = start; i < Info.Mail.Count; i++)
            {
                foreach (UserItem itm in Info.Mail[i].Items)
                {
                    CheckItem(itm);
                }

                mail.Add(Info.Mail[i].CreateClientMail());
            }

            //foreach (MailInfo m in Info.Mail)
            //{
            //    foreach (UserItem itm in m.Items)
            //    {
            //        CheckItem(itm);
            //    }

            //    mail.Add(m.CreateClientMail());
            //}

            NewMail = false;

            Enqueue(new S.ReceiveMail { Mail = mail });
        }

        public int GetMailAwaitingCollectionAmount()
        {
            int count = 0;
            for (int i = 0; i < Info.Mail.Count; i++)
            {
                if (!Info.Mail[i].Collected) count++;
            }

            return count;
        }

        #endregion

        #region IntelligentCreatures

        public void SummonIntelligentCreature(IntelligentCreatureType pType)
        {
            if (pType == IntelligentCreatureType.None) return;

            if (Dead) return;

            if (CreatureSummoned == true || SummonedCreatureType != IntelligentCreatureType.None) return;

            for (int i = 0; i < Info.IntelligentCreatures.Count; i++)
            {
                if (Info.IntelligentCreatures[i].PetType != pType) continue;

                MonsterInfo mInfo = Envir.GetMonsterInfo(64, (byte)pType);
                if (mInfo == null) return;

                MonsterObject monster = MonsterObject.GetMonster(mInfo);

                if (monster == null) return;
                monster.PetLevel = 0;
                monster.Master = this;
                monster.MaxPetLevel = 7;
                monster.Direction = Direction;
                monster.ActionTime = Envir.Time + 1000;

                ((IntelligentCreatureObject)monster).CreatureInfo = Info.IntelligentCreatures[i];
                ((IntelligentCreatureObject)monster).CreatureRules = new IntelligentCreatureRules
                {
                    MinimalFullness = Info.IntelligentCreatures[i].Info.MinimalFullness,
                    MousePickupEnabled = Info.IntelligentCreatures[i].Info.MousePickupEnabled,
                    MousePickupRange = Info.IntelligentCreatures[i].Info.MousePickupRange,
                    AutoPickupEnabled = Info.IntelligentCreatures[i].Info.AutoPickupEnabled,
                    AutoPickupRange = Info.IntelligentCreatures[i].Info.AutoPickupRange,
                    SemiAutoPickupEnabled = Info.IntelligentCreatures[i].Info.SemiAutoPickupEnabled,
                    SemiAutoPickupRange = Info.IntelligentCreatures[i].Info.SemiAutoPickupRange,
                    CanProduceBlackStone = Info.IntelligentCreatures[i].Info.CanProduceBlackStone
                };

                if (!CurrentMap.ValidPoint(Front)) return;
                monster.Spawn(CurrentMap, Front);
                Pets.Add(monster);

                CreatureSummoned = true;
                SummonedCreatureType = pType;

                ReceiveChat((string.Format("Creature {0} has been summoned.", Info.IntelligentCreatures[i].CustomName)), ChatType.System);
                break;
            }

            //update client
            GetCreaturesInfo();
        }

        public void UnSummonIntelligentCreature(IntelligentCreatureType pType, bool doUpdate = true)
        {
            if (pType == IntelligentCreatureType.None) return;

            for (int i = 0; i < Pets.Count; i++)
            {
                if (Pets[i].Info.AI != 64) continue;
                if (((IntelligentCreatureObject)Pets[i]).PetType != pType) continue;

                if (doUpdate) ReceiveChat((string.Format("Creature {0} has been dismissed.", ((IntelligentCreatureObject)Pets[i]).CustomName)), ChatType.System);

                Pets[i].Die();

                CreatureSummoned = false;
                SummonedCreatureType = IntelligentCreatureType.None;
                break;
            }

            //update client
            if (doUpdate) GetCreaturesInfo();
        }

        public void ReleaseIntelligentCreature(IntelligentCreatureType pType, bool doUpdate = true)
        {
            if (pType == IntelligentCreatureType.None) return;

            //remove creature
            for (int i = 0; i < Info.IntelligentCreatures.Count; i++)
            {
                if (Info.IntelligentCreatures[i].PetType != pType) continue;

                if (doUpdate) ReceiveChat((string.Format("Creature {0} has been released.", Info.IntelligentCreatures[i].CustomName)), ChatType.System);

                Info.IntelligentCreatures.Remove(Info.IntelligentCreatures[i]);
                break;
            }

            //re-arrange slots
            for (int i = 0; i < Info.IntelligentCreatures.Count; i++)
                Info.IntelligentCreatures[i].SlotIndex = i;

            //update client
            if (doUpdate) GetCreaturesInfo();
        }

        public void UpdateSummonedCreature(IntelligentCreatureType pType)
        {
            if (pType == IntelligentCreatureType.None) return;

            UserIntelligentCreature creatureInfo = null;
            for (int i = 0; i < Info.IntelligentCreatures.Count; i++)
            {
                if (Info.IntelligentCreatures[i].PetType != pType) continue;

                creatureInfo = Info.IntelligentCreatures[i];
                break;
            }
            if (creatureInfo == null) return;

            for (int i = 0; i < Pets.Count; i++)
            {
                if (Pets[i].Info.AI != 64) continue;
                if (((IntelligentCreatureObject)Pets[i]).PetType != pType) continue;

                ((IntelligentCreatureObject)Pets[i]).CustomName = creatureInfo.CustomName;
                ((IntelligentCreatureObject)Pets[i]).ItemFilter = creatureInfo.Filter;
                ((IntelligentCreatureObject)Pets[i]).CurrentPickupMode = creatureInfo.petMode;
                break;
            }
        }

        public void RefreshCreaturesTimeLeft()
        {
            if (Info.IntelligentCreatures.Count == 0) return;

            if (Envir.Time > CreatureTimeLeftTicker)
            {
                //ExpireTime
                List<int> releasedPets = new List<int>();
                CreatureTimeLeftTicker = Envir.Time + Settings.Second;

                for (int i = 0; i < Info.IntelligentCreatures.Count; i++)
                {
                    if (Info.IntelligentCreatures[i].Expire == DateTime.MinValue) continue; //permanent
    
                    if (Info.IntelligentCreatures[i].Expire < DateTime.Now)
                    {
                        //Info.IntelligentCreatures[i].ExpireTime = 0;

                        if (CreatureSummoned && SummonedCreatureType == Info.IntelligentCreatures[i].PetType)
                        {
                            UnSummonIntelligentCreature(SummonedCreatureType, false);
                        }

                        releasedPets.Add(i);
                    }
                }

                for (int i = (releasedPets.Count - 1); i >= 0; i--)
                {
                    ReceiveChat(string.Format("Creature {0} has expired.", Info.IntelligentCreatures[releasedPets[i]].CustomName), ChatType.System);
                    ReleaseIntelligentCreature(Info.IntelligentCreatures[releasedPets[i]].PetType, false);
                }

                if (SendIntelligentCreatureUpdates && CreatureSummoned && SummonedCreatureType != IntelligentCreatureType.None)
                {
                    //update client
                    GetCreaturesInfo();
                }
            }
        }

        public void RefreshCreatureSummoned()
        {
            if (SummonedCreatureType == IntelligentCreatureType.None || !CreatureSummoned)
            {
                //make sure both are in the unsummoned state
                CreatureSummoned = false;
                SummonedCreatureType = IntelligentCreatureType.None;
                return;
            }

            bool petFound = false;
            for (int i = 0; i < Pets.Count; i++)
            {
                if (Pets[i].Info.AI != 64) continue;
                if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;
                petFound = true;
                break;
            }

            if (!petFound)
            {
                MessageQueue.EnqueueDebugging(string.Format("{0}: SummonedCreature no longer exists?!?. {1}", Name, SummonedCreatureType.ToString()));
                CreatureSummoned = false;
                SummonedCreatureType = IntelligentCreatureType.None;
            }
        }

        public void IntelligentCreaturePickup(bool mousemode, Point atlocation)
        {
            if (!CreatureSummoned) return;

            for (int i = 0; i < Pets.Count; i++)
            {
                if (Pets[i].Info.AI != 64) continue;
                if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;

                //((IntelligentCreatureObject)Pets[i]).MouseLocation = atlocation;
                ((IntelligentCreatureObject)Pets[i]).ManualPickup(mousemode, atlocation);
                break;
            }
        }

        public void IntelligentCreatureGainPearls(int amount)
        {
            Info.PearlCount += amount;
            if (Info.PearlCount > int.MaxValue) Info.PearlCount = int.MaxValue;
        }

        public void IntelligentCreatureLosePearls(int amount)
        {
            Info.PearlCount -= amount;
            if (Info.PearlCount < 0) Info.PearlCount = 0;
        }

        public void IntelligentCreatureProducePearl()
        {
            Info.PearlCount++;
        }
        public bool IntelligentCreatureProduceBlackStone()
        {
            ItemInfo iInfo = Envir.GetItemInfo(Settings.CreatureBlackStoneName);
            if (iInfo == null) return false;

            UserItem item = Envir.CreateDropItem(iInfo);
            item.Count = 1;

            if (!CanGainItem(item, false))
            {
                MailInfo mail = new MailInfo(Info.Index)
                {
                    MailID = ++Envir.NextMailID,
                    Sender = "BlackStone",
                    Message = "Your pet has produced x1 BlackStone which couldn't be added to your inventory.",
                    Items = new List<UserItem> { item },
                };

                mail.Send();
                return false;
            }

            GainItem(item);
            return true;
        }

        public void IntelligentCreatureSay(IntelligentCreatureType pType, string message)
        {
            if (!CreatureSummoned || message == "") return;
            if (pType != SummonedCreatureType) return;

            for (int i = 0; i < Pets.Count; i++)
            {
                if (Pets[i].Info.AI != 64) continue;
                if (((IntelligentCreatureObject)Pets[i]).PetType != pType) continue;

                Enqueue(new S.ObjectChat { ObjectID = Pets[i].ObjectID, Text = message, Type = ChatType.Normal });
                return;
            }
        }

        public void StrongboxRewardItem(int boxtype)
        {
            int highRate = int.MaxValue;
            UserItem dropItem = null;

            foreach (DropInfo drop in Envir.StrongboxDrops)
            {
                int rate = (int)(Envir.Random.Next(0, drop.Chance) / Settings.DropRate);
                if (rate < 1) rate = 1;

                if (highRate > rate)
                {
                    highRate = rate;
                    dropItem = Envir.CreateFreshItem(drop.Item);
                }
            }

            if (dropItem == null)
            {
                ReceiveChat("Nothing found.", ChatType.System);
                return;
            }

            if (dropItem.Info.Type == ItemType.Pets && dropItem.Info.Shape == 26)
            {
                dropItem = CreateDynamicWonderDrug(boxtype, dropItem);
            }
            else
                dropItem = Envir.CreateDropItem(dropItem.Info);

            if (FreeSpace(Info.Inventory) < 1)
            {
                ReceiveChat("No more space.", ChatType.System);
                return;
            }

            if (dropItem != null) GainItem(dropItem);
        }

        public void BlackstoneRewardItem()
        {
            int highRate = int.MaxValue;
            UserItem dropItem = null;
            foreach (DropInfo drop in Envir.BlackstoneDrops)
            {
                int rate = (int)(Envir.Random.Next(0, drop.Chance) / Settings.DropRate); if (rate < 1) rate = 1;

                if (highRate > rate)
                {
                    highRate = rate;
                    dropItem = Envir.CreateDropItem(drop.Item);
                }
            }
            if (FreeSpace(Info.Inventory) < 1)
            {
                ReceiveChat("No more space.", ChatType.System);
                return;
            }
            if (dropItem != null) GainItem(dropItem);
        }

        private UserItem CreateDynamicWonderDrug(int boxtype, UserItem dropitem)
        {
            dropitem.CurrentDura = (ushort)1;//* 3600
            switch ((int)dropitem.Info.Effect)
            {
                case 0://exp low/med/high
                    dropitem.AddedStats[Stat.ExpRatePercent] = 5;
                    if (boxtype > 0) dropitem.AddedStats[Stat.ExpRatePercent] = 10;
                    if (boxtype > 1) dropitem.AddedStats[Stat.ExpRatePercent] = 20;
                    break;
                case 1://drop low/med/high
                    dropitem.AddedStats[Stat.ItemDropRatePercent] = 10;
                    if (boxtype > 0) dropitem.AddedStats[Stat.ItemDropRatePercent] = 20;
                    if (boxtype > 1) dropitem.AddedStats[Stat.ItemDropRatePercent] = 50;
                    break;
                case 2://hp low/med/high
                    dropitem.AddedStats[Stat.HP] = 50;
                    if (boxtype > 0) dropitem.AddedStats[Stat.HP] = 100;
                    if (boxtype > 1) dropitem.AddedStats[Stat.HP] = 200;
                    break;
                case 3://mp low/med/high
                    dropitem.AddedStats[Stat.MP] = 50;
                    if (boxtype > 0) dropitem.AddedStats[Stat.MP] = 100;
                    if (boxtype > 1) dropitem.AddedStats[Stat.MP] = 200;
                    break;
                case 4://ac low/med/high
                    dropitem.AddedStats[Stat.MaxAC] = 1;
                    if (boxtype > 0) dropitem.AddedStats[Stat.MaxAC] = 3;
                    if (boxtype > 1) dropitem.AddedStats[Stat.MaxAC] = 5;
                    break;
                case 5://amc low/med/high
                    dropitem.AddedStats[Stat.MaxMAC] = 1;
                    if (boxtype > 0) dropitem.AddedStats[Stat.MaxMAC] = 3;
                    if (boxtype > 1) dropitem.AddedStats[Stat.MaxMAC] = 5;
                    break;
                case 6://speed low/med/high
                    dropitem.AddedStats[Stat.AttackSpeed] = 2;
                    if (boxtype > 0) dropitem.AddedStats[Stat.AttackSpeed] = 3;
                    if (boxtype > 1) dropitem.AddedStats[Stat.AttackSpeed] = 4;
                    break;
            }

            return dropitem;
        }

        private IntelligentCreatureObject GetCreatureByName(string creaturename)
        {
            if (!CreatureSummoned || creaturename == "") return null;
            if (SummonedCreatureType == IntelligentCreatureType.None) return null;

            for (int i = 0; i < Pets.Count; i++)
            {
                if (Pets[i].Info.AI != 64) continue;
                if (((IntelligentCreatureObject)Pets[i]).PetType != SummonedCreatureType) continue;

                return ((IntelligentCreatureObject)Pets[i]);
            }
            return null;
        }

        private string CreateTimeString(double secs)
        {
            TimeSpan t = TimeSpan.FromSeconds(secs);
            string answer;
            if (t.TotalMinutes < 1.0)
            {
                answer = string.Format("{0}s", t.Seconds);
            }
            else if (t.TotalHours < 1.0)
            {
                answer = string.Format("{0}m", t.Minutes);
            }
            else if (t.TotalDays < 1.0)
            {
                answer = string.Format("{0}h {1:D2}m", (int)t.TotalHours, t.Minutes);
            }
            else // t.TotalDays >= 1.0
            {
                answer = string.Format("{0}d {1}h {2:D2}m", (int)t.TotalDays, (int)t.Hours, t.Minutes);
            }
            return answer;
        }

        private void GetCreaturesInfo()
        {
            S.UpdateIntelligentCreatureList packet = new S.UpdateIntelligentCreatureList
            {
                CreatureSummoned = CreatureSummoned,
                SummonedCreatureType = SummonedCreatureType,
                PearlCount = Info.PearlCount,
            };

            for (int i = 0; i < Info.IntelligentCreatures.Count; i++)
                packet.CreatureList.Add(Info.IntelligentCreatures[i].CreateClientIntelligentCreature());

            Enqueue(packet);
        }


        #endregion

        #region Friends

        public void AddFriend(string name, bool blocked = false)
        {
            CharacterInfo info = Envir.GetCharacterInfo(name);

            if (info == null)
            {
                ReceiveChat("Player doesn't exist", ChatType.System);
                return;
            }

            if (Name == name)
            {
                ReceiveChat("Cannot add yourself", ChatType.System);
                return;
            }

            if (Info.Friends.Any(e => e.Index == info.Index))
            {
                ReceiveChat("Player already added", ChatType.System);
                return;
            }

            FriendInfo friend = new FriendInfo(info, blocked);

            Info.Friends.Add(friend);

            GetFriends();
        }

        public void RemoveFriend(int index)
        {
            FriendInfo friend = Info.Friends.FirstOrDefault(e => e.Index == index);

            if (friend == null)
            {
                return;
            }

            Info.Friends.Remove(friend);

            GetFriends();
        }

        public void AddMemo(int index, string memo)
        {
            if (memo.Length > 200) return;

            FriendInfo friend = Info.Friends.FirstOrDefault(e => e.Index == index);

            if (friend == null)
            {
                return;
            }

            friend.Memo = memo;

            GetFriends();
        }

        public void GetFriends()
        {
            List<ClientFriend> friends = new List<ClientFriend>();

            foreach (FriendInfo friend in Info.Friends)
            {
                if (friend.Info != null)
                {
                    friends.Add(friend.CreateClientFriend());
                }
            }

            Enqueue(new S.FriendUpdate { Friends = friends });
        }

        #endregion

        #region Refining

        public void DepositRefineItem(int from, int to)
        {

            S.DepositRefineItem p = new S.DepositRefineItem { From = from, To = to, Success = false };

            if (NPCPage == null || !String.Equals(NPCPage.Key, NPCScript.RefineKey, StringComparison.CurrentCultureIgnoreCase))
            {
                Enqueue(p);
                return;
            }
            NPCObject ob = null;
            for (int i = 0; i < CurrentMap.NPCs.Count; i++)
            {
                if (CurrentMap.NPCs[i].ObjectID != NPCObjectID) continue;
                ob = CurrentMap.NPCs[i];
                break;
            }

            if (ob == null || !Functions.InRange(ob.CurrentLocation, CurrentLocation, Globals.DataRange))
            {
                Enqueue(p);
                return;
            }


            if (from < 0 || from >= Info.Inventory.Length)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Info.Refine.Length)
            {
                Enqueue(p);
                return;
            }

            UserItem temp = Info.Inventory[from];

            if (temp == null)
            {
                Enqueue(p);
                return;
            }

            if (Info.Refine[to] == null)
            {
                Info.Refine[to] = temp;
                Info.Inventory[from] = null;
                RefreshBagWeight();

                Report.ItemMoved(temp, MirGridType.Inventory, MirGridType.Refine, from, to);

                p.Success = true;
                Enqueue(p);
                return;
            }
            Enqueue(p);

        }
        public void RetrieveRefineItem(int from, int to)
        {
            S.RetrieveRefineItem p = new S.RetrieveRefineItem { From = from, To = to, Success = false };

            if (from < 0 || from >= Info.Refine.Length)
            {
                Enqueue(p);
                return;
            }

            if (to < 0 || to >= Info.Inventory.Length)
            {
                Enqueue(p);
                return;
            }

            UserItem temp = Info.Refine[from];

            if (temp == null)
            {
                Enqueue(p);
                return;
            }

            if (temp.Weight + CurrentBagWeight > Stats[Stat.BagWeight])
            {
                ReceiveChat("Too heavy to get back.", ChatType.System);
                Enqueue(p);
                return;
            }

            if (Info.Inventory[to] == null)
            {
                Info.Inventory[to] = temp;
                Info.Refine[from] = null;

                Report.ItemMoved(temp, MirGridType.Refine, MirGridType.Inventory, from, to);

                p.Success = true;
                RefreshBagWeight();
                Enqueue(p);

                return;
            }
            Enqueue(p);
        }
        public void RefineCancel()
        {
            for (int t = 0; t < Info.Refine.Length; t++)
            {
                UserItem temp = Info.Refine[t];

                if (temp == null) continue;

                for (int i = 0; i < Info.Inventory.Length; i++)
                {
                    if (Info.Inventory[i] != null) continue;

                    //Put item back in inventory
                    if (CanGainItem(temp))
                    {
                        RetrieveRefineItem(t, i);
                    }
                    else //Drop item on floor if it can no longer be stored
                    {
                        if (DropItem(temp, Settings.DropRange))
                        {
                            Enqueue(new S.DeleteItem { UniqueID = temp.UniqueID, Count = temp.Count });
                        }
                    }

                    Info.Refine[t] = null;

                    break;
                }
            }
        }
        public void RefineItem(ulong uniqueID)
        {
            Enqueue(new S.RepairItem { UniqueID = uniqueID }); //CHECK THIS.

            if (Dead) return;

            if (NPCPage == null || (!String.Equals(NPCPage.Key, NPCScript.RefineKey, StringComparison.CurrentCultureIgnoreCase))) return;

            int index = -1;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                if (Info.Inventory[i] == null || Info.Inventory[i].UniqueID != uniqueID) continue;
                index = i;
                break;
            }

            if (index == -1) return;

            if (Info.Inventory[index].RefineAdded != 0)
            {
                ReceiveChat(String.Format("Your {0} needs to be checked before you can attempt to refine it again.", Info.Inventory[index].FriendlyName), ChatType.System);
                return;
            }

            if ((Info.Inventory[index].Info.Type != ItemType.Weapon) && (Settings.OnlyRefineWeapon))
            {
                ReceiveChat(String.Format("Your {0} can't be refined.", Info.Inventory[index].FriendlyName), ChatType.System);
                return;
            }

            if (Info.Inventory[index].Info.Bind.HasFlag(BindMode.DontUpgrade))
            {
                ReceiveChat(String.Format("Your {0} can't be refined.", Info.Inventory[index].FriendlyName), ChatType.System);
                return;
            }

            if (Info.Inventory[index].RentalInformation != null && Info.Inventory[index].RentalInformation.BindingFlags.HasFlag(BindMode.DontUpgrade))
            {
                ReceiveChat(String.Format("Your {0} can't be refined.", Info.Inventory[index].FriendlyName), ChatType.System);
                return;
            }


            if (index == -1) return;




            //CHECK GOLD HERE
            uint cost = (uint)((Info.Inventory[index].Info.RequiredAmount * 10) * Settings.RefineCost);

            if (cost > Account.Gold)
            {
                ReceiveChat(String.Format("You don't have enough gold to refine your {0}.", Info.Inventory[index].FriendlyName), ChatType.System);
                return;
            }

            Account.Gold -= cost;
            Enqueue(new S.LoseGold { Gold = cost });

            //START OF FORMULA

            Info.CurrentRefine = Info.Inventory[index];
            Info.Inventory[index] = null;
            Info.CollectTime = (Envir.Time + (Settings.RefineTime * Settings.Minute));
            Enqueue(new S.RefineItem { UniqueID = uniqueID });


            short orePurity = 0;
            byte oreAmount = 0;
            byte itemAmount = 0;
            short totalDC = 0;
            short totalMC = 0;
            short totalSC = 0;
            ushort requiredLevel = 0;
            short durability = 0;
            short currentDura = 0;
            short addedStats = 0;
            UserItem ingredient;

            for (int i = 0; i < Info.Refine.Length; i++)
            {
                ingredient = Info.Refine[i];

                if (ingredient == null) continue;
                if (ingredient.Info.Type == ItemType.Weapon)
                {
                    Info.Refine[i] = null;
                    continue;
                }

                if ((ingredient.Info.Stats[Stat.MaxDC] > 0) || (ingredient.Info.Stats[Stat.MaxMC] > 0) || (ingredient.Info.Stats[Stat.MaxSC] > 0))
                {
                    totalDC += (short)(ingredient.Info.Stats[Stat.MinDC] + ingredient.Info.Stats[Stat.MaxDC] + ingredient.AddedStats[Stat.MaxDC]);
                    totalMC += (short)(ingredient.Info.Stats[Stat.MinMC] + ingredient.Info.Stats[Stat.MaxMC] + ingredient.AddedStats[Stat.MaxMC]);
                    totalSC += (short)(ingredient.Info.Stats[Stat.MinSC] + ingredient.Info.Stats[Stat.MaxSC] + ingredient.AddedStats[Stat.MaxSC]);
                    requiredLevel += ingredient.Info.RequiredAmount;
                    if (Math.Floor(ingredient.MaxDura / 1000M) == Math.Floor(ingredient.Info.Durability / 1000M)) durability++;
                    if (Math.Floor(ingredient.CurrentDura / 1000M) == Math.Floor(ingredient.MaxDura / 1000M)) currentDura++;
                    itemAmount++;
                }

                if (ingredient.Info.FriendlyName == Settings.RefineOreName)
                {
                    orePurity += (short)Math.Floor(ingredient.CurrentDura / 1000M);
                    oreAmount++;
                }

                Info.Refine[i] = null;
            }

            if ((totalDC == 0) && (totalMC == 0) && (totalSC == 0))
            {
                Info.CurrentRefine.RefineSuccessChance = 0;
                //Info.CurrentRefine.RefinedValue = RefinedValue.None;
                Info.CurrentRefine.RefineAdded = Settings.RefineIncrease;

                if (Settings.RefineTime == 0)
                {
                    CollectRefine();
                }
                else
                {
                    ReceiveChat(String.Format("Your {0} is now being refined, please check back in {1} minute(s).", Info.CurrentRefine.FriendlyName, Settings.RefineTime), ChatType.System);
                }

                return;
            }

            if (oreAmount == 0)
            {
                Info.CurrentRefine.RefineSuccessChance = 0;
                //Info.CurrentRefine.RefinedValue = RefinedValue.None;
                Info.CurrentRefine.RefineAdded = Settings.RefineIncrease;
                if (Settings.RefineTime == 0)
                {
                    CollectRefine();
                }
                else
                {
                    ReceiveChat(String.Format("Your {0} is now being refined, please check back in {1} minute(s).", Info.CurrentRefine.FriendlyName, Settings.RefineTime), ChatType.System);
                }
                return;
            }


            short refineStat = 0;

            if ((totalDC > totalMC) && (totalDC > totalSC))
            {
                Info.CurrentRefine.RefinedValue = RefinedValue.DC;
                refineStat = totalDC;
            }

            if ((totalMC > totalDC) && (totalMC > totalSC))
            {
                Info.CurrentRefine.RefinedValue = RefinedValue.MC;
                refineStat = totalMC;
            }

            if ((totalSC > totalDC) && (totalSC > totalMC))
            {
                Info.CurrentRefine.RefinedValue = RefinedValue.SC;
                refineStat = totalSC;
            }

            Info.CurrentRefine.RefineAdded = Settings.RefineIncrease;


            int itemSuccess = 0; //Chance out of 35%

            itemSuccess += (refineStat * 5) - Info.CurrentRefine.Info.RequiredAmount;
            itemSuccess += 5;
            if (itemSuccess > 10) itemSuccess = 10;
            if (itemSuccess < 0) itemSuccess = 0; //10%


            if ((requiredLevel / itemAmount) > (Info.CurrentRefine.Info.RequiredAmount - 5)) itemSuccess += 10; //20%
            if (durability == itemAmount) itemSuccess += 10; //30%
            if (currentDura == itemAmount) itemSuccess += 5; //35%

            int oreSuccess = 0; //Chance out of 35%

            if (oreAmount >= itemAmount) oreSuccess += 15; //15%
            if ((orePurity / oreAmount) >= (refineStat / itemAmount)) oreSuccess += 15; //30%
            if (orePurity == refineStat) oreSuccess += 5; //35%

            int luckSuccess = (Info.CurrentRefine.AddedStats[Stat.Luck] + 5); //Chance out of 10%
            if (luckSuccess > 10) luckSuccess = 10;
            if (luckSuccess < 0) luckSuccess = 0;


            int baseSuccess = Settings.RefineBaseChance; //20% as standard

            int successChance = (itemSuccess + oreSuccess + luckSuccess + baseSuccess);

            addedStats = (byte)(Info.CurrentRefine.AddedStats[Stat.MaxDC] + Info.CurrentRefine.AddedStats[Stat.MaxMC] + Info.CurrentRefine.AddedStats[Stat.MaxSC]);
            if (Info.CurrentRefine.Info.Type == ItemType.Weapon) addedStats = (short)(addedStats * Settings.RefineWepStatReduce);
            else addedStats = (short)(addedStats * Settings.RefineItemStatReduce);
            if (addedStats > 50) addedStats = 50;

            successChance -= addedStats;

            Info.CurrentRefine.RefineSuccessChance = successChance;

            //END OF FORMULA

            if (Settings.RefineTime == 0)
            {
                CollectRefine();
            }
            else
            {
                ReceiveChat(String.Format("Your {0} is now being refined, please check back in {1} minute(s).", Info.CurrentRefine.FriendlyName, Settings.RefineTime), ChatType.System);
            }
        }
        public void CollectRefine()
        {
            S.NPCCollectRefine p = new S.NPCCollectRefine { Success = false };

            if (Info.CurrentRefine == null)
            {
                ReceiveChat("You aren't currently refining any items.", ChatType.System);
                Enqueue(p);
                return;
            }

            if (Info.CollectTime > Envir.Time)
            {
                ReceiveChat(string.Format("Your {0} will be ready to collect in {1} minute(s).", Info.CurrentRefine.FriendlyName, ((Info.CollectTime - Envir.Time) / Settings.Minute)), ChatType.System);
                Enqueue(p);
                return;
            }


            if (Info.CurrentRefine.Info.Weight + CurrentBagWeight > Stats[Stat.BagWeight])
            {
                ReceiveChat(string.Format("Your {0} is too heavy to get back, try again after reducing your bag weight.", Info.CurrentRefine.FriendlyName), ChatType.System);
                Enqueue(p);
                return;
            }

            int index = -1;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                if (Info.Inventory[i] != null) continue;
                index = i;
                break;
            }

            if (index == -1)
            {
                ReceiveChat(String.Format("There isn't room in your bag for your {0}, make some space and try again.", Info.CurrentRefine.FriendlyName), ChatType.System);
                Enqueue(p);
                return;
            }

            ReceiveChat(String.Format("Your item has been returned to you."), ChatType.System);
            p.Success = true;

            GainItem(Info.CurrentRefine);

            Info.CurrentRefine = null;
            Info.CollectTime = 0;
            Enqueue(p);
        }
        public void CheckRefine(ulong uniqueID)
        {
            if (Dead) return;

            if (NPCPage == null || (!String.Equals(NPCPage.Key, NPCScript.RefineCheckKey, StringComparison.CurrentCultureIgnoreCase))) return;

            int index = -1;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                UserItem temp = Info.Inventory[i];
                if (temp == null || temp.UniqueID != uniqueID) continue;
                index = i;
                break;
            }

            if (index == -1) return;

            if (Info.Inventory[index].RefineAdded == 0)
            {
                ReceiveChat(String.Format("{0} doesn't need to be checked as it hasn't been refined yet.", Info.Inventory[index].FriendlyName), ChatType.System);
                return;
            }

            if (Envir.Random.Next(1, 100) > Info.Inventory[index].RefineSuccessChance)
            {
                Info.Inventory[index].RefinedValue = RefinedValue.None;
            }

            if (Envir.Random.Next(1, 100) < Settings.RefineCritChance)
            {
                Info.Inventory[index].RefineAdded = (byte)(Info.Inventory[index].RefineAdded * Settings.RefineCritIncrease);
            }

            if ((Info.Inventory[index].RefinedValue == RefinedValue.DC) && (Info.Inventory[index].RefineAdded > 0))
            {
                ReceiveChat(String.Format("Congratulations, your {0} now has +{1} extra DC.", Info.Inventory[index].FriendlyName, Info.Inventory[index].RefineAdded), ChatType.System);
                Info.Inventory[index].AddedStats[Stat.MaxDC] = (int)Math.Min(int.MaxValue, Info.Inventory[index].AddedStats[Stat.MaxDC] + Info.Inventory[index].RefineAdded);
                Info.Inventory[index].RefineAdded = 0;
                Info.Inventory[index].RefinedValue = RefinedValue.None;
                Info.Inventory[index].RefineSuccessChance = 0;

            }
            else if ((Info.Inventory[index].RefinedValue == RefinedValue.MC) && (Info.Inventory[index].RefineAdded > 0))
            {
                ReceiveChat(String.Format("Congratulations, your {0} now has +{1} extra MC.", Info.Inventory[index].FriendlyName, Info.Inventory[index].RefineAdded), ChatType.System);
                Info.Inventory[index].AddedStats[Stat.MaxMC] = (int)Math.Min(int.MaxValue, Info.Inventory[index].AddedStats[Stat.MaxMC] + Info.Inventory[index].RefineAdded);
                Info.Inventory[index].RefineAdded = 0;
                Info.Inventory[index].RefinedValue = RefinedValue.None;
                Info.Inventory[index].RefineSuccessChance = 0;

            }
            else if ((Info.Inventory[index].RefinedValue == RefinedValue.SC) && (Info.Inventory[index].RefineAdded > 0))
            {
                ReceiveChat(String.Format("Congratulations, your {0} now has +{1} extra SC.", Info.Inventory[index].FriendlyName, Info.Inventory[index].RefineAdded), ChatType.System);
                Info.Inventory[index].AddedStats[Stat.MaxSC] = (int)Math.Min(int.MaxValue, Info.Inventory[index].AddedStats[Stat.MaxSC] + Info.Inventory[index].RefineAdded);
                Info.Inventory[index].RefineAdded = 0;
                Info.Inventory[index].RefinedValue = RefinedValue.None;
                Info.Inventory[index].RefineSuccessChance = 0;
            }
            else if ((Info.Inventory[index].RefinedValue == RefinedValue.None) && (Info.Inventory[index].RefineAdded > 0))
            {
                ReceiveChat(String.Format("Your {0} smashed into a thousand pieces upon testing.", Info.Inventory[index].FriendlyName), ChatType.System);
                Enqueue(new S.RefineItem { UniqueID = Info.Inventory[index].UniqueID });
                Info.Inventory[index].RefineSuccessChance = 0;
                Info.Inventory[index] = null;
                return;
            }

            Enqueue(new S.ItemUpgraded { Item = Info.Inventory[index] });
            return;
        }

        #endregion

        #region Relationship

        public void NPCDivorce()
        {
            if (Info.Married == 0)
            {
                ReceiveChat(string.Format("You're not married."), ChatType.System);
                return;
            }

            CharacterInfo Lover = Envir.GetCharacterInfo(Info.Married);
            PlayerObject Player = Envir.GetPlayer(Lover.Name);

            if (HasBuff(BuffType.RelationshipEXP, out _))
            {
                RemoveBuff(BuffType.RelationshipEXP);
                Player.RemoveBuff(BuffType.RelationshipEXP);
            }

            Info.Married = 0;
            Info.MarriedDate = DateTime.Now;

            if (Info.Equipment[(int)EquipmentSlot.RingL] != null)
            {
                Info.Equipment[(int)EquipmentSlot.RingL].WeddingRing = -1;
                Enqueue(new S.RefreshItem { Item = Info.Equipment[(int)EquipmentSlot.RingL] });
            }


            GetRelationship(false);
            
            Lover.Married = 0;
            Lover.MarriedDate = DateTime.Now;
            if (Lover.Equipment[(int)EquipmentSlot.RingL] != null)
                Lover.Equipment[(int)EquipmentSlot.RingL].WeddingRing = -1;

            if (Player != null)
            {
                Player.GetRelationship(false);
                Player.ReceiveChat(string.Format("You've just been forcefully divorced"), ChatType.System);
                if (Player.Info.Equipment[(int)EquipmentSlot.RingL] != null)
                    Player.Enqueue(new S.RefreshItem { Item = Player.Info.Equipment[(int)EquipmentSlot.RingL] });
            }
        }

        public bool CheckMakeWeddingRing()
        {
            if (Info.Married == 0)
            {
                ReceiveChat(string.Format("You need to be married to make a Wedding Ring."), ChatType.System);
                return false;
            }

            if (Info.Equipment[(int)EquipmentSlot.RingL] == null)
            {
                ReceiveChat(string.Format("You need to wear a ring on your left finger to make a Wedding Ring."), ChatType.System);
                return false;
            }

            if (Info.Equipment[(int)EquipmentSlot.RingL].WeddingRing != -1)
            {
                ReceiveChat(string.Format("You're already wearing a Wedding Ring."), ChatType.System);
                return false;
            }

            if (Info.Equipment[(int)EquipmentSlot.RingL].Info.Bind.HasFlag(BindMode.NoWeddingRing))
            {
                ReceiveChat(string.Format("You cannot use this type of ring."), ChatType.System);
                return false;
            }

            return true;
        }

        public void MakeWeddingRing()
        {
            if (CheckMakeWeddingRing())
            {
                Info.Equipment[(int)EquipmentSlot.RingL].WeddingRing = Info.Married;
                Enqueue(new S.RefreshItem { Item = Info.Equipment[(int)EquipmentSlot.RingL] });
            }
        }

        public void ReplaceWeddingRing(ulong uniqueID)
        {
            if (Dead) return;

            if (NPCPage == null || (!String.Equals(NPCPage.Key, NPCScript.ReplaceWedRingKey, StringComparison.CurrentCultureIgnoreCase))) return;

            UserItem temp = null;
            UserItem CurrentRing = Info.Equipment[(int)EquipmentSlot.RingL];

            if (CurrentRing == null)
            {
                ReceiveChat(string.Format("You arn't wearing a  ring to upgrade."), ChatType.System);
                return;
            }

            if (CurrentRing.WeddingRing == -1)
            {
                ReceiveChat(string.Format("You arn't wearing a Wedding Ring to upgrade."), ChatType.System);
                return;
            }

            int index = -1;

            for (int i = 0; i < Info.Inventory.Length; i++)
            {
                temp = Info.Inventory[i];
                if (temp == null || temp.UniqueID != uniqueID) continue;
                index = i;
                break;
            }

            if (index == -1) return;

            temp = Info.Inventory[index];


            if (temp.Info.Type != ItemType.Ring)
            {
                ReceiveChat(string.Format("You can't replace a Wedding Ring with this item."), ChatType.System);
                return;
            }

            if (!CanEquipItem(temp, (int)EquipmentSlot.RingL))
            {
                ReceiveChat(string.Format("You can't equip the item you're trying to use."), ChatType.System);
                return;
            }

            if (temp.Info.Bind.HasFlag(BindMode.NoWeddingRing))
            {
                ReceiveChat(string.Format("You cannot use this type of ring."), ChatType.System);
                return;
            }

            uint cost = (uint)((Info.Inventory[index].Info.RequiredAmount * 10) * Settings.ReplaceWedRingCost);

            if (cost > Account.Gold)
            {
                ReceiveChat(String.Format("You don't have enough gold to replace your Wedding Ring."), ChatType.System);
                return;
            }

            Account.Gold -= cost;
            Enqueue(new S.LoseGold { Gold = cost });


            temp.WeddingRing = Info.Married;
            CurrentRing.WeddingRing = -1;

            Info.Equipment[(int)EquipmentSlot.RingL] = temp;
            Info.Inventory[index] = CurrentRing;

            Enqueue(new S.EquipItem { Grid = MirGridType.Inventory, UniqueID = temp.UniqueID, To = (int)EquipmentSlot.RingL, Success = true });

            Enqueue(new S.RefreshItem { Item = Info.Inventory[index] });
            Enqueue(new S.RefreshItem { Item = Info.Equipment[(int)EquipmentSlot.RingL] });

        }

        public void MarriageRequest()
        {

            if (Info.Married != 0)
            {
                ReceiveChat(string.Format("You're already married."), ChatType.System);
                return;
            }

            if (Info.MarriedDate.AddDays(Settings.MarriageCooldown) > DateTime.Now)
            {
                ReceiveChat(string.Format("You can't get married again yet, there is a {0} day cooldown after a divorce.", Settings.MarriageCooldown), ChatType.System);
                return;
            }

            if (Info.Level < Settings.MarriageLevelRequired)
            {
                ReceiveChat(string.Format("You need to be at least level {0} to get married.", Settings.MarriageLevelRequired), ChatType.System);
                return;
            }

            Point target = Functions.PointMove(CurrentLocation, Direction, 1);
            Cell cell = CurrentMap.GetCell(target);
            PlayerObject player = null;

            if (cell.Objects == null || cell.Objects.Count < 1) return;

            for (int i = 0; i < cell.Objects.Count; i++)
            {
                MapObject ob = cell.Objects[i];
                if (ob.Race != ObjectType.Player) continue;

                player = Envir.GetPlayer(ob.Name);
            }



            if (player != null)
            {


                if (!Functions.FacingEachOther(Direction, CurrentLocation, player.Direction, player.CurrentLocation))
                {
                    ReceiveChat(string.Format("You need to be facing each other to perform a marriage."), ChatType.System);
                    return;
                }

                if (player.Level < Settings.MarriageLevelRequired)
                {
                    ReceiveChat(string.Format("Your lover needs to be at least level {0} to get married.", Settings.MarriageLevelRequired), ChatType.System);
                    return;
                }

                if (player.Info.MarriedDate.AddDays(Settings.MarriageCooldown) > DateTime.Now)
                {
                    ReceiveChat(string.Format("{0} can't get married again yet, there is a {1} day cooldown after divorce", player.Name, Settings.MarriageCooldown), ChatType.System);
                    return;
                }

                if (!player.AllowMarriage)
                {
                    ReceiveChat("The person you're trying to propose to isn't allowing marriage requests.", ChatType.System);
                    return;
                }

                if (player == this)
                {
                    ReceiveChat("You cant marry yourself.", ChatType.System);
                    return;
                }

                if (player.Dead || Dead)
                {
                    ReceiveChat("You can't perform a marriage with a dead player.", ChatType.System);
                    return;
                }

                if (player.MarriageProposal != null)
                {
                    ReceiveChat(string.Format("{0} already has a marriage invitation.", player.Info.Name), ChatType.System);
                    return;
                }

                if (!Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) || player.CurrentMap != CurrentMap)
                {
                    ReceiveChat(string.Format("{0} is not within marriage range.", player.Info.Name), ChatType.System);
                    return;
                }

                if (player.Info.Married != 0)
                {
                    ReceiveChat(string.Format("{0} is already married.", player.Info.Name), ChatType.System);
                    return;
                }

                player.MarriageProposal = this;
                player.Enqueue(new S.MarriageRequest { Name = Info.Name });
            }
            else
            {
                ReceiveChat(string.Format("You need to be facing a player to request a marriage."), ChatType.System);
                return;
            }
        }

        public void MarriageReply(bool accept)
        {
            if (MarriageProposal == null || MarriageProposal.Info == null)
            {
                MarriageProposal = null;
                return;
            }

            if (!accept)
            {
                MarriageProposal.ReceiveChat(string.Format("{0} has refused to marry you.", Info.Name), ChatType.System);
                MarriageProposal = null;
                return;
            }

            if (Info.Married != 0)
            {
                ReceiveChat("You are already married.", ChatType.System);
                MarriageProposal = null;
                return;
            }

            if (MarriageProposal.Info.Married != 0)
            {
                ReceiveChat(string.Format("{0} is already married.", MarriageProposal.Info.Name), ChatType.System);
                MarriageProposal = null;
                return;
            }


            MarriageProposal.Info.Married = Info.Index;
            MarriageProposal.Info.MarriedDate = DateTime.Now;

            Info.Married = MarriageProposal.Info.Index;
            Info.MarriedDate = DateTime.Now;

            GetRelationship(false);
            MarriageProposal.GetRelationship(false);

            MarriageProposal.ReceiveChat(string.Format("Congratulations, you're now married to {0}.", Info.Name), ChatType.System);
            ReceiveChat(String.Format("Congratulations, you're now married to {0}.", MarriageProposal.Info.Name), ChatType.System);

            MarriageProposal = null;
        }

        public void DivorceRequest()
        {

            if (Info.Married == 0)
            {
                ReceiveChat(string.Format("You're not married."), ChatType.System);
                return;
            }


            Point target = Functions.PointMove(CurrentLocation, Direction, 1);
            Cell cell = CurrentMap.GetCell(target);
            PlayerObject player = null;

            if (cell.Objects == null || cell.Objects.Count < 1) return;

            for (int i = 0; i < cell.Objects.Count; i++)
            {
                MapObject ob = cell.Objects[i];
                if (ob.Race != ObjectType.Player) continue;

                player = Envir.GetPlayer(ob.Name);
            }

            if (player == null)
            {
                ReceiveChat(string.Format("You need to be facing your lover to divorce them."), ChatType.System);
                return;
            }

            if (player != null)
            {
                if (!Functions.FacingEachOther(Direction, CurrentLocation, player.Direction, player.CurrentLocation))
                {
                    ReceiveChat(string.Format("You need to be facing your lover to divorce them."), ChatType.System);
                    return;
                }

                if (player == this)
                {
                    ReceiveChat("You can't divorce yourself.", ChatType.System);
                    return;
                }

                if (player.Dead || Dead)
                {
                    ReceiveChat("You can't divorce a dead player.", ChatType.System); //GOT TO HERE, NEED TO KEEP WORKING ON IT.
                    return;
                }

                if (player.Info.Index != Info.Married)
                {
                    ReceiveChat(string.Format("You aren't married to {0}", player.Info.Name), ChatType.System);
                    return;
                }

                if (!Functions.InRange(player.CurrentLocation, CurrentLocation, Globals.DataRange) || player.CurrentMap != CurrentMap)
                {
                    ReceiveChat(string.Format("{0} is not within divorce range.", player.Info.Name), ChatType.System);
                    return;
                }

                player.DivorceProposal = this;
                player.Enqueue(new S.DivorceRequest { Name = Info.Name });
            }
            else
            {
                ReceiveChat(string.Format("You need to be facing your lover to divorce them."), ChatType.System);
                return;
            }
        }

        public void DivorceReply(bool accept)
        {
            if (DivorceProposal == null || DivorceProposal.Info == null)
            {
                DivorceProposal = null;
                return;
            }

            if (!accept)
            {
                DivorceProposal.ReceiveChat(string.Format("{0} has refused to divorce you.", Info.Name), ChatType.System);
                DivorceProposal = null;
                return;
            }

            if (Info.Married == 0)
            {
                ReceiveChat("You aren't married so you don't require a divorce.", ChatType.System);
                DivorceProposal = null;
                return;
            }

            if (HasBuff(BuffType.RelationshipEXP, out _))
            {
                RemoveBuff(BuffType.RelationshipEXP);
                DivorceProposal.RemoveBuff(BuffType.RelationshipEXP);
            }

            DivorceProposal.Info.Married = 0;
            DivorceProposal.Info.MarriedDate = DateTime.Now;
            if (DivorceProposal.Info.Equipment[(int)EquipmentSlot.RingL] != null)
            {
                DivorceProposal.Info.Equipment[(int)EquipmentSlot.RingL].WeddingRing = -1;
                DivorceProposal.Enqueue(new S.RefreshItem { Item = DivorceProposal.Info.Equipment[(int)EquipmentSlot.RingL] });
            }

            Info.Married = 0;
            Info.MarriedDate = DateTime.Now;
            if (Info.Equipment[(int)EquipmentSlot.RingL] != null)
            {
                Info.Equipment[(int)EquipmentSlot.RingL].WeddingRing = -1;
                Enqueue(new S.RefreshItem { Item = Info.Equipment[(int)EquipmentSlot.RingL] });
            }


            DivorceProposal.ReceiveChat(string.Format("You're now divorced", Info.Name), ChatType.System);
            ReceiveChat("You're now divorced", ChatType.System);

            GetRelationship(false);
            DivorceProposal.GetRelationship(false);
            DivorceProposal = null;
        }

        public void GetRelationship(bool CheckOnline = true)
        {
            if (Info.Married == 0)
            {
                Enqueue(new S.LoverUpdate { Name = "", Date = Info.MarriedDate, MapName = "", MarriedDays = 0 });
            }
            else
            {
                CharacterInfo Lover = Envir.GetCharacterInfo(Info.Married);

                PlayerObject player = Envir.GetPlayer(Lover.Name);

                if (player == null)
                    Enqueue(new S.LoverUpdate { Name = Lover.Name, Date = Info.MarriedDate, MapName = "", MarriedDays = (short)(DateTime.Now - Info.MarriedDate).TotalDays });
                else
                {
                    Enqueue(new S.LoverUpdate { Name = Lover.Name, Date = Info.MarriedDate, MapName = player.CurrentMap.Info.Title, MarriedDays = (short)(DateTime.Now - Info.MarriedDate).TotalDays });
                    if (CheckOnline)
                    {
                        player.GetRelationship(false);
                        player.ReceiveChat(String.Format("{0} has come online.", Info.Name), ChatType.System);
                    }
                }
            }
        }
        public void LogoutRelationship()
        {
            if (Info.Married == 0) return;
            CharacterInfo Lover = Envir.GetCharacterInfo(Info.Married);

            if (Lover == null)
            {
                MessageQueue.EnqueueDebugging(Name + " is married but couldn't find marriage ID " + Info.Married);
                return;
            }

            PlayerObject player = Envir.GetPlayer(Lover.Name);
            if (player != null)
            {
                player.Enqueue(new S.LoverUpdate { Name = Info.Name, Date = player.Info.MarriedDate, MapName = "", MarriedDays = (short)(DateTime.Now - Info.MarriedDate).TotalDays });
                player.ReceiveChat(String.Format("{0} has gone offline.", Info.Name), ChatType.System);
            }
        }

        #endregion

        #region Mentorship

        public void MentorBreak(bool Force = false)
        {
            if (Info.Mentor == 0)
            {
                ReceiveChat(GameLanguage.NoMentorship, ChatType.System);
                return;
            }
            CharacterInfo Mentor = Envir.GetCharacterInfo(Info.Mentor);
            PlayerObject Player = Envir.GetPlayer(Mentor.Name);

            if (Force)
            {
                Info.MentorDate = DateTime.Now.AddDays(Settings.MentorLength);
                ReceiveChat(String.Format("You now have a {0} day cooldown on starting a new Mentorship.", Settings.MentorLength), ChatType.System);
            }
            else
                ReceiveChat("Your Mentorship has now expired.", ChatType.System);

            if (Info.isMentor)
            {
                RemoveBuff(BuffType.Mentor);

                if (Player != null)
                {
                    Info.MentorExp += Player.MenteeEXP;
                    Player.MenteeEXP = 0;
                    Player.RemoveBuff(BuffType.Mentee);
                }
            }
            else
            {
                RemoveBuff(BuffType.Mentee);

                if (Player != null)
                {
                    Mentor.MentorExp += MenteeEXP;
                    MenteeEXP = 0;
                    Player.RemoveBuff(BuffType.Mentor);
                }
            }

            Info.Mentor = 0;
            GetMentor(false);
            

            if (Info.isMentor && Info.MentorExp > 0)
            {
                GainExp((uint)Info.MentorExp);
                Info.MentorExp = 0;
            }
            

            Mentor.Mentor = 0;
            

            if (Player != null)
            {
                Player.ReceiveChat("Your Mentorship has now expired.", ChatType.System);
                Player.GetMentor(false);
                if (Mentor.isMentor && Mentor.MentorExp > 0)
                {
                    Player.GainExp((uint)Mentor.MentorExp);
                    Info.MentorExp = 0;
                }
            }
            else
            {
                if (Mentor.isMentor && Mentor.MentorExp > 0)
                {
                    Mentor.Experience += Mentor.MentorExp;
                    Mentor.MentorExp = 0;
                }
            }

            Info.isMentor = false;
            Mentor.isMentor = false;
            Info.MentorExp = 0;
            Mentor.MentorExp = 0;
        }

        public void AddMentor(string Name)
        {

            if (Info.Mentor != 0)
            {
                ReceiveChat("You already have a Mentor.", ChatType.System);
                return;
            }

            if (Info.Name == Name)
            {
                ReceiveChat("You can't Mentor yourself.", ChatType.System);
                return;
            }

            if (Info.MentorDate > DateTime.Now)
            {
                ReceiveChat("You can't start a new Mentorship yet.", ChatType.System);
                return;
            }

            PlayerObject Mentor = Envir.GetPlayer(Name);

            if (Mentor == null)
            {
                ReceiveChat(String.Format("Can't find anybody by the name {0}.", Name), ChatType.System);
            }
            else
            {
                Mentor.MentorRequest = null;

                if (!Mentor.AllowMentor)
                {
                    ReceiveChat(String.Format("{0} is not allowing Mentor requests.", Mentor.Info.Name), ChatType.System);
                    return;
                }

                if (Mentor.Info.MentorDate > DateTime.Now)
                {
                    ReceiveChat(String.Format("{0} can't start another Mentorship yet.", Mentor.Info.Name), ChatType.System);
                    return;
                }

                if (Mentor.Info.Mentor != 0)
                {
                    ReceiveChat(String.Format("{0} is already a Mentor.", Mentor.Info.Name), ChatType.System);
                    return;
                }

                if (Info.Class != Mentor.Info.Class)
                {
                    ReceiveChat("You can only be mentored by someone of the same Class.", ChatType.System);
                    return;
                }
                if ((Info.Level + Settings.MentorLevelGap) > Mentor.Level)
                {
                    ReceiveChat(String.Format("You can only be mentored by someone who at least {0} level(s) above you.", Settings.MentorLevelGap), ChatType.System);
                    return;
                }

                Mentor.MentorRequest = this;
                Mentor.Enqueue(new S.MentorRequest { Name = Info.Name, Level = Info.Level });
                ReceiveChat(String.Format("Request Sent."), ChatType.System);
            }

        }

        public void MentorReply(bool accept)
        {
            if (MentorRequest == null || MentorRequest.Info == null)
            {
                MentorRequest = null;
                return;
            }

            if (!accept)
            {
                MentorRequest.ReceiveChat(string.Format("{0} has refused to Mentor you.", Info.Name), ChatType.System);
                MentorRequest = null;
                return;
            }

            if (Info.Mentor != 0)
            {
                ReceiveChat("You already have a Student.", ChatType.System);
                return;
            }

            PlayerObject Student = Envir.GetPlayer(MentorRequest.Info.Name);
            MentorRequest = null;

            if (Student == null)
            {
                ReceiveChat(String.Format("{0} is no longer online.", Student.Name), ChatType.System);
                return;
            }
            else
            {
                if (Student.Info.Mentor != 0)
                {
                    ReceiveChat(String.Format("{0} already has a Mentor.", Student.Info.Name), ChatType.System);
                    return;
                }
                if (Info.Class != Student.Info.Class)
                {
                    ReceiveChat("You can only mentor someone of the same Class.", ChatType.System);
                    return;
                }
                if ((Info.Level - Settings.MentorLevelGap) < Student.Level)
                {
                    ReceiveChat(String.Format("You can only mentor someone who at least {0} level(s) below you.", Settings.MentorLevelGap), ChatType.System);
                    return;
                }

                Student.Info.Mentor = Info.Index;
                Student.Info.isMentor = false;
                Info.Mentor = Student.Info.Index;
                Info.isMentor = true;
                Student.Info.MentorDate = DateTime.Now;
                Info.MentorDate = DateTime.Now;

                ReceiveChat(String.Format("You're now the Mentor of {0}.", Student.Info.Name), ChatType.System);
                Student.ReceiveChat(String.Format("You're now being Mentored by {0}.", Info.Name), ChatType.System);
                GetMentor(false);
                Student.GetMentor(false);
            }
        }

        public void GetMentor(bool CheckOnline = true)
        {
            if (Info.Mentor == 0)
            {
                Enqueue(new S.MentorUpdate { Name = "", Level = 0, Online = false, MenteeEXP = 0 });
            }
            else
            {
                CharacterInfo Mentor = Envir.GetCharacterInfo(Info.Mentor);

                PlayerObject player = Envir.GetPlayer(Mentor.Name);

                if (player == null)
                    Enqueue(new S.MentorUpdate { Name = Mentor.Name, Level = Mentor.Level, Online = false, MenteeEXP = Info.MentorExp });
                else
                {
                    Enqueue(new S.MentorUpdate { Name = Mentor.Name, Level = Mentor.Level, Online = true, MenteeEXP = Info.MentorExp });
                    if (CheckOnline)
                    {
                        player.GetMentor(false);
                        player.ReceiveChat(String.Format("{0} has come online.", Info.Name), ChatType.System);
                    }
                }
            }
        }

        public void LogoutMentor()
        {
            if (Info.Mentor == 0) return;

            CharacterInfo Mentor = Envir.GetCharacterInfo(Info.Mentor);

            if (Mentor == null)
            {
                MessageQueue.EnqueueDebugging(Name + " is mentored but couldn't find mentor ID " + Info.Mentor);
                return;
            }

            PlayerObject player = Envir.GetPlayer(Mentor.Name);

            if (!Info.isMentor)
            {
                Mentor.MentorExp += MenteeEXP;
            }

            if (player != null)
            {
                player.Enqueue(new S.MentorUpdate { Name = Info.Name, Level = Info.Level, Online = false, MenteeEXP = Mentor.MentorExp });
                player.ReceiveChat(String.Format("{0} has gone offline.", Info.Name), ChatType.System);
            }
        }

        #endregion

        #region Gameshop

        public void GameShopStock(GameShopItem item)
        {
            int purchased;
            int StockLevel;

            if (item.iStock) //Invididual Stock
            {
                Info.GSpurchases.TryGetValue(item.Info.Index, out purchased);
            }
            else //Server Stock
            {
                Envir.GameshopLog.TryGetValue(item.Info.Index, out purchased);
            }

            if (item.Stock - purchased >= 0)
            {
                StockLevel = item.Stock - purchased;
                Enqueue(new S.GameShopStock { GIndex = item.Info.Index, StockLevel = StockLevel });
            }
              
        }

        public void GameshopBuy(int GIndex, byte Quantity, int PayType)
        {
            if (Quantity < 1 || Quantity > 99) return;

            List<GameShopItem> shopList = Envir.GameShopList;
            GameShopItem Product = null;
            
            int purchased;
            bool stockAvailable = false;
            bool canAfford = false;
            uint CreditCost =0;
            uint GoldCost = 0;
            uint HuntPointsCost = 0;

            List<UserItem> mailItems = new List<UserItem>();

            for (int i = 0; i < shopList.Count; i++)
            {
                if (shopList[i].GIndex == GIndex)
                {
                    Product = shopList[i];
                    break;
                }
            }

            if (Product == null)
            {
                ReceiveChat("You're trying to buy an item that isn't in the shop.", ChatType.System);
                MessageQueue.EnqueueDebugging(Info.Name + " is trying to buy Something that doesn't exist.");
                return;
            }

            if (((decimal)(Quantity * Product.Count) / Product.Info.StackSize) > 5) return;

            if (Product.Stock != 0)
            {

                if (Product.iStock) //Invididual Stock
                {
                    Info.GSpurchases.TryGetValue(Product.Info.Index, out purchased);
                }
                else //Server Stock
                {
                    Envir.GameshopLog.TryGetValue(Product.Info.Index, out purchased);
                }

                if (Product.Stock - purchased - Quantity >= 0)
                {
                    stockAvailable = true;
                }
                else
                {
                    ReceiveChat("You're trying to buy more of this item than is available.", ChatType.System);
                    GameShopStock(Product);
                    MessageQueue.EnqueueDebugging(Info.Name + " is trying to buy " + Product.Info.FriendlyName + " x " + Quantity + " - Stock isn't available.");
                    return;
                }
            }
            else
            {
                stockAvailable = true;
            }
            
            if (stockAvailable)
            {
                switch (PayType)
                {
                    case 0:
                        if (Product.CreditPrice * Quantity <= Account.Credit)
                        {
                            canAfford = true;
                            CreditCost = (Product.CreditPrice * Quantity);
                        }
                        break;
                    case 1:
                        if (Product.GoldPrice * Quantity <= Account.Gold)
                        {
                            canAfford = true;
                            GoldCost = (Product.GoldPrice * Quantity);
                        }
                        break;
                    case 2:
                        if (Product.HuntPointsPrice * Quantity <= Account.HuntPoints)
                        {
                            canAfford = true;
                            HuntPointsCost = (Product.HuntPointsPrice * Quantity);
                        }
                        break;
                    default:
                        return;
                }
            }
            else
            {
                return;
            }

            if (canAfford)
            {
                MessageQueue.EnqueueDebugging(Info.Name + " is trying to buy " + Product.Info.FriendlyName + " x " + Quantity + " - Has enough currency.");
                Account.Gold -= GoldCost;
                Account.Credit -= CreditCost;
                Account.HuntPoints -= HuntPointsCost;

                Report.GoldChanged(GoldCost, true, Product.Info.FriendlyName);
                Report.CreditChanged(CreditCost, true, Product.Info.FriendlyName);
                Report.HuntPointsChanged(HuntPointsCost, true, Product.Info.FriendlyName);

                if (GoldCost != 0) Enqueue(new S.LoseGold { Gold = GoldCost });
                if (CreditCost != 0) Enqueue(new S.LoseCredit { Credit = CreditCost });
                if (HuntPointsCost != 0) Enqueue(new S.LoseHuntPoints { HuntPoints = HuntPointsCost });

                int Purchased;

                if (Product.iStock && Product.Stock != 0)
                {
                    Info.GSpurchases.TryGetValue(Product.Info.Index, out Purchased);
                    if (Purchased == 0)
                    {
                        Info.GSpurchases[Product.GIndex] = Quantity;
                    }
                    else
                    {
                        Info.GSpurchases[Product.GIndex] += Quantity;
                    }
                }

                Purchased = 0;

                Envir.GameshopLog.TryGetValue(Product.Info.Index, out Purchased);
                if (Purchased == 0)
                {
                    Envir.GameshopLog[Product.GIndex] = Quantity;
                }
                else
                {
                    Envir.GameshopLog[Product.GIndex] += Quantity;
                }

                if (Product.Stock != 0) GameShopStock(Product);
            }
            else
            {
                return;
            }

            Report.ItemGSBought(Product, Quantity, CreditCost, GoldCost, HuntPointsCost);

            int quantity = (Quantity * Product.Count);

            if (Product.Info.StackSize <= 1 || quantity == 1)
            {
                for (int i = 0; i < Quantity; i++)
                {
                    UserItem mailItem = Envir.CreateFreshItem(Envir.GetItemInfo(Product.Info.Index));

                    mailItems.Add(mailItem);
                }
            }
            else
            {
                while (quantity > 0)
                {
                    UserItem mailItem = Envir.CreateFreshItem(Envir.GetItemInfo(Product.Info.Index));
                    mailItem.Count = 0;
                    for (int i = 0; i < mailItem.Info.StackSize; i++)
                    {
                        mailItem.Count++;
                        quantity--;
                        if (quantity == 0) break;
                    }
                    if (mailItem.Count == 0) break;

                    mailItems.Add(mailItem);

                }
            }

            MailInfo mail = new MailInfo(Info.Index)
                {
                    MailID = ++Envir.NextMailID,
                    Sender = "Gameshop",
                    Message = "Thank you for your purchase from the Gameshop. Your item(s) are enclosed.",
                    Items = mailItems,
                };
                mail.Send();

            MessageQueue.EnqueueDebugging(Info.Name + " is trying to buy " + Product.Info.FriendlyName + " x " + Quantity + " - Purchases Sent!");
            ReceiveChat("Your purchases have been sent to your Mailbox.", ChatType.Hint);
            ReceiveChat("Click Collect Parcels At Storage Npc After Get The Mail .", ChatType.System2);
        }
            
        public void GetGameShop()
        {
            int purchased;
            GameShopItem item = new GameShopItem();
            int StockLevel;

            for (int i = 0; i < Envir.GameShopList.Count; i++)
            {
                item = Envir.GameShopList[i];

                if (item.Stock != 0)
                {
                    if (item.iStock) //Individual Stock
                    {
                        Info.GSpurchases.TryGetValue(item.Info.Index, out purchased);
                    }
                    else //Server Stock
                    {
                        Envir.GameshopLog.TryGetValue(item.Info.Index, out purchased);
                    }

                    if (item.Stock - purchased >= 0)
                    {
                        StockLevel = item.Stock - purchased;
                        Enqueue(new S.GameShopInfo { Item = item, StockLevel = StockLevel });
                    }
                }
                else
                {
                    Enqueue(new S.GameShopInfo { Item = item, StockLevel = item.Stock });
                }  
            }
        }

        #endregion

        #region ConquestWall
        public void CheckConquest(bool checkPalace = false)
        {
            if (CurrentMap.tempConquest == null && CurrentMap.Conquest != null)
            {
                ConquestObject swi = CurrentMap.GetConquest(CurrentLocation);
                if (swi != null)
                    EnterSabuk();
                else
                    LeaveSabuk();
            }
            else if (CurrentMap.tempConquest != null)
            {
                if (checkPalace && CurrentMap.Info.Index == CurrentMap.tempConquest.PalaceMap.Info.Index && CurrentMap.tempConquest.GameType == ConquestGame.CapturePalace)
                    CurrentMap.tempConquest.TakeConquest(this);

                EnterSabuk();
            }
        }
        public void EnterSabuk()
        {
            if (WarZone) return;
            WarZone = true;
            RefreshNameColour();
        }

        public void LeaveSabuk()
        {
            if (!WarZone) return;
            WarZone = false;
            RefreshNameColour();
        }
        #endregion

        #region Ranking

        private long[] LastRankRequest = new long[6];
        public void GetRanking(byte RankType)
        {
            if (RankType > 6) return;
            if ((LastRankRequest[RankType] != 0) && ((LastRankRequest[RankType] + 300 * 1000) > Envir.Time)) return;
            LastRankRequest[RankType] = Envir.Time;
            if (RankType == 0)
            {
                Enqueue(new S.Rankings { Listings = Envir.RankTop, RankType = RankType, MyRank = Info.Rank[0]});
            }
            else
            {
                Enqueue(new S.Rankings { Listings = Envir.RankClass[RankType - 1], RankType = RankType, MyRank = (byte)Class == (RankType -1)?Info.Rank[1]: 0});
            }
        }

        #endregion

        #region Rental

        public void GetRentedItems()
        {
            Enqueue(new S.GetRentedItems { RentedItems = Info.RentedItems });
        }

        public void ItemRentalRequest()
        {
            if (Dead)
            {
                ReceiveChat("Unable to rent items while dead.", ChatType.System);
                return;
            }

            if (ItemRentalPartner != null)
            {
                ReceiveChat("You are already renting an item to another player.", ChatType.System);
                return;
            }

            var targetPosition = Functions.PointMove(CurrentLocation, Direction, 1);
            var targetCell = CurrentMap.GetCell(targetPosition);
            PlayerObject targetPlayer = null;

            if (targetCell.Objects == null || targetCell.Objects.Count < 1)
                return;

            foreach (var mapObject in targetCell.Objects)
            {
                if (mapObject.Race != ObjectType.Player)
                    continue;

                targetPlayer = Envir.GetPlayer(mapObject.Name);
            }

            if (targetPlayer == null)
            {
                ReceiveChat("Face the player you would like to rent an item too.", ChatType.System);
                return;
            }

            if (Info.RentedItems.Count >= 3)
            {
                ReceiveChat("Unable to rent more than 3 items at a time.", ChatType.System);
                return;
            }

            if (targetPlayer.Info.HasRentedItem)
            {
                ReceiveChat($"{targetPlayer.Name} is unable to rent anymore items at this time.", ChatType.System);
                return;
            }

            if (!Functions.FacingEachOther(Direction, CurrentLocation, targetPlayer.Direction,
                targetPlayer.CurrentLocation))
            {
                ReceiveChat("Face the player you would like to rent an item too.", ChatType.System);
                return;
            }

            if (targetPlayer == this)
            {
                ReceiveChat("You are unable to rent items to yourself.", ChatType.System);
                return;
            }

            if (targetPlayer.Dead)
            {
                ReceiveChat($"Unable to rent items to {targetPlayer.Name} while dead.", ChatType.System);
                return;
            }

            if (!Functions.InRange(targetPlayer.CurrentLocation, CurrentLocation, Globals.DataRange)
                || targetPlayer.CurrentMap != CurrentMap)
            {
                ReceiveChat($"{targetPlayer.Name} is not within range.", ChatType.System);
                return;
            }

            if (targetPlayer.ItemRentalPartner != null)
            {
                ReceiveChat($"{targetPlayer.Name} is currently busy, try again soon.", ChatType.System);
                return;
            }

            ItemRentalPartner = targetPlayer;
            targetPlayer.ItemRentalPartner = this;

            Enqueue(new S.ItemRentalRequest { Name = targetPlayer.Name, Renting = false });
            ItemRentalPartner.Enqueue(new S.ItemRentalRequest { Name = Name, Renting = true });
        }

        public void SetItemRentalFee(uint amount)
        {
            if (ItemRentalFeeLocked)
                return;

            if (Account.Gold < amount)
                return;

            if (ItemRentalPartner == null)
                return;

            ItemRentalFeeAmount += amount;
            Account.Gold -= amount;

            Enqueue(new S.LoseGold { Gold = amount });
            ItemRentalPartner.Enqueue(new S.ItemRentalFee { Amount = amount });
        }

        public void SetItemRentalPeriodLength(uint days)
        {
            if (ItemRentalItemLocked)
                return;

            if (ItemRentalPartner == null)
                return;

            ItemRentalPeriodLength = days;
            ItemRentalPartner.Enqueue(new S.ItemRentalPeriod { Days = days });
        }

        public void DepositRentalItem(int from, int to)
        {
            var packet = new S.DepositRentalItem { From = from, To = to, Success = false };

            if (ItemRentalItemLocked)
            {
                Enqueue(packet);
                return;
            }

            if (from < 0 || from >= Info.Inventory.Length)
            {
                Enqueue(packet);
                return;
            }

            // TODO: Change this check.
            if (to < 0 || to >= 1)
            {
                Enqueue(packet);
                return;
            }

            var item = Info.Inventory[from];

            if (item == null)
            {
                Enqueue(packet);
                return;
            }

            if (item.RentalInformation?.RentalLocked == true)
            {
                ReceiveChat($"Unable to rent {item.FriendlyName} until {item.RentalInformation.ExpiryDate}", ChatType.System);
                Enqueue(packet);
                return;
            }

            if (item.Info.Bind.HasFlag(BindMode.UnableToRent))
            {
                ReceiveChat($"Unable to rent {item.FriendlyName}", ChatType.System);
                Enqueue(packet);
                return;
            }

            if (item.RentalInformation != null && item.RentalInformation.BindingFlags.HasFlag(BindMode.UnableToRent))
            {
                ReceiveChat($"Unable to rent {item.FriendlyName} as it belongs to {item.RentalInformation.OwnerName}", ChatType.System);
                Enqueue(packet);
                return;
            }

            if (ItemRentalDepositedItem == null)
            {
                ItemRentalDepositedItem = item;
                Info.Inventory[from] = null;

                packet.Success = true;
                RefreshBagWeight();
                UpdateRentalItem();
                Report.ItemMoved(item, MirGridType.Inventory, MirGridType.Renting, from, to);
            }

            Enqueue(packet);
        }

        public void RetrieveRentalItem(int from, int to)
        {
            var packet = new S.RetrieveRentalItem { From = from, To = to, Success = false };

            // TODO: Change this check.
            if (from < 0 || from >= 1)
            {
                Enqueue(packet);
                return;
            }

            if (to < 0 || to >= Info.Inventory.Length)
            {
                Enqueue(packet);
                return;
            }

            var item = ItemRentalDepositedItem;

            if (item == null)
            {
                Enqueue(packet);
                return;
            }

            if (item.Weight + CurrentBagWeight > Stats[Stat.BagWeight])
            {
                ReceiveChat("Item is too heavy to retrieve.", ChatType.System);
                Enqueue(packet);
                return;
            }

            if (Info.Inventory[to] == null)
            {
                Info.Inventory[to] = item;
                ItemRentalDepositedItem = null;

                packet.Success = true;
                RefreshBagWeight();
                UpdateRentalItem();
                Report.ItemMoved(item, MirGridType.Renting, MirGridType.Inventory, from, to);
            }

            Enqueue(packet);
        }

        private void UpdateRentalItem()
        {
            if (ItemRentalPartner == null)
                return;

            if (ItemRentalDepositedItem != null)
                ItemRentalPartner.CheckItem(ItemRentalDepositedItem);

            ItemRentalPartner.Enqueue(new S.UpdateRentalItem { LoanItem = ItemRentalDepositedItem });
        }

        public void CancelItemRental()
        {
            if (ItemRentalPartner == null)
                return;

            ItemRentalRemoveLocks();

            var rentalPair = new []  {
                ItemRentalPartner,
                this
            };

            for (var i = 0; i < 2; i++)
            {
                if (rentalPair[i] == null)
                    continue;

                if (rentalPair[i].ItemRentalDepositedItem != null)
                {
                    var item = rentalPair[i].ItemRentalDepositedItem;

                    if (FreeSpace(rentalPair[i].Info.Inventory) < 1)
                    {
                        rentalPair[i].GainItemMail(item, 1);
                        rentalPair[i].Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });
                        rentalPair[i].ItemRentalDepositedItem = null;

                        Report.ItemMailed(item, item.Count, 1);

                        continue;
                    }

                    for (var j = 0; j < rentalPair[i].Info.Inventory.Length; j++)
                    {
                        if (rentalPair[i].Info.Inventory[j] != null)
                            continue;

                        if (rentalPair[i].CanGainItem(item))
                            rentalPair[i].RetrieveRentalItem(0, j);
                        else
                        {
                            rentalPair[i].GainItemMail(item, 1);
                            rentalPair[i].Enqueue(new S.DeleteItem { UniqueID = item.UniqueID, Count = item.Count });

                            Report.ItemMailed(item, item.Count, 1);
                        }

                        rentalPair[i].ItemRentalDepositedItem = null;

                        break;
                    }
                }
 
                if (rentalPair[i].ItemRentalFeeAmount > 0)
                {
                    rentalPair[i].GainGold(rentalPair[i].ItemRentalFeeAmount);
                    rentalPair[i].ItemRentalFeeAmount = 0;

                    Report.GoldChanged(rentalPair[i].ItemRentalFeeAmount, false);
                }

                rentalPair[i].ItemRentalPartner = null;
                rentalPair[i].Enqueue(new S.CancelItemRental());
            }
        }

        public void ItemRentalLockFee()
        {
            S.ItemRentalLock p = new S.ItemRentalLock { Success = false, GoldLocked = false, ItemLocked = false };

            if (ItemRentalFeeAmount > 0)
            {
                ItemRentalFeeLocked = true;
                p.GoldLocked = true;
                p.Success = true;

                ItemRentalPartner.Enqueue(new S.ItemRentalPartnerLock { GoldLocked = ItemRentalFeeLocked });
            }

            if (ItemRentalFeeLocked && ItemRentalPartner.ItemRentalItemLocked)
                ItemRentalPartner.Enqueue(new S.CanConfirmItemRental());
            else if (ItemRentalFeeLocked && !ItemRentalPartner.ItemRentalItemLocked)
                ItemRentalPartner.ReceiveChat($"{Name} has locked in the rental fee.", ChatType.System);

            Enqueue(p);
        }

        public void ItemRentalLockItem()
        {
            S.ItemRentalLock p = new S.ItemRentalLock { Success = false, GoldLocked = false, ItemLocked = false };

            if (ItemRentalDepositedItem != null)
            {
                ItemRentalItemLocked = true;
                p.ItemLocked = true;
                p.Success = true;

                ItemRentalPartner.Enqueue(new S.ItemRentalPartnerLock { ItemLocked = ItemRentalItemLocked });
            }

            if (ItemRentalItemLocked && ItemRentalPartner.ItemRentalFeeLocked)
                Enqueue(new S.CanConfirmItemRental());
            else if (ItemRentalItemLocked && !ItemRentalPartner.ItemRentalFeeLocked)
                ItemRentalPartner.ReceiveChat($"{Name} has locked in the rental item.", ChatType.System);


            Enqueue(p);
        }

        private void ItemRentalRemoveLocks()
        {
            ItemRentalFeeLocked = false;
            ItemRentalItemLocked = false;

            if (ItemRentalPartner == null)
                return;

            ItemRentalPartner.ItemRentalFeeLocked = false;
            ItemRentalPartner.ItemRentalItemLocked = false;
        }

        public void ConfirmItemRental()
        {
            if (ItemRentalPartner == null)
            {
                CancelItemRental();
                return;
            }

            if (Info.RentedItems.Count >= 3)
            {
                CancelItemRental();
                return;
            }

            if (ItemRentalPartner.Info.HasRentedItem)
            {
                CancelItemRental();
                return;
            }

            if (ItemRentalDepositedItem == null)
                return;

            if (ItemRentalPartner.ItemRentalFeeAmount <= 0)
                return;

            if (ItemRentalDepositedItem.Info.Bind.HasFlag(BindMode.UnableToRent))
                return;

            if (ItemRentalDepositedItem.RentalInformation != null &&
                ItemRentalDepositedItem.RentalInformation.BindingFlags.HasFlag(BindMode.UnableToRent))
                return;

            if (!Functions.InRange(ItemRentalPartner.CurrentLocation, CurrentLocation, Globals.DataRange)
                || ItemRentalPartner.CurrentMap != CurrentMap || !Functions.FacingEachOther(Direction, CurrentLocation,
                    ItemRentalPartner.Direction, ItemRentalPartner.CurrentLocation))
            {
                CancelItemRental();
                return;
            }

            if (!ItemRentalItemLocked && !ItemRentalPartner.ItemRentalFeeLocked)
                return;

            if (!ItemRentalPartner.CanGainItem(ItemRentalDepositedItem))
            {
                ReceiveChat($"{ItemRentalPartner.Name} is unable to receive the item.", ChatType.System);
                Enqueue(new S.CancelItemRental());

                ItemRentalPartner.ReceiveChat("Unable to accept the rental item.", ChatType.System);
                ItemRentalPartner.Enqueue(new S.CancelItemRental());

                return;
            }

            if (!CanGainGold(ItemRentalPartner.ItemRentalFeeAmount))
            {
                ReceiveChat("You are unable to receive any more gold.", ChatType.System);
                Enqueue(new S.CancelItemRental());

                ItemRentalPartner.ReceiveChat($"{Name} is unable to receive any more gold.", ChatType.System);
                ItemRentalPartner.Enqueue(new S.CancelItemRental());

                return;
            }

            var item = ItemRentalDepositedItem;
            item.RentalInformation = new RentalInformation
            {
                OwnerName = Name,
                ExpiryDate = DateTime.Now.AddDays(ItemRentalPeriodLength),
                BindingFlags = BindMode.DontDrop | BindMode.DontStore | BindMode.DontSell | BindMode.DontTrade | BindMode.UnableToRent | BindMode.DontUpgrade | BindMode.UnableToDisassemble
            };

            var itemRentalInformation = new ItemRentalInformation
            {
                ItemId = item.UniqueID,
                ItemName = item.FriendlyName,
                RentingPlayerName = ItemRentalPartner.Name,
                ItemReturnDate = item.RentalInformation.ExpiryDate,
                
            };

            Info.RentedItems.Add(itemRentalInformation);
            ItemRentalDepositedItem = null;

            ItemRentalPartner.GainItem(item);
            ItemRentalPartner.Info.HasRentedItem = true;
            ItemRentalPartner.ReceiveChat($"You have rented {item.FriendlyName} from {Name} until {item.RentalInformation.ExpiryDate}", ChatType.System);

            GainGold(ItemRentalPartner.ItemRentalFeeAmount);
            ReceiveChat($"Received {ItemRentalPartner.ItemRentalFeeAmount} gold for item rental.", ChatType.System);
            ItemRentalPartner.ItemRentalFeeAmount = 0;

            Enqueue(new S.ConfirmItemRental());
            ItemRentalPartner.Enqueue(new S.ConfirmItemRental());

            ItemRentalRemoveLocks();

            ItemRentalPartner.ItemRentalPartner = null;
            ItemRentalPartner = null;
        }

        //ATTRIBUTES SYSTEM
        public void GainAttributePoint(int point)
        {
            if (point + Info.CurrentAttributePoints >= int.MaxValue)
                point = int.MaxValue - Info.CurrentAttributePoints;

            Info.CurrentAttributePoints += point;

            //ReceiveChat($"Received {point} attribute points.", ChatType.System);

            Enqueue(new S.UpdateAttributes
            {
                CurrentPoints = Info.CurrentAttributePoints,
                Attributes = Info.Attributes
            });
        }

        public void AddAttribute(string attribute, int value)
        {
            if (!Info.Attributes.AttributeExists(attribute)) return; //Attribute doesnt exist

            int pointsToUse = value;

            //Multiplier for HP/MP to it uses 1 point per X HP/MP given
            //This value should less than or equal to the value sent from the client (default 15)

            if (attribute == "HP" || attribute == "MP")
            {
                value *= Settings.AttributeInfo.HPMPMultiplier;
            }

            //Calculate cost per stat
            pointsToUse *= Settings.AttributeInfo.GetCost(attribute);

            if (value == 0 || Info.CurrentAttributePoints < pointsToUse || value < -50 || value > 50) return; //Not enough points or stupid values passed in

            //var currentRawValue = (int)this.GetType().GetField("attribute").GetValue(this); //Find current stat value for the chosen attribute

            var currentAttributeValue = Info.Attributes.GetValue(attribute);

            var attributeLimit = Settings.AttributeInfo.Limits.GetValue(attribute);

            if ((currentAttributeValue + value) > attributeLimit || (currentAttributeValue + value) < 0) //Limit reached
            {
                return;
            }

            Info.CurrentAttributePoints -= pointsToUse; //Take points

            Info.Attributes.AddValue(attribute, value); //Add points to stats

            Enqueue(new S.UpdateAttributes
            {
                CurrentPoints = Info.CurrentAttributePoints,
                Attributes = Info.Attributes
            });

            RefreshStats();
        }

        #endregion


        public void SetTimer(string key, int seconds, byte type = 0)
        {
            if (seconds < 0) seconds = 0;

            Timer t = new Timer(key, seconds, type);

            Enqueue(new S.SetTimer { Key = t.Key, Seconds = t.Seconds, Type = t.Type });
        }
        public void SetTimer2(string key, int seconds, byte type = 0)
        {
            if (seconds < 0) seconds = 0;

            Timer t = new Timer(key, seconds, type);

            Enqueue(new S.SetTimer2 { Key = t.Key, Seconds = t.Seconds, Type = t.Type });
        }

        public void ExpireTimer(string key)
        {
            Enqueue(new S.ExpireTimer { Key = key });
        }
        public void ExpireTimer2(string key)
        {
            Enqueue(new S.ExpireTimer2 { Key = key });
        }
    }
}

